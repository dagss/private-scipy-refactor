#cython: ccomplex=True

"""The flapack module was generated with Fwrap v0.2.0dev_8989ae1.

Below is a listing of functions and data types.
For usage information see the function docstrings.

Functions
---------
cgees(...)
cgeev(...)
cgegv(...)
cgelss(...)
cgesdd(...)
cggev(...)
chbevd, zhbevd(...)
chbevx, zhbevx(...)
cheev, zheev(...)
cheevr, zheevr(...)
chegv, zhegv(...)
chegvd, zhegvd(...)
chegvx, zhegvx(...)
cungqr, zungqr(...)
dgees(...)
dgeev(...)
dgegv(...)
dgelss(...)
dgesdd(...)
dggev(...)
sgbsv, dgbsv, cgbsv, zgbsv(...)
sgbtrf, dgbtrf, cgbtrf, zgbtrf(...)
sgbtrs, dgbtrs, cgbtrs, zgbtrs(...)
sgebal, dgebal, cgebal, zgebal(...)
sgees(...)
sgeev(...)
sgegv(...)
sgehrd, dgehrd, cgehrd, zgehrd(...)
sgelss(...)
sgeqrf, dgeqrf, cgeqrf, zgeqrf(...)
sgerqf, dgerqf, cgerqf, zgerqf(...)
sgesdd(...)
sgesv, dgesv, cgesv, zgesv(...)
sgetrf, dgetrf, cgetrf, zgetrf(...)
sgetri, dgetri, cgetri, zgetri(...)
sgetrs, dgetrs, cgetrs, zgetrs(...)
sggev(...)
slaswp, dlaswp, claswp, zlaswp(...)
slauum, dlauum, clauum, zlauum(...)
sorgqr, dorgqr(...)
spbsv, dpbsv, cpbsv, zpbsv(...)
spbtrf, dpbtrf, cpbtrf, zpbtrf(...)
spbtrs, dpbtrs, cpbtrs, zpbtrs(...)
sposv, dposv, cposv, zposv(...)
spotrf, dpotrf, cpotrf, zpotrf(...)
spotri, dpotri, cpotri, zpotri(...)
spotrs, dpotrs, cpotrs, zpotrs(...)
ssbev, dsbev(...)
ssbevd, dsbevd(...)
ssbevx, dsbevx(...)
ssyev, dsyev(...)
ssyevr, dsyevr(...)
ssygv, dsygv(...)
ssygvd, dsygvd(...)
ssygvx, dsygvx(...)
strtri, dtrtri, ctrtri, ztrtri(...)
strtrs, dtrtrs, ctrtrs, ztrtrs(...)
zgees(...)
zgeev(...)
zgegv(...)
zgelss(...)
zgesdd(...)
zggev(...)

Data Types
----------
fw_character
fw_shape
fwc_complex
fwc_complex_x16
fwi_integer
fwl_logical
fwr_dbl
fwr_real

"""
np.import_array()
include 'fwrap_ktp.pxi'
cdef extern from "string.h":
    void *memcpy(void *dest, void *src, size_t n)
cpdef api object cgees(object jobvs, object sort, bint select, fwi_integer_t n, object a, fwi_integer_t lda, fwi_integer_t sdim, object w, object vs, fwi_integer_t ldvs, object work, fwi_integer_t lwork, object rwork, object bwork, fwi_integer_t info):
    """cgees(jobvs, sort, select, n, a, lda, sdim, w, vs, ldvs, work, lwork, rwork, bwork, info[, jobvs, sort, select, n, a, lda, sdim, w, vs, ldvs, work, lwork, rwork, bwork, info]) -> (jobvs, sort, select_, n, a, lda, sdim, w, vs, ldvs, work, lwork, rwork, bwork, info)

    Parameters
    ----------
    jobvs : object_, intent inout
    sort : object_, intent inout
    select : fwl_logical, intent inout
    n : fwi_integer, intent inout
    a : fwc_complex, 2D array, dimension(lda, *), intent inout
    lda : fwi_integer, intent inout
    sdim : fwi_integer, intent inout
    w : fwc_complex, 1D array, dimension(*), intent inout
    vs : fwc_complex, 2D array, dimension(ldvs, *), intent inout
    ldvs : fwi_integer, intent inout
    work : fwc_complex, 1D array, dimension(*), intent inout
    lwork : fwi_integer, intent inout
    rwork : fwr_real, 1D array, dimension(*), intent inout
    bwork : fwl_logical, 1D array, dimension(*), intent inout
    info : fwi_integer, intent inout

    Returns
    -------
    jobvs : object_, intent inout
    sort : object_, intent inout
    select : fwl_logical, intent inout
    n : fwi_integer, intent inout
    a : fwc_complex, 2D array, dimension(lda, *), intent inout
    lda : fwi_integer, intent inout
    sdim : fwi_integer, intent inout
    w : fwc_complex, 1D array, dimension(*), intent inout
    vs : fwc_complex, 2D array, dimension(ldvs, *), intent inout
    ldvs : fwi_integer, intent inout
    work : fwc_complex, 1D array, dimension(*), intent inout
    lwork : fwi_integer, intent inout
    rwork : fwr_real, 1D array, dimension(*), intent inout
    bwork : fwl_logical, 1D array, dimension(*), intent inout
    info : fwi_integer, intent inout

    """
    cdef char *fw_jobvs = [0, 0]
    cdef char *fw_sort = [0, 0]
    cdef fwl_logical_t select_
    cdef np.ndarray a_
    cdef fw_shape_t a_shape_[2]
    cdef np.ndarray w_
    cdef fw_shape_t w_shape_[1]
    cdef np.ndarray vs_
    cdef fw_shape_t vs_shape_[2]
    cdef np.ndarray work_
    cdef fw_shape_t work_shape_[1]
    cdef np.ndarray rwork_
    cdef fw_shape_t rwork_shape_[1]
    cdef np.ndarray bwork_
    cdef fw_shape_t bwork_shape_[1]
    cdef fwi_integer_t fw_iserr__
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    select_ = 1 if select else 0
    a_, a = fw_asfortranarray(a, fwc_complex_t_enum, 2, False)
    fw_copyshape(a_shape_, np.PyArray_DIMS(a_), 2)
    if lda != a_shape_[0]:
        raise ValueError("(lda == a.shape[0]) not satisifed")
    w_, w = fw_asfortranarray(w, fwc_complex_t_enum, 1, False)
    fw_copyshape(w_shape_, np.PyArray_DIMS(w_), 1)
    vs_, vs = fw_asfortranarray(vs, fwc_complex_t_enum, 2, False)
    fw_copyshape(vs_shape_, np.PyArray_DIMS(vs_), 2)
    if ldvs != vs_shape_[0]:
        raise ValueError("(ldvs == vs.shape[0]) not satisifed")
    work_, work = fw_asfortranarray(work, fwc_complex_t_enum, 1, False)
    fw_copyshape(work_shape_, np.PyArray_DIMS(work_), 1)
    rwork_, rwork = fw_asfortranarray(rwork, fwr_real_t_enum, 1, False)
    fw_copyshape(rwork_shape_, np.PyArray_DIMS(rwork_), 1)
    bwork_, bwork = fw_asfortranarray(bwork, fwl_logical_t_enum, 1, False)
    fw_copyshape(bwork_shape_, np.PyArray_DIMS(bwork_), 1)
    fw_jobvs[0] = fw_aschar(jobvs)
    if fw_jobvs[0] == 0:
        raise ValueError("len(jobvs) != 1")
    fw_sort[0] = fw_aschar(sort)
    if fw_sort[0] == 0:
        raise ValueError("len(sort) != 1")
    cgees_c(fw_jobvs, fw_sort, &select_, &n, a_shape_, <fwc_complex_t*>np.PyArray_DATA(a_), &lda, &sdim, w_shape_, <fwc_complex_t*>np.PyArray_DATA(w_), vs_shape_, <fwc_complex_t*>np.PyArray_DATA(vs_), &ldvs, work_shape_, <fwc_complex_t*>np.PyArray_DATA(work_), &lwork, rwork_shape_, <fwr_real_t*>np.PyArray_DATA(rwork_), bwork_shape_, <fwl_logical_t*>np.PyArray_DATA(bwork_), &info, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the 'cgees' wrapper.")
    return (fw_jobvs, fw_sort, select_, n, a, lda, sdim, w, vs, ldvs, work, lwork, rwork, bwork, info,)


cpdef api object cgeev(object a, fwi_integer_t compute_vl=1, fwi_integer_t compute_vr=1, object w=None, object vl=None, object vr=None, object lwork=None, bint overwrite_a=False):
    """cgeev(a[, compute_vl, compute_vr, w, vl, vr, lwork, overwrite_a]) -> (w, vl, vr, info)

    Parameters
    ----------
    a : fwc_complex, 2D array, dimension(n, n), intent in
    compute_vl : fwi_integer, intent in
    compute_vr : fwi_integer, intent in
    w : fwc_complex, 1D array, dimension(n), intent out
    vl : fwc_complex, 2D array, dimension(ldvl, n), intent out
    vr : fwc_complex, 2D array, dimension(ldvr, n), intent out
    lwork : fwi_integer, intent in
    overwrite_a : bint_, intent in

    Returns
    -------
    w : fwc_complex, 1D array, dimension(n), intent out
    vl : fwc_complex, 2D array, dimension(ldvl, n), intent out
    vr : fwc_complex, 2D array, dimension(ldvr, n), intent out
    info : fwi_integer, intent out

    """
    cdef np.ndarray a_
    cdef fw_shape_t a_shape_[2]
    cdef np.ndarray w_
    cdef fw_shape_t w_shape_[1]
    cdef np.ndarray vl_
    cdef fw_shape_t vl_shape_[2]
    cdef np.ndarray vr_
    cdef fw_shape_t vr_shape_[2]
    cdef fwi_integer_t lwork_
    cdef fwi_integer_t n
    cdef fwi_integer_t ldvl
    cdef fwi_integer_t ldvr
    cdef np.ndarray work_
    cdef fw_shape_t work_shape_[1]
    cdef np.ndarray rwork_
    cdef fw_shape_t rwork_shape_[1]
    cdef fwi_integer_t fw_iserr__
    cdef char *fw_jobvl_f = [0, 0]
    cdef char *fw_jobvr_f = [0, 0]
    cdef fwi_integer_t info
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    jobvl_f = "V" if compute_vl else "N"
    jobvr_f = "V" if compute_vr else "N"
    a_, a = fw_asfortranarray(a, fwc_complex_t_enum, 2, not overwrite_a)
    fw_copyshape(a_shape_, np.PyArray_DIMS(a_), 2)
    n = np.PyArray_DIMS(a_)[0]
    lwork_ = lwork if (lwork is not None) else 2 * n
    if not (np.PyArray_DIMS(a_)[0] == np.PyArray_DIMS(a_)[1]):
        raise ValueError('Condition on arguments not satisfied: a.shape[0] == a.shape[1]')
    if not ((compute_vl == 1) or (compute_vl == 0)):
        raise ValueError('Condition on arguments not satisfied: (compute_vl == 1) or (compute_vl == 0)')
    if not ((compute_vr == 1) or (compute_vr == 0)):
        raise ValueError('Condition on arguments not satisfied: (compute_vr == 1) or (compute_vr == 0)')
    if not (lwork_ >= (2 * n)):
        raise ValueError('Condition on arguments not satisfied: lwork >= (2 * n)')
    if n != a_shape_[0]:
        raise ValueError("(n == a.shape[0]) not satisifed")
    if not (0 <= n <= a_shape_[1]):
        raise ValueError("(0 <= n <= a.shape[1]) not satisifed")
    w_, w = fw_explicitshapearray(w, fwc_complex_t_enum, 1, [n], False)
    fw_copyshape(w_shape_, np.PyArray_DIMS(w_), 1)
    if n != w_shape_[0]:
        raise ValueError("(n == w.shape[0]) not satisifed")
    ldvl = n if compute_vl else 1
    vl_, vl = fw_explicitshapearray(vl, fwc_complex_t_enum, 2, [ldvl, n], False)
    fw_copyshape(vl_shape_, np.PyArray_DIMS(vl_), 2)
    if ldvl != vl_shape_[0]:
        raise ValueError("(ldvl == vl.shape[0]) not satisifed")
    if not (0 <= n <= vl_shape_[1]):
        raise ValueError("(0 <= n <= vl.shape[1]) not satisifed")
    ldvr = n if compute_vr else 1
    vr_, vr = fw_explicitshapearray(vr, fwc_complex_t_enum, 2, [ldvr, n], False)
    fw_copyshape(vr_shape_, np.PyArray_DIMS(vr_), 2)
    if ldvr != vr_shape_[0]:
        raise ValueError("(ldvr == vr.shape[0]) not satisifed")
    if not (0 <= n <= vr_shape_[1]):
        raise ValueError("(0 <= n <= vr.shape[1]) not satisifed")
    work_, work = fw_explicitshapearray(None, fwc_complex_t_enum, 1, [lwork_], False)
    fw_copyshape(work_shape_, np.PyArray_DIMS(work_), 1)
    if lwork_ != work_shape_[0]:
        raise ValueError("(lwork == work.shape[0]) not satisifed")
    rwork_, rwork = fw_explicitshapearray(None, fwr_real_t_enum, 1, [2 * n], False)
    fw_copyshape(rwork_shape_, np.PyArray_DIMS(rwork_), 1)
    if 2 * n != rwork_shape_[0]:
        raise ValueError("(2 * n == rwork.shape[0]) not satisifed")
    fw_jobvl_f[0] = fw_aschar(jobvl_f)
    if fw_jobvl_f[0] == 0:
        raise ValueError("len(jobvl_f) != 1")
    fw_jobvr_f[0] = fw_aschar(jobvr_f)
    if fw_jobvr_f[0] == 0:
        raise ValueError("len(jobvr_f) != 1")
    cgeev_c(fw_jobvl_f, fw_jobvr_f, &n, a_shape_, <fwc_complex_t*>np.PyArray_DATA(a_), &n, w_shape_, <fwc_complex_t*>np.PyArray_DATA(w_), vl_shape_, <fwc_complex_t*>np.PyArray_DATA(vl_), &ldvl, vr_shape_, <fwc_complex_t*>np.PyArray_DATA(vr_), &ldvr, work_shape_, <fwc_complex_t*>np.PyArray_DATA(work_), &lwork_, rwork_shape_, <fwr_real_t*>np.PyArray_DATA(rwork_), &info, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the 'cgeev' wrapper.")
    return (w, vl, vr, info,)


cpdef api object cgegv(object a, object b, fwi_integer_t compute_vl=1, fwi_integer_t compute_vr=1, object alpha=None, object beta=None, object vl=None, object vr=None, object lwork=None, bint overwrite_a=False, bint overwrite_b=False):
    """cgegv(a, b[, compute_vl, compute_vr, alpha, beta, vl, vr, lwork, overwrite_a, overwrite_b]) -> (alpha, beta, vl, vr, info)

    Parameters
    ----------
    a : fwc_complex, 2D array, dimension(n, n), intent in
    b : fwc_complex, 2D array, dimension(n, n), intent in
    compute_vl : fwi_integer, intent in
    compute_vr : fwi_integer, intent in
    alpha : fwc_complex, 1D array, dimension(n), intent out
    beta : fwc_complex, 1D array, dimension(n), intent out
    vl : fwc_complex, 2D array, dimension(ldvl, n), intent out
    vr : fwc_complex, 2D array, dimension(ldvr, n), intent out
    lwork : fwi_integer, intent in
    overwrite_a : bint_, intent in
    overwrite_b : bint_, intent in

    Returns
    -------
    alpha : fwc_complex, 1D array, dimension(n), intent out
    beta : fwc_complex, 1D array, dimension(n), intent out
    vl : fwc_complex, 2D array, dimension(ldvl, n), intent out
    vr : fwc_complex, 2D array, dimension(ldvr, n), intent out
    info : fwi_integer, intent out

    """
    cdef np.ndarray a_
    cdef fw_shape_t a_shape_[2]
    cdef np.ndarray b_
    cdef fw_shape_t b_shape_[2]
    cdef np.ndarray alpha_
    cdef fw_shape_t alpha_shape_[1]
    cdef np.ndarray beta_
    cdef fw_shape_t beta_shape_[1]
    cdef np.ndarray vl_
    cdef fw_shape_t vl_shape_[2]
    cdef np.ndarray vr_
    cdef fw_shape_t vr_shape_[2]
    cdef fwi_integer_t lwork_
    cdef fwi_integer_t n
    cdef fwi_integer_t ldvl
    cdef fwi_integer_t ldvr
    cdef np.ndarray work_
    cdef fw_shape_t work_shape_[1]
    cdef np.ndarray rwork_
    cdef fw_shape_t rwork_shape_[1]
    cdef fwi_integer_t fw_iserr__
    cdef char *fw_jobvl_f = [0, 0]
    cdef char *fw_jobvr_f = [0, 0]
    cdef fwi_integer_t info
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    jobvl_f = "V" if compute_vl else "N"
    jobvr_f = "V" if compute_vr else "N"
    a_, a = fw_asfortranarray(a, fwc_complex_t_enum, 2, not overwrite_a)
    fw_copyshape(a_shape_, np.PyArray_DIMS(a_), 2)
    b_, b = fw_asfortranarray(b, fwc_complex_t_enum, 2, not overwrite_b)
    fw_copyshape(b_shape_, np.PyArray_DIMS(b_), 2)
    n = np.PyArray_DIMS(a_)[0]
    lwork_ = lwork if (lwork is not None) else 2 * n
    if not (np.PyArray_DIMS(a_)[0] == np.PyArray_DIMS(a_)[1]):
        raise ValueError('Condition on arguments not satisfied: a.shape[0] == a.shape[1]')
    if not ((np.PyArray_DIMS(b_)[0] == np.PyArray_DIMS(b_)[1]) and (np.PyArray_DIMS(b_)[0] == n)):
        raise ValueError('Condition on arguments not satisfied: (b.shape[0] == b.shape[1]) and (b.shape[0] == n)')
    if not ((compute_vl == 1) or (compute_vl == 0)):
        raise ValueError('Condition on arguments not satisfied: (compute_vl == 1) or (compute_vl == 0)')
    if not ((compute_vr == 1) or (compute_vr == 0)):
        raise ValueError('Condition on arguments not satisfied: (compute_vr == 1) or (compute_vr == 0)')
    if not (lwork_ >= (2 * n)):
        raise ValueError('Condition on arguments not satisfied: lwork >= (2 * n)')
    if n != a_shape_[0]:
        raise ValueError("(n == a.shape[0]) not satisifed")
    if not (0 <= n <= a_shape_[1]):
        raise ValueError("(0 <= n <= a.shape[1]) not satisifed")
    if n != b_shape_[0]:
        raise ValueError("(n == b.shape[0]) not satisifed")
    if n != b_shape_[1]:
        raise ValueError("(n == b.shape[1]) not satisifed")
    alpha_, alpha = fw_explicitshapearray(alpha, fwc_complex_t_enum, 1, [n], False)
    fw_copyshape(alpha_shape_, np.PyArray_DIMS(alpha_), 1)
    if n != alpha_shape_[0]:
        raise ValueError("(n == alpha.shape[0]) not satisifed")
    beta_, beta = fw_explicitshapearray(beta, fwc_complex_t_enum, 1, [n], False)
    fw_copyshape(beta_shape_, np.PyArray_DIMS(beta_), 1)
    if n != beta_shape_[0]:
        raise ValueError("(n == beta.shape[0]) not satisifed")
    ldvl = n if compute_vl else 1
    vl_, vl = fw_explicitshapearray(vl, fwc_complex_t_enum, 2, [ldvl, n], False)
    fw_copyshape(vl_shape_, np.PyArray_DIMS(vl_), 2)
    if ldvl != vl_shape_[0]:
        raise ValueError("(ldvl == vl.shape[0]) not satisifed")
    if not (0 <= n <= vl_shape_[1]):
        raise ValueError("(0 <= n <= vl.shape[1]) not satisifed")
    ldvr = n if compute_vr else 1
    vr_, vr = fw_explicitshapearray(vr, fwc_complex_t_enum, 2, [ldvr, n], False)
    fw_copyshape(vr_shape_, np.PyArray_DIMS(vr_), 2)
    if ldvr != vr_shape_[0]:
        raise ValueError("(ldvr == vr.shape[0]) not satisifed")
    if not (0 <= n <= vr_shape_[1]):
        raise ValueError("(0 <= n <= vr.shape[1]) not satisifed")
    work_, work = fw_explicitshapearray(None, fwc_complex_t_enum, 1, [lwork_], False)
    fw_copyshape(work_shape_, np.PyArray_DIMS(work_), 1)
    if lwork_ != work_shape_[0]:
        raise ValueError("(lwork == work.shape[0]) not satisifed")
    rwork_, rwork = fw_explicitshapearray(None, fwr_real_t_enum, 1, [8 * n], False)
    fw_copyshape(rwork_shape_, np.PyArray_DIMS(rwork_), 1)
    if 8 * n != rwork_shape_[0]:
        raise ValueError("(8 * n == rwork.shape[0]) not satisifed")
    fw_jobvl_f[0] = fw_aschar(jobvl_f)
    if fw_jobvl_f[0] == 0:
        raise ValueError("len(jobvl_f) != 1")
    fw_jobvr_f[0] = fw_aschar(jobvr_f)
    if fw_jobvr_f[0] == 0:
        raise ValueError("len(jobvr_f) != 1")
    cgegv_c(fw_jobvl_f, fw_jobvr_f, &n, a_shape_, <fwc_complex_t*>np.PyArray_DATA(a_), &n, b_shape_, <fwc_complex_t*>np.PyArray_DATA(b_), &n, alpha_shape_, <fwc_complex_t*>np.PyArray_DATA(alpha_), beta_shape_, <fwc_complex_t*>np.PyArray_DATA(beta_), vl_shape_, <fwc_complex_t*>np.PyArray_DATA(vl_), &ldvl, vr_shape_, <fwc_complex_t*>np.PyArray_DATA(vr_), &ldvr, work_shape_, <fwc_complex_t*>np.PyArray_DATA(work_), &lwork_, rwork_shape_, <fwr_real_t*>np.PyArray_DATA(rwork_), &info, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the 'cgegv' wrapper.")
    return (alpha, beta, vl, vr, info,)


cpdef api object cgelss(object a, object b, object s=None, fwr_real_t cond=-1.0, object lwork=None, bint overwrite_a=False, bint overwrite_b=False):
    """cgelss(a, b[, s, cond, lwork, overwrite_a, overwrite_b]) -> (a, b, s, r, info)

    Parameters
    ----------
    a : fwc_complex, 2D array, dimension(m, n), intent inout
    b : fwc_complex, 2D array, dimension(maxmn, nrhs), intent inout
    s : fwr_real, 1D array, dimension(minmn), intent out
    cond : fwr_real, intent in
    lwork : fwi_integer, intent in
    overwrite_a : bint_, intent in
    overwrite_b : bint_, intent in

    Returns
    -------
    a : fwc_complex, 2D array, dimension(m, n), intent inout
    b : fwc_complex, 2D array, dimension(maxmn, nrhs), intent inout
    s : fwr_real, 1D array, dimension(minmn), intent out
    r : fwi_integer, intent out
    info : fwi_integer, intent out

    """
    cdef np.ndarray a_
    cdef fw_shape_t a_shape_[2]
    cdef np.ndarray b_
    cdef fw_shape_t b_shape_[2]
    cdef np.ndarray s_
    cdef fw_shape_t s_shape_[1]
    cdef fwi_integer_t lwork_
    cdef fwi_integer_t m
    cdef fwi_integer_t n
    cdef fwi_integer_t minmn
    cdef fwi_integer_t maxmn
    cdef fwi_integer_t nrhs
    cdef np.ndarray work_
    cdef fw_shape_t work_shape_[1]
    cdef np.ndarray rwork_
    cdef fw_shape_t rwork_shape_[1]
    cdef fwi_integer_t fw_iserr__
    cdef fwi_integer_t r
    cdef fwi_integer_t info
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    b_, b = fw_asfortranarray(b, fwc_complex_t_enum, 2, not overwrite_b)
    fw_copyshape(b_shape_, np.PyArray_DIMS(b_), 2)
    nrhs = np.PyArray_DIMS(b_)[1]
    a_, a = fw_asfortranarray(a, fwc_complex_t_enum, 2, not overwrite_a)
    fw_copyshape(a_shape_, np.PyArray_DIMS(a_), 2)
    m = np.PyArray_DIMS(a_)[0]
    n = np.PyArray_DIMS(a_)[1]
    maxmn = max(m, n)
    minmn = min(m, n)
    lwork_ = lwork if (lwork is not None) else (2 * minmn) + max(maxmn, nrhs)
    if not (maxmn == np.PyArray_DIMS(b_)[0]):
        raise ValueError('Condition on arguments not satisfied: maxmn == b.shape[0]')
    if not (lwork_ >= 1):
        raise ValueError('Condition on arguments not satisfied: lwork >= 1')
    if m != a_shape_[0]:
        raise ValueError("(m == a.shape[0]) not satisifed")
    if not (0 <= n <= a_shape_[1]):
        raise ValueError("(0 <= n <= a.shape[1]) not satisifed")
    if maxmn != b_shape_[0]:
        raise ValueError("(maxmn == b.shape[0]) not satisifed")
    if not (0 <= nrhs <= b_shape_[1]):
        raise ValueError("(0 <= nrhs <= b.shape[1]) not satisifed")
    s_, s = fw_explicitshapearray(s, fwr_real_t_enum, 1, [minmn], False)
    fw_copyshape(s_shape_, np.PyArray_DIMS(s_), 1)
    if minmn != s_shape_[0]:
        raise ValueError("(minmn == s.shape[0]) not satisifed")
    work_, work = fw_explicitshapearray(None, fwc_complex_t_enum, 1, [lwork_], False)
    fw_copyshape(work_shape_, np.PyArray_DIMS(work_), 1)
    if lwork_ != work_shape_[0]:
        raise ValueError("(lwork == work.shape[0]) not satisifed")
    rwork_, rwork = fw_explicitshapearray(None, fwr_real_t_enum, 1, [(5 * minmn) - 1], False)
    fw_copyshape(rwork_shape_, np.PyArray_DIMS(rwork_), 1)
    if not (0 <= (5 * minmn) - 1 <= rwork_shape_[0]):
        raise ValueError("(0 <= (5 * minmn) - 1 <= rwork.shape[0]) not satisifed")
    cgelss_c(&m, &n, &nrhs, a_shape_, <fwc_complex_t*>np.PyArray_DATA(a_), &m, b_shape_, <fwc_complex_t*>np.PyArray_DATA(b_), &maxmn, s_shape_, <fwr_real_t*>np.PyArray_DATA(s_), &cond, &r, work_shape_, <fwc_complex_t*>np.PyArray_DATA(work_), &lwork_, rwork_shape_, <fwr_real_t*>np.PyArray_DATA(rwork_), &info, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the 'cgelss' wrapper.")
    return (a, b, s, r, info,)


cpdef api object cgesdd(object a, fwi_integer_t compute_uv=1, object u=None, object s=None, object vt=None, object lwork=None, bint overwrite_a=False):
    """cgesdd(a[, compute_uv, u, s, vt, lwork, overwrite_a]) -> (u, s, vt, info)

    Parameters
    ----------
    a : fwc_complex, 2D array, dimension(m, n), intent in
    compute_uv : fwi_integer, intent in
    u : fwc_complex, 2D array, dimension(du, du), intent out
    s : fwr_real, 1D array, dimension(minmn), intent out
    vt : fwc_complex, 2D array, dimension(dvt, dvt), intent out
    lwork : fwi_integer, intent in
    overwrite_a : bint_, intent in

    Returns
    -------
    u : fwc_complex, 2D array, dimension(du, du), intent out
    s : fwr_real, 1D array, dimension(minmn), intent out
    vt : fwc_complex, 2D array, dimension(dvt, dvt), intent out
    info : fwi_integer, intent out

    """
    cdef np.ndarray a_
    cdef fw_shape_t a_shape_[2]
    cdef np.ndarray u_
    cdef fw_shape_t u_shape_[2]
    cdef np.ndarray s_
    cdef fw_shape_t s_shape_[1]
    cdef np.ndarray vt_
    cdef fw_shape_t vt_shape_[2]
    cdef fwi_integer_t lwork_
    cdef fwi_integer_t m
    cdef fwi_integer_t n
    cdef fwi_integer_t minmn
    cdef fwi_integer_t du
    cdef fwi_integer_t dvt
    cdef np.ndarray work_
    cdef fw_shape_t work_shape_[1]
    cdef np.ndarray rwork_
    cdef fw_shape_t rwork_shape_[1]
    cdef np.ndarray iwork_
    cdef fw_shape_t iwork_shape_[1]
    cdef fwi_integer_t rwork_len
    cdef fwi_integer_t fw_iserr__
    cdef char *fw_jobz_f = [0, 0]
    cdef fwi_integer_t info
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    jobz_f = "A" if compute_uv else "N"
    a_, a = fw_asfortranarray(a, fwc_complex_t_enum, 2, not overwrite_a)
    fw_copyshape(a_shape_, np.PyArray_DIMS(a_), 2)
    m = np.PyArray_DIMS(a_)[0]
    n = np.PyArray_DIMS(a_)[1]
    minmn = min(m, n)
    lwork_ = lwork if (lwork is not None) else ((2 * minmn * minmn) + max(m, n) + (2 * minmn)) if compute_uv else ((2 * minmn) + max(m, n))
    if not ((compute_uv == 0) or (compute_uv == 1)):
        raise ValueError('Condition on arguments not satisfied: (compute_uv == 0) or (compute_uv == 1)')
    if not (lwork_ >= (((2 * minmn * minmn) + max(m, n) + (2 * minmn)) if compute_uv else ((2 * minmn) + max(m, n)))):
        raise ValueError('Condition on arguments not satisfied: lwork >= (((2 * minmn * minmn) + max(m, n) + (2 * minmn)) if compute_uv else ((2 * minmn) + max(m, n)))')
    if m != a_shape_[0]:
        raise ValueError("(m == a.shape[0]) not satisifed")
    if not (0 <= n <= a_shape_[1]):
        raise ValueError("(0 <= n <= a.shape[1]) not satisifed")
    du = m if compute_uv else 1
    u_, u = fw_explicitshapearray(u, fwc_complex_t_enum, 2, [du, du], False)
    fw_copyshape(u_shape_, np.PyArray_DIMS(u_), 2)
    if du != u_shape_[0]:
        raise ValueError("(du == u.shape[0]) not satisifed")
    if du != u_shape_[1]:
        raise ValueError("(du == u.shape[1]) not satisifed")
    s_, s = fw_explicitshapearray(s, fwr_real_t_enum, 1, [minmn], False)
    fw_copyshape(s_shape_, np.PyArray_DIMS(s_), 1)
    if minmn != s_shape_[0]:
        raise ValueError("(minmn == s.shape[0]) not satisifed")
    dvt = n if compute_uv else 1
    vt_, vt = fw_explicitshapearray(vt, fwc_complex_t_enum, 2, [dvt, dvt], False)
    fw_copyshape(vt_shape_, np.PyArray_DIMS(vt_), 2)
    if dvt != vt_shape_[0]:
        raise ValueError("(dvt == vt.shape[0]) not satisifed")
    if dvt != vt_shape_[1]:
        raise ValueError("(dvt == vt.shape[1]) not satisifed")
    work_, work = fw_explicitshapearray(None, fwc_complex_t_enum, 1, [lwork_], False)
    fw_copyshape(work_shape_, np.PyArray_DIMS(work_), 1)
    if lwork_ != work_shape_[0]:
        raise ValueError("(lwork == work.shape[0]) not satisifed")
    rwork_len = ((5 * minmn * minmn) + (7 * minmn)) if compute_uv else (5 * minmn)
    rwork_, rwork = fw_explicitshapearray(None, fwr_real_t_enum, 1, [rwork_len], False)
    fw_copyshape(rwork_shape_, np.PyArray_DIMS(rwork_), 1)
    if not (0 <= rwork_len <= rwork_shape_[0]):
        raise ValueError("(0 <= rwork_len <= rwork.shape[0]) not satisifed")
    iwork_, iwork = fw_explicitshapearray(None, fwi_integer_t_enum, 1, [8 * minmn], False)
    fw_copyshape(iwork_shape_, np.PyArray_DIMS(iwork_), 1)
    if 8 * minmn != iwork_shape_[0]:
        raise ValueError("(8 * minmn == iwork.shape[0]) not satisifed")
    fw_jobz_f[0] = fw_aschar(jobz_f)
    if fw_jobz_f[0] == 0:
        raise ValueError("len(jobz_f) != 1")
    cgesdd_c(fw_jobz_f, &m, &n, a_shape_, <fwc_complex_t*>np.PyArray_DATA(a_), &m, s_shape_, <fwr_real_t*>np.PyArray_DATA(s_), u_shape_, <fwc_complex_t*>np.PyArray_DATA(u_), &du, vt_shape_, <fwc_complex_t*>np.PyArray_DATA(vt_), &dvt, work_shape_, <fwc_complex_t*>np.PyArray_DATA(work_), &lwork_, rwork_shape_, <fwr_real_t*>np.PyArray_DATA(rwork_), iwork_shape_, <fwi_integer_t*>np.PyArray_DATA(iwork_), &info, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the 'cgesdd' wrapper.")
    return (u, s, vt, info,)


cpdef api object cggev(object a, object b, fwi_integer_t compute_vl=1, fwi_integer_t compute_vr=1, object alpha=None, object beta=None, object vl=None, object vr=None, object work=None, object lwork=None, bint overwrite_a=False, bint overwrite_b=False):
    """cggev(a, b[, compute_vl, compute_vr, alpha, beta, vl, vr, work, lwork, overwrite_a, overwrite_b]) -> (alpha, beta, vl, vr, work, info)

    Parameters
    ----------
    a : fwc_complex, 2D array, dimension(n, n), intent in
    b : fwc_complex, 2D array, dimension(n, n), intent in
    compute_vl : fwi_integer, intent in
    compute_vr : fwi_integer, intent in
    alpha : fwc_complex, 1D array, dimension(n), intent out
    beta : fwc_complex, 1D array, dimension(n), intent out
    vl : fwc_complex, 2D array, dimension(ldvl, n), intent out
    vr : fwc_complex, 2D array, dimension(ldvr, n), intent out
    work : fwc_complex, 1D array, dimension(max(lwork,1)), intent out
    lwork : fwi_integer, intent in
    overwrite_a : bint_, intent in
    overwrite_b : bint_, intent in

    Returns
    -------
    alpha : fwc_complex, 1D array, dimension(n), intent out
    beta : fwc_complex, 1D array, dimension(n), intent out
    vl : fwc_complex, 2D array, dimension(ldvl, n), intent out
    vr : fwc_complex, 2D array, dimension(ldvr, n), intent out
    work : fwc_complex, 1D array, dimension(max(lwork,1)), intent out
    info : fwi_integer, intent out

    """
    cdef np.ndarray a_
    cdef fw_shape_t a_shape_[2]
    cdef np.ndarray b_
    cdef fw_shape_t b_shape_[2]
    cdef np.ndarray alpha_
    cdef fw_shape_t alpha_shape_[1]
    cdef np.ndarray beta_
    cdef fw_shape_t beta_shape_[1]
    cdef np.ndarray vl_
    cdef fw_shape_t vl_shape_[2]
    cdef np.ndarray vr_
    cdef fw_shape_t vr_shape_[2]
    cdef np.ndarray work_
    cdef fw_shape_t work_shape_[1]
    cdef fwi_integer_t lwork_
    cdef fwi_integer_t n
    cdef fwi_integer_t ldvl
    cdef fwi_integer_t ldvr
    cdef np.ndarray rwork_
    cdef fw_shape_t rwork_shape_[1]
    cdef fwi_integer_t fw_iserr__
    cdef char *fw_jobvl_f = [0, 0]
    cdef char *fw_jobvr_f = [0, 0]
    cdef fwi_integer_t info
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    jobvl_f = "V" if compute_vl else "N"
    jobvr_f = "V" if compute_vr else "N"
    a_, a = fw_asfortranarray(a, fwc_complex_t_enum, 2, not overwrite_a)
    fw_copyshape(a_shape_, np.PyArray_DIMS(a_), 2)
    b_, b = fw_asfortranarray(b, fwc_complex_t_enum, 2, not overwrite_b)
    fw_copyshape(b_shape_, np.PyArray_DIMS(b_), 2)
    n = np.PyArray_DIMS(a_)[0]
    lwork_ = lwork if (lwork is not None) else 2 * n
    if not (np.PyArray_DIMS(a_)[0] == np.PyArray_DIMS(a_)[1]):
        raise ValueError('Condition on arguments not satisfied: a.shape[0] == a.shape[1]')
    if not (np.PyArray_DIMS(b_)[0] == np.PyArray_DIMS(b_)[1]):
        raise ValueError('Condition on arguments not satisfied: b.shape[0] == b.shape[1]')
    if not ((compute_vl == 1) or (compute_vl == 0)):
        raise ValueError('Condition on arguments not satisfied: (compute_vl == 1) or (compute_vl == 0)')
    if not ((compute_vr == 1) or (compute_vr == 0)):
        raise ValueError('Condition on arguments not satisfied: (compute_vr == 1) or (compute_vr == 0)')
    if not ((lwork_ == -1) or (lwork_ >= max(1, (2 * n)))):
        raise ValueError('Condition on arguments not satisfied: (lwork == -1) or (lwork >= max(1, (2 * n)))')
    if n != a_shape_[0]:
        raise ValueError("(n == a.shape[0]) not satisifed")
    if not (0 <= n <= a_shape_[1]):
        raise ValueError("(0 <= n <= a.shape[1]) not satisifed")
    if n != b_shape_[0]:
        raise ValueError("(n == b.shape[0]) not satisifed")
    if not (0 <= n <= b_shape_[1]):
        raise ValueError("(0 <= n <= b.shape[1]) not satisifed")
    alpha_, alpha = fw_explicitshapearray(alpha, fwc_complex_t_enum, 1, [n], False)
    fw_copyshape(alpha_shape_, np.PyArray_DIMS(alpha_), 1)
    if n != alpha_shape_[0]:
        raise ValueError("(n == alpha.shape[0]) not satisifed")
    beta_, beta = fw_explicitshapearray(beta, fwc_complex_t_enum, 1, [n], False)
    fw_copyshape(beta_shape_, np.PyArray_DIMS(beta_), 1)
    if n != beta_shape_[0]:
        raise ValueError("(n == beta.shape[0]) not satisifed")
    ldvl = n if compute_vl else 1
    vl_, vl = fw_explicitshapearray(vl, fwc_complex_t_enum, 2, [ldvl, n], False)
    fw_copyshape(vl_shape_, np.PyArray_DIMS(vl_), 2)
    if ldvl != vl_shape_[0]:
        raise ValueError("(ldvl == vl.shape[0]) not satisifed")
    if n != vl_shape_[1]:
        raise ValueError("(n == vl.shape[1]) not satisifed")
    ldvr = n if compute_vr else 1
    vr_, vr = fw_explicitshapearray(vr, fwc_complex_t_enum, 2, [ldvr, n], False)
    fw_copyshape(vr_shape_, np.PyArray_DIMS(vr_), 2)
    if ldvr != vr_shape_[0]:
        raise ValueError("(ldvr == vr.shape[0]) not satisifed")
    if n != vr_shape_[1]:
        raise ValueError("(n == vr.shape[1]) not satisifed")
    work_, work = fw_explicitshapearray(work, fwc_complex_t_enum, 1, [max(lwork_, 1)], False)
    fw_copyshape(work_shape_, np.PyArray_DIMS(work_), 1)
    if max(lwork_, 1) != work_shape_[0]:
        raise ValueError("(max(lwork, 1) == work.shape[0]) not satisifed")
    rwork_, rwork = fw_explicitshapearray(None, fwr_real_t_enum, 1, [8 * n], False)
    fw_copyshape(rwork_shape_, np.PyArray_DIMS(rwork_), 1)
    if 8 * n != rwork_shape_[0]:
        raise ValueError("(8 * n == rwork.shape[0]) not satisifed")
    fw_jobvl_f[0] = fw_aschar(jobvl_f)
    if fw_jobvl_f[0] == 0:
        raise ValueError("len(jobvl_f) != 1")
    fw_jobvr_f[0] = fw_aschar(jobvr_f)
    if fw_jobvr_f[0] == 0:
        raise ValueError("len(jobvr_f) != 1")
    cggev_c(fw_jobvl_f, fw_jobvr_f, &n, a_shape_, <fwc_complex_t*>np.PyArray_DATA(a_), &n, b_shape_, <fwc_complex_t*>np.PyArray_DATA(b_), &n, alpha_shape_, <fwc_complex_t*>np.PyArray_DATA(alpha_), beta_shape_, <fwc_complex_t*>np.PyArray_DATA(beta_), vl_shape_, <fwc_complex_t*>np.PyArray_DATA(vl_), &ldvl, vr_shape_, <fwc_complex_t*>np.PyArray_DATA(vr_), &ldvr, work_shape_, <fwc_complex_t*>np.PyArray_DATA(work_), &lwork_, rwork_shape_, <fwr_real_t*>np.PyArray_DATA(rwork_), &info, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the 'cggev' wrapper.")
    return (alpha, beta, vl, vr, work, info,)


{{for fc_name, ktp, ktp2, name, npy_enum, npy_enum2
      in zip(['chbevd_c', 'zhbevd_c'],
             ['fwc_complex_t', 'fwc_dbl_complex_t'],
             ['fwr_real_t', 'fwr_dbl_t'],
             ['chbevd', 'zhbevd'],
             ['fwc_complex_t_enum', 'fwc_dbl_complex_t_enum'],
             ['fwr_real_t_enum', 'fwr_dbl_t_enum'])}}
cpdef api object {{name}}(object ab, fwi_integer_t compute_v=1, fwi_integer_t lower=0, object ldab=None, object w=None, object z=None, object lrwork=None, object liwork=None, bint overwrite_ab=True):
    """{{name}}(ab[, compute_v, lower, ldab, w, z, lrwork, liwork, overwrite_ab]) -> (w, z, info)

    Parameters
    ----------
    ab : {{ktp}}_, 2D array, dimension(ldab, *), intent in
    compute_v : fwi_integer, intent in
    lower : fwi_integer, intent in
    ldab : fwi_integer, intent in
    w : {{ktp2}}_, 1D array, dimension(n), intent out
    z : {{ktp}}_, 2D array, dimension(ldz, ldz), intent out
    lrwork : fwi_integer, intent in
    liwork : fwi_integer, intent in
    overwrite_ab : bint_, intent in

    Returns
    -------
    w : {{ktp2}}_, 1D array, dimension(n), intent out
    z : {{ktp}}_, 2D array, dimension(ldz, ldz), intent out
    info : fwi_integer, intent out

    """
    cdef np.ndarray ab_
    cdef fw_shape_t ab_shape_[2]
    cdef fwi_integer_t ldab_
    cdef np.ndarray w_
    cdef fw_shape_t w_shape_[1]
    cdef np.ndarray z_
    cdef fw_shape_t z_shape_[2]
    cdef fwi_integer_t lrwork_
    cdef fwi_integer_t liwork_
    cdef fwi_integer_t n
    cdef fwi_integer_t kd
    cdef fwi_integer_t ldz
    cdef np.ndarray work_
    cdef fw_shape_t work_shape_[1]
    cdef fwi_integer_t lwork
    cdef np.ndarray rwork_
    cdef fw_shape_t rwork_shape_[1]
    cdef np.ndarray iwork_
    cdef fw_shape_t iwork_shape_[1]
    cdef fwi_integer_t fw_iserr__
    cdef char *fw_jobz_f = [0, 0]
    cdef char *fw_uplo_f = [0, 0]
    cdef fwi_integer_t info
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    jobz_f = "V" if compute_v else "N"
    uplo_f = "L" if lower else "U"
    ab_, ab = fw_asfortranarray(ab, {{npy_enum}}, 2, not overwrite_ab)
    fw_copyshape(ab_shape_, np.PyArray_DIMS(ab_), 2)
    kd = np.PyArray_DIMS(ab_)[0] - 1
    ldab_ = ldab if (ldab is not None) else np.PyArray_DIMS(ab_)[0]
    n = np.PyArray_DIMS(ab_)[1]
    lrwork_ = lrwork if (lrwork is not None) else (1 + (5 * n) + (2 * n * n)) if compute_v else n
    liwork_ = liwork if (liwork is not None) else (3 + (5 * n)) if compute_v else 1
    if not ((compute_v == 1) or (compute_v == 0)):
        raise ValueError('Condition on arguments not satisfied: (compute_v == 1) or (compute_v == 0)')
    if not ((lower == 0) or (lower == 1)):
        raise ValueError('Condition on arguments not satisfied: (lower == 0) or (lower == 1)')
    if not (np.PyArray_DIMS(ab_)[0] == ldab_):
        raise ValueError('Condition on arguments not satisfied: ab.shape[0] == ldab')
    if not (lrwork_ >= ((1 + (5 * n) + (2 * n * n)) if compute_v else n)):
        raise ValueError('Condition on arguments not satisfied: lrwork >= ((1 + (5 * n) + (2 * n * n)) if compute_v else n)')
    if not (liwork_ >= ((3 + (5 * n)) if compute_v else 1)):
        raise ValueError('Condition on arguments not satisfied: liwork >= ((3 + (5 * n)) if compute_v else 1)')
    if not (n > 0):
        raise ValueError('Condition on arguments not satisfied: n > 0')
    if ldab_ != ab_shape_[0]:
        raise ValueError("(ldab == ab.shape[0]) not satisifed")
    w_, w = fw_explicitshapearray(w, {{npy_enum2}}, 1, [n], False)
    fw_copyshape(w_shape_, np.PyArray_DIMS(w_), 1)
    if n != w_shape_[0]:
        raise ValueError("(n == w.shape[0]) not satisifed")
    ldz = n if compute_v else 1
    z_, z = fw_explicitshapearray(z, {{npy_enum}}, 2, [ldz, ldz], False)
    fw_copyshape(z_shape_, np.PyArray_DIMS(z_), 2)
    if ldz != z_shape_[0]:
        raise ValueError("(ldz == z.shape[0]) not satisifed")
    if ldz != z_shape_[1]:
        raise ValueError("(ldz == z.shape[1]) not satisifed")
    lwork = (2 * n * n) if compute_v else n
    work_, work = fw_explicitshapearray(None, {{npy_enum}}, 1, [lwork], False)
    fw_copyshape(work_shape_, np.PyArray_DIMS(work_), 1)
    if lwork != work_shape_[0]:
        raise ValueError("(lwork == work.shape[0]) not satisifed")
    rwork_, rwork = fw_explicitshapearray(None, {{npy_enum2}}, 1, [lrwork_], False)
    fw_copyshape(rwork_shape_, np.PyArray_DIMS(rwork_), 1)
    if lrwork_ != rwork_shape_[0]:
        raise ValueError("(lrwork == rwork.shape[0]) not satisifed")
    iwork_, iwork = fw_explicitshapearray(None, fwi_integer_t_enum, 1, [liwork_], False)
    fw_copyshape(iwork_shape_, np.PyArray_DIMS(iwork_), 1)
    if liwork_ != iwork_shape_[0]:
        raise ValueError("(liwork == iwork.shape[0]) not satisifed")
    fw_jobz_f[0] = fw_aschar(jobz_f)
    if fw_jobz_f[0] == 0:
        raise ValueError("len(jobz_f) != 1")
    fw_uplo_f[0] = fw_aschar(uplo_f)
    if fw_uplo_f[0] == 0:
        raise ValueError("len(uplo_f) != 1")
    {{fc_name}}(fw_jobz_f, fw_uplo_f, &n, &kd, ab_shape_, <{{ktp}}*>np.PyArray_DATA(ab_), &ldab_, w_shape_, <{{ktp2}}*>np.PyArray_DATA(w_), z_shape_, <{{ktp}}*>np.PyArray_DATA(z_), &ldz, work_shape_, <{{ktp}}*>np.PyArray_DATA(work_), &lwork, rwork_shape_, <{{ktp2}}*>np.PyArray_DATA(rwork_), &lrwork_, iwork_shape_, <fwi_integer_t*>np.PyArray_DATA(iwork_), &liwork_, &info, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the '{{name}}' wrapper.")
    return (w, z, info,)
{{endfor}}


{{for fc_name, ktp, ktp2, name, npy_enum, npy_enum2
      in zip(['chbevx_c', 'zhbevx_c'],
             ['fwc_complex_t', 'fwc_dbl_complex_t'],
             ['fwr_real_t', 'fwr_dbl_t'],
             ['chbevx', 'zhbevx'],
             ['fwc_complex_t_enum', 'fwc_dbl_complex_t_enum'],
             ['fwr_real_t_enum', 'fwr_dbl_t_enum'])}}
cpdef api object {{name}}(object ab, {{ktp2}} vl, {{ktp2}} vu, fwi_integer_t il, fwi_integer_t iu, object ldab=None, fwi_integer_t compute_v=1, fwi_integer_t range=0, fwi_integer_t lower=0, {{ktp2}} abstol=0.0, object w=None, object z=None, object mmax=None, object ifail=None, bint overwrite_ab=True):
    """{{name}}(ab, vl, vu, il, iu[, ldab, compute_v, range, lower, abstol, w, z, mmax, ifail, overwrite_ab]) -> (w, z, m, ifail, info)

    Parameters
    ----------
    ab : {{ktp}}_, 2D array, dimension(ldab, *), intent in
    vl : {{ktp2}}_, intent in
    vu : {{ktp2}}_, intent in
    il : fwi_integer, intent in
    iu : fwi_integer, intent in
    ldab : fwi_integer, intent in
    compute_v : fwi_integer, intent in
    range : fwi_integer, intent in
    lower : fwi_integer, intent in
    abstol : {{ktp2}}_, intent in
    w : {{ktp2}}_, 1D array, dimension(n), intent out
    z : {{ktp}}_, 2D array, dimension(ldz, mmax), intent out
    mmax : fwi_integer, intent in
    ifail : fwi_integer, 1D array, dimension(ifail_len), intent out
    overwrite_ab : bint_, intent in

    Returns
    -------
    w : {{ktp2}}_, 1D array, dimension(n), intent out
    z : {{ktp}}_, 2D array, dimension(ldz, mmax), intent out
    m : fwi_integer, intent out
    ifail : fwi_integer, 1D array, dimension(ifail_len), intent out
    info : fwi_integer, intent out

    """
    cdef np.ndarray ab_
    cdef fw_shape_t ab_shape_[2]
    cdef fwi_integer_t ldab_
    cdef np.ndarray w_
    cdef fw_shape_t w_shape_[1]
    cdef np.ndarray z_
    cdef fw_shape_t z_shape_[2]
    cdef fwi_integer_t mmax_
    cdef np.ndarray ifail_
    cdef fw_shape_t ifail_shape_[1]
    cdef fwi_integer_t n
    cdef fwi_integer_t kd
    cdef np.ndarray q_
    cdef fw_shape_t q_shape_[2]
    cdef fwi_integer_t ldq
    cdef fwi_integer_t ldz
    cdef np.ndarray work_
    cdef fw_shape_t work_shape_[1]
    cdef np.ndarray rwork_
    cdef fw_shape_t rwork_shape_[1]
    cdef np.ndarray iwork_
    cdef fw_shape_t iwork_shape_[1]
    cdef fwi_integer_t ifail_len
    cdef fwi_integer_t fw_iserr__
    cdef char *fw_jobz_f = [0, 0]
    cdef char *fw_range_f = [0, 0]
    cdef char *fw_uplo_f = [0, 0]
    cdef fwi_integer_t m
    cdef fwi_integer_t info
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    jobz_f = "V" if compute_v else "N"
    range_f = ("V" if (range == 1) else "I") if (range > 0) else "A"
    uplo_f = "L" if lower else "U"
    ab_, ab = fw_asfortranarray(ab, {{npy_enum}}, 2, not overwrite_ab)
    fw_copyshape(ab_shape_, np.PyArray_DIMS(ab_), 2)
    kd = np.PyArray_DIMS(ab_)[0] - 1
    ldab_ = ldab if (ldab is not None) else np.PyArray_DIMS(ab_)[0]
    n = np.PyArray_DIMS(ab_)[1]
    if not ((il >= 1) and (il <= n)):
        raise ValueError('Condition on arguments not satisfied: (il >= 1) and (il <= n)')
    if not ((iu >= 1) and (iu <= n) and (iu >= il)):
        raise ValueError('Condition on arguments not satisfied: (iu >= 1) and (iu <= n) and (iu >= il)')
    if not (np.PyArray_DIMS(ab_)[0] == ldab_):
        raise ValueError('Condition on arguments not satisfied: ab.shape[0] == ldab')
    if not ((compute_v == 1) or (compute_v == 0)):
        raise ValueError('Condition on arguments not satisfied: (compute_v == 1) or (compute_v == 0)')
    if not ((range == 2) or (range == 1) or (range == 0)):
        raise ValueError('Condition on arguments not satisfied: (range == 2) or (range == 1) or (range == 0)')
    if not ((lower == 0) or (lower == 1)):
        raise ValueError('Condition on arguments not satisfied: (lower == 0) or (lower == 1)')
    if ldab_ != ab_shape_[0]:
        raise ValueError("(ldab == ab.shape[0]) not satisifed")
    w_, w = fw_explicitshapearray(w, {{npy_enum2}}, 1, [n], False)
    fw_copyshape(w_shape_, np.PyArray_DIMS(w_), 1)
    if n != w_shape_[0]:
        raise ValueError("(n == w.shape[0]) not satisifed")
    mmax_ = mmax if (mmax is not None) else ((iu - il + 1) if (range == 2) else n) if compute_v else 1
    ldz = n if compute_v else 1
    z_, z = fw_explicitshapearray(z, {{npy_enum}}, 2, [ldz, mmax_], False)
    fw_copyshape(z_shape_, np.PyArray_DIMS(z_), 2)
    if ldz != z_shape_[0]:
        raise ValueError("(ldz == z.shape[0]) not satisifed")
    if not (0 <= mmax_ <= z_shape_[1]):
        raise ValueError("(0 <= mmax <= z.shape[1]) not satisifed")
    ifail_len = n if compute_v else 1
    ifail_, ifail = fw_explicitshapearray(ifail, fwi_integer_t_enum, 1, [ifail_len], False)
    fw_copyshape(ifail_shape_, np.PyArray_DIMS(ifail_), 1)
    if not (0 <= ifail_len <= ifail_shape_[0]):
        raise ValueError("(0 <= ifail_len <= ifail.shape[0]) not satisifed")
    ldq = n if compute_v else 1
    q_, q = fw_explicitshapearray(None, {{npy_enum}}, 2, [ldq, ldq], False)
    fw_copyshape(q_shape_, np.PyArray_DIMS(q_), 2)
    if ldq != q_shape_[0]:
        raise ValueError("(ldq == q.shape[0]) not satisifed")
    if ldq != q_shape_[1]:
        raise ValueError("(ldq == q.shape[1]) not satisifed")
    work_, work = fw_explicitshapearray(None, {{npy_enum}}, 1, [n], False)
    fw_copyshape(work_shape_, np.PyArray_DIMS(work_), 1)
    if not (0 <= n <= work_shape_[0]):
        raise ValueError("(0 <= n <= work.shape[0]) not satisifed")
    rwork_, rwork = fw_explicitshapearray(None, {{npy_enum2}}, 1, [7 * n], False)
    fw_copyshape(rwork_shape_, np.PyArray_DIMS(rwork_), 1)
    if not (0 <= 7 * n <= rwork_shape_[0]):
        raise ValueError("(0 <= 7 * n <= rwork.shape[0]) not satisifed")
    iwork_, iwork = fw_explicitshapearray(None, fwi_integer_t_enum, 1, [5 * n], False)
    fw_copyshape(iwork_shape_, np.PyArray_DIMS(iwork_), 1)
    if not (0 <= 5 * n <= iwork_shape_[0]):
        raise ValueError("(0 <= 5 * n <= iwork.shape[0]) not satisifed")
    fw_jobz_f[0] = fw_aschar(jobz_f)
    if fw_jobz_f[0] == 0:
        raise ValueError("len(jobz_f) != 1")
    fw_range_f[0] = fw_aschar(range_f)
    if fw_range_f[0] == 0:
        raise ValueError("len(range_f) != 1")
    fw_uplo_f[0] = fw_aschar(uplo_f)
    if fw_uplo_f[0] == 0:
        raise ValueError("len(uplo_f) != 1")
    {{fc_name}}(fw_jobz_f, fw_range_f, fw_uplo_f, &n, &kd, ab_shape_, <{{ktp}}*>np.PyArray_DATA(ab_), &ldab_, q_shape_, <{{ktp}}*>np.PyArray_DATA(q_), &ldq, &vl, &vu, &il, &iu, &abstol, &m, w_shape_, <{{ktp2}}*>np.PyArray_DATA(w_), z_shape_, <{{ktp}}*>np.PyArray_DATA(z_), &ldz, work_shape_, <{{ktp}}*>np.PyArray_DATA(work_), rwork_shape_, <{{ktp2}}*>np.PyArray_DATA(rwork_), iwork_shape_, <fwi_integer_t*>np.PyArray_DATA(iwork_), ifail_shape_, <fwi_integer_t*>np.PyArray_DATA(ifail_), &info, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the '{{name}}' wrapper.")
    return (w, z, m, ifail, info,)
{{endfor}}


{{for fc_name, ktp, ktp2, name, npy_enum, npy_enum2
      in zip(['cheev_c', 'zheev_c'],
             ['fwc_complex_t', 'fwc_dbl_complex_t'],
             ['fwr_real_t', 'fwr_dbl_t'],
             ['cheev', 'zheev'],
             ['fwc_complex_t_enum', 'fwc_dbl_complex_t_enum'],
             ['fwr_real_t_enum', 'fwr_dbl_t_enum'])}}
cpdef api object {{name}}(object a, fwi_integer_t compute_v=1, fwi_integer_t lower=0, object w=None, object lwork=None, bint overwrite_a=False):
    """{{name}}(a[, compute_v, lower, w, lwork, overwrite_a]) -> (w, a, info)

    Parameters
    ----------
    a : {{ktp}}_, 2D array, dimension(n, n), intent inout
    compute_v : fwi_integer, intent in
    lower : fwi_integer, intent in
    w : {{ktp2}}_, 1D array, dimension(n), intent out
    lwork : fwi_integer, intent in
    overwrite_a : bint_, intent in

    Returns
    -------
    w : {{ktp2}}_, 1D array, dimension(n), intent out
    a : {{ktp}}_, 2D array, dimension(n, n), intent inout
    info : fwi_integer, intent out

    """
    cdef np.ndarray a_
    cdef fw_shape_t a_shape_[2]
    cdef np.ndarray w_
    cdef fw_shape_t w_shape_[1]
    cdef fwi_integer_t lwork_
    cdef fwi_integer_t n
    cdef np.ndarray work_
    cdef fw_shape_t work_shape_[1]
    cdef np.ndarray rwork_
    cdef fw_shape_t rwork_shape_[1]
    cdef fwi_integer_t fw_iserr__
    cdef char *fw_jobz_f = [0, 0]
    cdef char *fw_uplo_f = [0, 0]
    cdef fwi_integer_t info
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    jobz_f = "V" if compute_v else "N"
    uplo_f = "L" if lower else "U"
    a_, a = fw_asfortranarray(a, {{npy_enum}}, 2, not overwrite_a)
    fw_copyshape(a_shape_, np.PyArray_DIMS(a_), 2)
    n = np.PyArray_DIMS(a_)[0]
    lwork_ = lwork if (lwork is not None) else (2 * n) - 1
    if not (np.PyArray_DIMS(a_)[0] == np.PyArray_DIMS(a_)[1]):
        raise ValueError('Condition on arguments not satisfied: a.shape[0] == a.shape[1]')
    if not ((compute_v == 1) or (compute_v == 0)):
        raise ValueError('Condition on arguments not satisfied: (compute_v == 1) or (compute_v == 0)')
    if not ((lower == 0) or (lower == 1)):
        raise ValueError('Condition on arguments not satisfied: (lower == 0) or (lower == 1)')
    if not (lwork_ >= ((2 * n) - 1)):
        raise ValueError('Condition on arguments not satisfied: lwork >= ((2 * n) - 1)')
    if n != a_shape_[0]:
        raise ValueError("(n == a.shape[0]) not satisifed")
    if not (0 <= n <= a_shape_[1]):
        raise ValueError("(0 <= n <= a.shape[1]) not satisifed")
    w_, w = fw_explicitshapearray(w, {{npy_enum2}}, 1, [n], False)
    fw_copyshape(w_shape_, np.PyArray_DIMS(w_), 1)
    if n != w_shape_[0]:
        raise ValueError("(n == w.shape[0]) not satisifed")
    work_, work = fw_explicitshapearray(None, {{npy_enum}}, 1, [lwork_], False)
    fw_copyshape(work_shape_, np.PyArray_DIMS(work_), 1)
    if lwork_ != work_shape_[0]:
        raise ValueError("(lwork == work.shape[0]) not satisifed")
    rwork_, rwork = fw_explicitshapearray(None, {{npy_enum2}}, 1, [(3 * n) - 1], False)
    fw_copyshape(rwork_shape_, np.PyArray_DIMS(rwork_), 1)
    if (3 * n) - 1 != rwork_shape_[0]:
        raise ValueError("((3 * n) - 1 == rwork.shape[0]) not satisifed")
    fw_jobz_f[0] = fw_aschar(jobz_f)
    if fw_jobz_f[0] == 0:
        raise ValueError("len(jobz_f) != 1")
    fw_uplo_f[0] = fw_aschar(uplo_f)
    if fw_uplo_f[0] == 0:
        raise ValueError("len(uplo_f) != 1")
    {{fc_name}}(fw_jobz_f, fw_uplo_f, &n, a_shape_, <{{ktp}}*>np.PyArray_DATA(a_), &n, w_shape_, <{{ktp2}}*>np.PyArray_DATA(w_), work_shape_, <{{ktp}}*>np.PyArray_DATA(work_), &lwork_, rwork_shape_, <{{ktp2}}*>np.PyArray_DATA(rwork_), &info, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the '{{name}}' wrapper.")
    return (w, a, info,)
{{endfor}}


{{for fc_name, ktp, ktp2, name, npy_enum, npy_enum2
      in zip(['cheevr_c', 'zheevr_c'],
             ['fwc_complex_t', 'fwc_complex_x16_t'],
             ['fwr_real_t', 'fwr_dbl_t'],
             ['cheevr', 'zheevr'],
             ['fwc_complex_t_enum', 'fwc_complex_x16_t_enum'],
             ['fwr_real_t_enum', 'fwr_dbl_t_enum'])}}
cpdef api object {{name}}(object a, object jobz='V', object range='A', object uplo='L', fwi_integer_t il=1, object iu=None, object w=None, object z=None, object lwork=None, bint overwrite_a=False):
    """{{name}}(a[, jobz, range, uplo, il, iu, w, z, lwork, overwrite_a]) -> (w, z, info)

    Parameters
    ----------
    a : {{ktp}}_, 2D array, dimension(n, n), intent in
    jobz : object_, intent in
    range : object_, intent in
    uplo : object_, intent in
    il : fwi_integer, intent in
    iu : fwi_integer, intent in
    w : {{ktp2}}_, 1D array, dimension(n), intent out
    z : {{ktp}}_, 2D array, dimension(n, m), intent out
    lwork : fwi_integer, intent in
    overwrite_a : bint_, intent in

    Returns
    -------
    w : {{ktp2}}_, 1D array, dimension(n), intent out
    z : {{ktp}}_, 2D array, dimension(n, m), intent out
    info : fwi_integer, intent out

    """
    cdef np.ndarray a_
    cdef fw_shape_t a_shape_[2]
    cdef char *fw_jobz = [0, 0]
    cdef char *fw_range = [0, 0]
    cdef char *fw_uplo = [0, 0]
    cdef fwi_integer_t iu_
    cdef np.ndarray w_
    cdef fw_shape_t w_shape_[1]
    cdef np.ndarray z_
    cdef fw_shape_t z_shape_[2]
    cdef fwi_integer_t lwork_
    cdef fwi_integer_t n
    cdef fwi_integer_t lda
    cdef {{ktp2}} vl
    cdef {{ktp2}} vu
    cdef {{ktp2}} abstol
    cdef fwi_integer_t m
    cdef fwi_integer_t ldz
    cdef np.ndarray isuppz_
    cdef fw_shape_t isuppz_shape_[1]
    cdef np.ndarray work_
    cdef fw_shape_t work_shape_[1]
    cdef np.ndarray rwork_
    cdef fw_shape_t rwork_shape_[1]
    cdef fwi_integer_t lrwork
    cdef np.ndarray iwork_
    cdef fw_shape_t iwork_shape_[1]
    cdef fwi_integer_t liwork
    cdef fwi_integer_t fw_iserr__
    cdef fwi_integer_t info
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    a_, a = fw_asfortranarray(a, {{npy_enum}}, 2, not overwrite_a)
    fw_copyshape(a_shape_, np.PyArray_DIMS(a_), 2)
    n = np.PyArray_DIMS(a_)[0]
    lda = n
    vl = 0
    vu = 1
    abstol = 0.
    iu_ = iu if (iu is not None) else n
    m = iu_ - il + 1
    z_, z = fw_explicitshapearray(z, {{npy_enum}}, 2, [n, m], False)
    fw_copyshape(z_shape_, np.PyArray_DIMS(z_), 2)
    ldz = n
    if not (np.PyArray_DIMS(z_)[0] == ldz):
        raise ValueError('Condition on arguments not satisfied: z.shape[0] == ldz')
    if n != a_shape_[0]:
        raise ValueError("(n == a.shape[0]) not satisifed")
    if not (0 <= n <= a_shape_[1]):
        raise ValueError("(0 <= n <= a.shape[1]) not satisifed")
    w_, w = fw_explicitshapearray(w, {{npy_enum2}}, 1, [n], False)
    fw_copyshape(w_shape_, np.PyArray_DIMS(w_), 1)
    if n != w_shape_[0]:
        raise ValueError("(n == w.shape[0]) not satisifed")
    if n != z_shape_[0]:
        raise ValueError("(n == z.shape[0]) not satisifed")
    if m != z_shape_[1]:
        raise ValueError("(m == z.shape[1]) not satisifed")
    isuppz_, isuppz = fw_explicitshapearray(None, fwi_integer_t_enum, 1, [2 * m], False)
    fw_copyshape(isuppz_shape_, np.PyArray_DIMS(isuppz_), 1)
    if not (0 <= 2 * m <= isuppz_shape_[0]):
        raise ValueError("(0 <= 2 * m <= isuppz.shape[0]) not satisifed")
    lwork_ = lwork if (lwork is not None) else 18 * n
    work_, work = fw_explicitshapearray(None, {{npy_enum}}, 1, [lwork_], False)
    fw_copyshape(work_shape_, np.PyArray_DIMS(work_), 1)
    if not (0 <= lwork_ <= work_shape_[0]):
        raise ValueError("(0 <= lwork <= work.shape[0]) not satisifed")
    lrwork = 24 * n
    rwork_, rwork = fw_explicitshapearray(None, {{npy_enum2}}, 1, [lrwork], False)
    fw_copyshape(rwork_shape_, np.PyArray_DIMS(rwork_), 1)
    if not (0 <= lrwork <= rwork_shape_[0]):
        raise ValueError("(0 <= lrwork <= rwork.shape[0]) not satisifed")
    liwork = 10 * n
    iwork_, iwork = fw_explicitshapearray(None, fwi_integer_t_enum, 1, [liwork], False)
    fw_copyshape(iwork_shape_, np.PyArray_DIMS(iwork_), 1)
    if not (0 <= liwork <= iwork_shape_[0]):
        raise ValueError("(0 <= liwork <= iwork.shape[0]) not satisifed")
    fw_jobz[0] = fw_aschar(jobz)
    if fw_jobz[0] == 0:
        raise ValueError("len(jobz) != 1")
    fw_range[0] = fw_aschar(range)
    if fw_range[0] == 0:
        raise ValueError("len(range) != 1")
    fw_uplo[0] = fw_aschar(uplo)
    if fw_uplo[0] == 0:
        raise ValueError("len(uplo) != 1")
    {{fc_name}}(fw_jobz, fw_range, fw_uplo, &n, a_shape_, <{{ktp}}*>np.PyArray_DATA(a_), &lda, &vl, &vu, &il, &iu_, &abstol, &m, w_shape_, <{{ktp2}}*>np.PyArray_DATA(w_), z_shape_, <{{ktp}}*>np.PyArray_DATA(z_), &ldz, isuppz_shape_, <fwi_integer_t*>np.PyArray_DATA(isuppz_), work_shape_, <{{ktp}}*>np.PyArray_DATA(work_), &lwork_, rwork_shape_, <{{ktp2}}*>np.PyArray_DATA(rwork_), &lrwork, iwork_shape_, <fwi_integer_t*>np.PyArray_DATA(iwork_), &liwork, &info, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the '{{name}}' wrapper.")
    return (w, z, info,)
{{endfor}}


{{for fc_name, ktp, ktp2, name, npy_enum, npy_enum2
      in zip(['chegv_c', 'zhegv_c'],
             ['fwc_complex_t', 'fwc_complex_x16_t'],
             ['fwr_real_t', 'fwr_dbl_t'],
             ['chegv', 'zhegv'],
             ['fwc_complex_t_enum', 'fwc_complex_x16_t_enum'],
             ['fwr_real_t_enum', 'fwr_dbl_t_enum'])}}
cpdef api object {{name}}(object a, object b, fwi_integer_t itype=1, object jobz='V', object uplo='L', object w=None, bint overwrite_a=False, bint overwrite_b=False):
    """{{name}}(a, b[, itype, jobz, uplo, w, overwrite_a, overwrite_b]) -> (a, w, info)

    Parameters
    ----------
    a : {{ktp}}_, 2D array, dimension(n, n), intent inout
    b : {{ktp}}_, 2D array, dimension(n, n), intent in
    itype : fwi_integer, intent in
    jobz : object_, intent in
    uplo : object_, intent in
    w : {{ktp2}}_, 1D array, dimension(n), intent out
    overwrite_a : bint_, intent in
    overwrite_b : bint_, intent in

    Returns
    -------
    a : {{ktp}}_, 2D array, dimension(n, n), intent inout
    w : {{ktp2}}_, 1D array, dimension(n), intent out
    info : fwi_integer, intent out

    """
    cdef np.ndarray a_
    cdef fw_shape_t a_shape_[2]
    cdef np.ndarray b_
    cdef fw_shape_t b_shape_[2]
    cdef char *fw_jobz = [0, 0]
    cdef char *fw_uplo = [0, 0]
    cdef np.ndarray w_
    cdef fw_shape_t w_shape_[1]
    cdef fwi_integer_t n
    cdef fwi_integer_t lda
    cdef fwi_integer_t ldb
    cdef np.ndarray work_
    cdef fw_shape_t work_shape_[1]
    cdef fwi_integer_t lwork
    cdef np.ndarray rwork_
    cdef fw_shape_t rwork_shape_[1]
    cdef fwi_integer_t fw_iserr__
    cdef fwi_integer_t info
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    a_, a = fw_asfortranarray(a, {{npy_enum}}, 2, not overwrite_a)
    fw_copyshape(a_shape_, np.PyArray_DIMS(a_), 2)
    n = np.PyArray_DIMS(a_)[0]
    lda = n
    ldb = n
    if n != a_shape_[0]:
        raise ValueError("(n == a.shape[0]) not satisifed")
    if not (0 <= n <= a_shape_[1]):
        raise ValueError("(0 <= n <= a.shape[1]) not satisifed")
    b_, b = fw_asfortranarray(b, {{npy_enum}}, 2, not overwrite_b)
    fw_copyshape(b_shape_, np.PyArray_DIMS(b_), 2)
    if n != b_shape_[0]:
        raise ValueError("(n == b.shape[0]) not satisifed")
    if not (0 <= n <= b_shape_[1]):
        raise ValueError("(0 <= n <= b.shape[1]) not satisifed")
    w_, w = fw_explicitshapearray(w, {{npy_enum2}}, 1, [n], False)
    fw_copyshape(w_shape_, np.PyArray_DIMS(w_), 1)
    if n != w_shape_[0]:
        raise ValueError("(n == w.shape[0]) not satisifed")
    lwork = (18 * n) - 1
    work_, work = fw_explicitshapearray(None, {{npy_enum}}, 1, [lwork], False)
    fw_copyshape(work_shape_, np.PyArray_DIMS(work_), 1)
    if not (0 <= lwork <= work_shape_[0]):
        raise ValueError("(0 <= lwork <= work.shape[0]) not satisifed")
    rwork_, rwork = fw_explicitshapearray(None, {{npy_enum2}}, 1, [(3 * n) - 2], False)
    fw_copyshape(rwork_shape_, np.PyArray_DIMS(rwork_), 1)
    if not (0 <= (3 * n) - 2 <= rwork_shape_[0]):
        raise ValueError("(0 <= (3 * n) - 2 <= rwork.shape[0]) not satisifed")
    fw_jobz[0] = fw_aschar(jobz)
    if fw_jobz[0] == 0:
        raise ValueError("len(jobz) != 1")
    fw_uplo[0] = fw_aschar(uplo)
    if fw_uplo[0] == 0:
        raise ValueError("len(uplo) != 1")
    {{fc_name}}(&itype, fw_jobz, fw_uplo, &n, a_shape_, <{{ktp}}*>np.PyArray_DATA(a_), &lda, b_shape_, <{{ktp}}*>np.PyArray_DATA(b_), &ldb, w_shape_, <{{ktp2}}*>np.PyArray_DATA(w_), work_shape_, <{{ktp}}*>np.PyArray_DATA(work_), &lwork, rwork_shape_, <{{ktp2}}*>np.PyArray_DATA(rwork_), &info, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the '{{name}}' wrapper.")
    return (a, w, info,)
{{endfor}}


{{for fc_name, ktp, ktp2, name, npy_enum, npy_enum2
      in zip(['chegvd_c', 'zhegvd_c'],
             ['fwc_complex_t', 'fwc_complex_x16_t'],
             ['fwr_real_t', 'fwr_dbl_t'],
             ['chegvd', 'zhegvd'],
             ['fwc_complex_t_enum', 'fwc_complex_x16_t_enum'],
             ['fwr_real_t_enum', 'fwr_dbl_t_enum'])}}
cpdef api object {{name}}(object a, object b, fwi_integer_t itype=1, object jobz='V', object uplo='L', object w=None, object lwork=None, bint overwrite_a=False, bint overwrite_b=False):
    """{{name}}(a, b[, itype, jobz, uplo, w, lwork, overwrite_a, overwrite_b]) -> (a, w, info)

    Parameters
    ----------
    a : {{ktp}}_, 2D array, dimension(n, n), intent inout
    b : {{ktp}}_, 2D array, dimension(n, n), intent in
    itype : fwi_integer, intent in
    jobz : object_, intent in
    uplo : object_, intent in
    w : {{ktp2}}_, 1D array, dimension(n), intent out
    lwork : fwi_integer, intent in
    overwrite_a : bint_, intent in
    overwrite_b : bint_, intent in

    Returns
    -------
    a : {{ktp}}_, 2D array, dimension(n, n), intent inout
    w : {{ktp2}}_, 1D array, dimension(n), intent out
    info : fwi_integer, intent out

    """
    cdef np.ndarray a_
    cdef fw_shape_t a_shape_[2]
    cdef np.ndarray b_
    cdef fw_shape_t b_shape_[2]
    cdef char *fw_jobz = [0, 0]
    cdef char *fw_uplo = [0, 0]
    cdef np.ndarray w_
    cdef fw_shape_t w_shape_[1]
    cdef fwi_integer_t lwork_
    cdef fwi_integer_t n
    cdef fwi_integer_t lda
    cdef fwi_integer_t ldb
    cdef np.ndarray work_
    cdef fw_shape_t work_shape_[1]
    cdef np.ndarray rwork_
    cdef fw_shape_t rwork_shape_[1]
    cdef fwi_integer_t lrwork
    cdef np.ndarray iwork_
    cdef fw_shape_t iwork_shape_[1]
    cdef fwi_integer_t liwork
    cdef fwi_integer_t fw_iserr__
    cdef fwi_integer_t info
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    a_, a = fw_asfortranarray(a, {{npy_enum}}, 2, not overwrite_a)
    fw_copyshape(a_shape_, np.PyArray_DIMS(a_), 2)
    n = np.PyArray_DIMS(a_)[0]
    lda = n
    ldb = n
    if n != a_shape_[0]:
        raise ValueError("(n == a.shape[0]) not satisifed")
    if not (0 <= n <= a_shape_[1]):
        raise ValueError("(0 <= n <= a.shape[1]) not satisifed")
    b_, b = fw_asfortranarray(b, {{npy_enum}}, 2, not overwrite_b)
    fw_copyshape(b_shape_, np.PyArray_DIMS(b_), 2)
    if n != b_shape_[0]:
        raise ValueError("(n == b.shape[0]) not satisifed")
    if not (0 <= n <= b_shape_[1]):
        raise ValueError("(0 <= n <= b.shape[1]) not satisifed")
    w_, w = fw_explicitshapearray(w, {{npy_enum2}}, 1, [n], False)
    fw_copyshape(w_shape_, np.PyArray_DIMS(w_), 1)
    if n != w_shape_[0]:
        raise ValueError("(n == w.shape[0]) not satisifed")
    lwork_ = lwork if (lwork is not None) else (2 * n) + (n * n)
    work_, work = fw_explicitshapearray(None, {{npy_enum}}, 1, [lwork_], False)
    fw_copyshape(work_shape_, np.PyArray_DIMS(work_), 1)
    if not (0 <= lwork_ <= work_shape_[0]):
        raise ValueError("(0 <= lwork <= work.shape[0]) not satisifed")
    lrwork = 1 + (5 * n) + (2 * n * n)
    rwork_, rwork = fw_explicitshapearray(None, {{npy_enum2}}, 1, [lrwork], False)
    fw_copyshape(rwork_shape_, np.PyArray_DIMS(rwork_), 1)
    if not (0 <= lrwork <= rwork_shape_[0]):
        raise ValueError("(0 <= lrwork <= rwork.shape[0]) not satisifed")
    liwork = 3 + (5 * n)
    iwork_, iwork = fw_explicitshapearray(None, fwi_integer_t_enum, 1, [liwork], False)
    fw_copyshape(iwork_shape_, np.PyArray_DIMS(iwork_), 1)
    if not (0 <= liwork <= iwork_shape_[0]):
        raise ValueError("(0 <= liwork <= iwork.shape[0]) not satisifed")
    fw_jobz[0] = fw_aschar(jobz)
    if fw_jobz[0] == 0:
        raise ValueError("len(jobz) != 1")
    fw_uplo[0] = fw_aschar(uplo)
    if fw_uplo[0] == 0:
        raise ValueError("len(uplo) != 1")
    {{fc_name}}(&itype, fw_jobz, fw_uplo, &n, a_shape_, <{{ktp}}*>np.PyArray_DATA(a_), &lda, b_shape_, <{{ktp}}*>np.PyArray_DATA(b_), &ldb, w_shape_, <{{ktp2}}*>np.PyArray_DATA(w_), work_shape_, <{{ktp}}*>np.PyArray_DATA(work_), &lwork_, rwork_shape_, <{{ktp2}}*>np.PyArray_DATA(rwork_), &lrwork, iwork_shape_, <fwi_integer_t*>np.PyArray_DATA(iwork_), &liwork, &info, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the '{{name}}' wrapper.")
    return (a, w, info,)
{{endfor}}


{{for fc_name, ktp, ktp2, name, npy_enum, npy_enum2
      in zip(['chegvx_c', 'zhegvx_c'],
             ['fwc_complex_t', 'fwc_complex_x16_t'],
             ['fwr_real_t', 'fwr_dbl_t'],
             ['chegvx', 'zhegvx'],
             ['fwc_complex_t_enum', 'fwc_complex_x16_t_enum'],
             ['fwr_real_t_enum', 'fwr_dbl_t_enum'])}}
cpdef api object {{name}}(object a, object b, fwi_integer_t iu, fwi_integer_t itype=1, object jobz='V', object uplo='L', fwi_integer_t il=1, object w=None, object z=None, object lwork=None, object ifail=None, bint overwrite_a=False, bint overwrite_b=False):
    """{{name}}(a, b, iu[, itype, jobz, uplo, il, w, z, lwork, ifail, overwrite_a, overwrite_b]) -> (w, z, ifail, info)

    Parameters
    ----------
    a : {{ktp}}_, 2D array, dimension(n, n), intent in
    b : {{ktp}}_, 2D array, dimension(n, n), intent in
    iu : fwi_integer, intent in
    itype : fwi_integer, intent in
    jobz : object_, intent in
    uplo : object_, intent in
    il : fwi_integer, intent in
    w : {{ktp2}}_, 1D array, dimension(n), intent out
    z : {{ktp}}_, 2D array, dimension(n, m), intent out
    lwork : fwi_integer, intent in
    ifail : fwi_integer, 1D array, dimension(n), intent out
    overwrite_a : bint_, intent in
    overwrite_b : bint_, intent in

    Returns
    -------
    w : {{ktp2}}_, 1D array, dimension(n), intent out
    z : {{ktp}}_, 2D array, dimension(n, m), intent out
    ifail : fwi_integer, 1D array, dimension(n), intent out
    info : fwi_integer, intent out

    """
    cdef np.ndarray a_
    cdef fw_shape_t a_shape_[2]
    cdef np.ndarray b_
    cdef fw_shape_t b_shape_[2]
    cdef char *fw_jobz = [0, 0]
    cdef char *fw_uplo = [0, 0]
    cdef np.ndarray w_
    cdef fw_shape_t w_shape_[1]
    cdef np.ndarray z_
    cdef fw_shape_t z_shape_[2]
    cdef fwi_integer_t lwork_
    cdef np.ndarray ifail_
    cdef fw_shape_t ifail_shape_[1]
    cdef char *fw_range = [0, 0]
    cdef fwi_integer_t n
    cdef fwi_integer_t lda
    cdef fwi_integer_t ldb
    cdef {{ktp2}} vl
    cdef {{ktp2}} vu
    cdef {{ktp2}} abstol
    cdef fwi_integer_t m
    cdef fwi_integer_t ldz
    cdef np.ndarray work_
    cdef fw_shape_t work_shape_[1]
    cdef np.ndarray rwork_
    cdef fw_shape_t rwork_shape_[1]
    cdef np.ndarray iwork_
    cdef fw_shape_t iwork_shape_[1]
    cdef fwi_integer_t fw_iserr__
    cdef fwi_integer_t info
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    range = 'I'
    a_, a = fw_asfortranarray(a, {{npy_enum}}, 2, not overwrite_a)
    fw_copyshape(a_shape_, np.PyArray_DIMS(a_), 2)
    n = np.PyArray_DIMS(a_)[0]
    lda = n
    ldb = n
    vl = 0.
    vu = 0.
    abstol = 0.
    m = iu - il + 1
    z_, z = fw_explicitshapearray(z, {{npy_enum}}, 2, [n, m], False)
    fw_copyshape(z_shape_, np.PyArray_DIMS(z_), 2)
    ldz = n
    if not (np.PyArray_DIMS(z_)[0] == ldz):
        raise ValueError('Condition on arguments not satisfied: z.shape[0] == ldz')
    if n != a_shape_[0]:
        raise ValueError("(n == a.shape[0]) not satisifed")
    if not (0 <= n <= a_shape_[1]):
        raise ValueError("(0 <= n <= a.shape[1]) not satisifed")
    b_, b = fw_asfortranarray(b, {{npy_enum}}, 2, not overwrite_b)
    fw_copyshape(b_shape_, np.PyArray_DIMS(b_), 2)
    if n != b_shape_[0]:
        raise ValueError("(n == b.shape[0]) not satisifed")
    if not (0 <= n <= b_shape_[1]):
        raise ValueError("(0 <= n <= b.shape[1]) not satisifed")
    w_, w = fw_explicitshapearray(w, {{npy_enum2}}, 1, [n], False)
    fw_copyshape(w_shape_, np.PyArray_DIMS(w_), 1)
    if n != w_shape_[0]:
        raise ValueError("(n == w.shape[0]) not satisifed")
    if n != z_shape_[0]:
        raise ValueError("(n == z.shape[0]) not satisifed")
    if m != z_shape_[1]:
        raise ValueError("(m == z.shape[1]) not satisifed")
    ifail_, ifail = fw_explicitshapearray(ifail, fwi_integer_t_enum, 1, [n], False)
    fw_copyshape(ifail_shape_, np.PyArray_DIMS(ifail_), 1)
    if n != ifail_shape_[0]:
        raise ValueError("(n == ifail.shape[0]) not satisifed")
    lwork_ = lwork if (lwork is not None) else (18 * n) - 1
    work_, work = fw_explicitshapearray(None, {{npy_enum}}, 1, [lwork_], False)
    fw_copyshape(work_shape_, np.PyArray_DIMS(work_), 1)
    if lwork_ != work_shape_[0]:
        raise ValueError("(lwork == work.shape[0]) not satisifed")
    rwork_, rwork = fw_explicitshapearray(None, {{npy_enum2}}, 1, [7 * n], False)
    fw_copyshape(rwork_shape_, np.PyArray_DIMS(rwork_), 1)
    if not (0 <= 7 * n <= rwork_shape_[0]):
        raise ValueError("(0 <= 7 * n <= rwork.shape[0]) not satisifed")
    iwork_, iwork = fw_explicitshapearray(None, fwi_integer_t_enum, 1, [5 * n], False)
    fw_copyshape(iwork_shape_, np.PyArray_DIMS(iwork_), 1)
    if not (0 <= 5 * n <= iwork_shape_[0]):
        raise ValueError("(0 <= 5 * n <= iwork.shape[0]) not satisifed")
    fw_jobz[0] = fw_aschar(jobz)
    if fw_jobz[0] == 0:
        raise ValueError("len(jobz) != 1")
    fw_range[0] = fw_aschar(range)
    if fw_range[0] == 0:
        raise ValueError("len(range) != 1")
    fw_uplo[0] = fw_aschar(uplo)
    if fw_uplo[0] == 0:
        raise ValueError("len(uplo) != 1")
    {{fc_name}}(&itype, fw_jobz, fw_range, fw_uplo, &n, a_shape_, <{{ktp}}*>np.PyArray_DATA(a_), &lda, b_shape_, <{{ktp}}*>np.PyArray_DATA(b_), &ldb, &vl, &vu, &il, &iu, &abstol, &m, w_shape_, <{{ktp2}}*>np.PyArray_DATA(w_), z_shape_, <{{ktp}}*>np.PyArray_DATA(z_), &ldz, work_shape_, <{{ktp}}*>np.PyArray_DATA(work_), &lwork_, rwork_shape_, <{{ktp2}}*>np.PyArray_DATA(rwork_), iwork_shape_, <fwi_integer_t*>np.PyArray_DATA(iwork_), ifail_shape_, <fwi_integer_t*>np.PyArray_DATA(ifail_), &info, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the '{{name}}' wrapper.")
    return (w, z, ifail, info,)
{{endfor}}


{{for fc_name, ktp, name, npy_enum
      in zip(['cungqr_c', 'zungqr_c'],
             ['fwc_complex_t', 'fwc_dbl_complex_t'],
             ['cungqr', 'zungqr'],
             ['fwc_complex_t_enum', 'fwc_dbl_complex_t_enum'])}}
cpdef api object {{name}}(object a, object tau, object work=None, object lwork=None, bint overwrite_a=False):
    """{{name}}(a, tau[, work, lwork, overwrite_a]) -> (a, work, info)

    Parameters
    ----------
    a : {{ktp}}_, 2D array, dimension(m, n), intent inout
    tau : {{ktp}}_, 1D array, dimension(k), intent in
    work : {{ktp}}_, 1D array, dimension(max(lwork,1)), intent out
    lwork : fwi_integer, intent in
    overwrite_a : bint_, intent in

    Returns
    -------
    a : {{ktp}}_, 2D array, dimension(m, n), intent inout
    work : {{ktp}}_, 1D array, dimension(max(lwork,1)), intent out
    info : fwi_integer, intent out

    """
    cdef np.ndarray a_
    cdef fw_shape_t a_shape_[2]
    cdef np.ndarray tau_
    cdef fw_shape_t tau_shape_[1]
    cdef np.ndarray work_
    cdef fw_shape_t work_shape_[1]
    cdef fwi_integer_t lwork_
    cdef fwi_integer_t m
    cdef fwi_integer_t n
    cdef fwi_integer_t k
    cdef fwi_integer_t fw_iserr__
    cdef fwi_integer_t info
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    a_, a = fw_asfortranarray(a, {{npy_enum}}, 2, not overwrite_a)
    fw_copyshape(a_shape_, np.PyArray_DIMS(a_), 2)
    n = np.PyArray_DIMS(a_)[1]
    lwork_ = lwork if (lwork is not None) else 3 * n
    if not ((lwork_ >= n) or (lwork_ == -1)):
        raise ValueError('Condition on arguments not satisfied: (lwork >= n) or (lwork == -1)')
    m = np.PyArray_DIMS(a_)[0]
    if m != a_shape_[0]:
        raise ValueError("(m == a.shape[0]) not satisifed")
    if not (0 <= n <= a_shape_[1]):
        raise ValueError("(0 <= n <= a.shape[1]) not satisifed")
    tau_, tau = fw_asfortranarray(tau, {{npy_enum}}, 1, False)
    fw_copyshape(tau_shape_, np.PyArray_DIMS(tau_), 1)
    k = np.PyArray_DIMS(tau_)[0]
    if not (0 <= k <= tau_shape_[0]):
        raise ValueError("(0 <= k <= tau.shape[0]) not satisifed")
    work_, work = fw_explicitshapearray(work, {{npy_enum}}, 1, [max(lwork_, 1)], False)
    fw_copyshape(work_shape_, np.PyArray_DIMS(work_), 1)
    if max(lwork_, 1) != work_shape_[0]:
        raise ValueError("(max(lwork, 1) == work.shape[0]) not satisifed")
    {{fc_name}}(&m, &n, &k, a_shape_, <{{ktp}}*>np.PyArray_DATA(a_), &m, tau_shape_, <{{ktp}}*>np.PyArray_DATA(tau_), work_shape_, <{{ktp}}*>np.PyArray_DATA(work_), &lwork_, &info, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the '{{name}}' wrapper.")
    return (a, work, info,)
{{endfor}}


cpdef api object dgees(object jobvs, object sort, bint select, fwi_integer_t n, object a, fwi_integer_t lda, fwi_integer_t sdim, object wr, object wi, object vs, fwi_integer_t ldvs, object work, fwi_integer_t lwork, object bwork, fwi_integer_t info):
    """dgees(jobvs, sort, select, n, a, lda, sdim, wr, wi, vs, ldvs, work, lwork, bwork, info[, jobvs, sort, select, n, a, lda, sdim, wr, wi, vs, ldvs, work, lwork, bwork, info]) -> (jobvs, sort, select_, n, a, lda, sdim, wr, wi, vs, ldvs, work, lwork, bwork, info)

    Parameters
    ----------
    jobvs : object_, intent inout
    sort : object_, intent inout
    select : fwl_logical, intent inout
    n : fwi_integer, intent inout
    a : fwr_dbl, 2D array, dimension(lda, *), intent inout
    lda : fwi_integer, intent inout
    sdim : fwi_integer, intent inout
    wr : fwr_dbl, 1D array, dimension(*), intent inout
    wi : fwr_dbl, 1D array, dimension(*), intent inout
    vs : fwr_dbl, 2D array, dimension(ldvs, *), intent inout
    ldvs : fwi_integer, intent inout
    work : fwr_dbl, 1D array, dimension(*), intent inout
    lwork : fwi_integer, intent inout
    bwork : fwl_logical, 1D array, dimension(*), intent inout
    info : fwi_integer, intent inout

    Returns
    -------
    jobvs : object_, intent inout
    sort : object_, intent inout
    select : fwl_logical, intent inout
    n : fwi_integer, intent inout
    a : fwr_dbl, 2D array, dimension(lda, *), intent inout
    lda : fwi_integer, intent inout
    sdim : fwi_integer, intent inout
    wr : fwr_dbl, 1D array, dimension(*), intent inout
    wi : fwr_dbl, 1D array, dimension(*), intent inout
    vs : fwr_dbl, 2D array, dimension(ldvs, *), intent inout
    ldvs : fwi_integer, intent inout
    work : fwr_dbl, 1D array, dimension(*), intent inout
    lwork : fwi_integer, intent inout
    bwork : fwl_logical, 1D array, dimension(*), intent inout
    info : fwi_integer, intent inout

    """
    cdef char *fw_jobvs = [0, 0]
    cdef char *fw_sort = [0, 0]
    cdef fwl_logical_t select_
    cdef np.ndarray a_
    cdef fw_shape_t a_shape_[2]
    cdef np.ndarray wr_
    cdef fw_shape_t wr_shape_[1]
    cdef np.ndarray wi_
    cdef fw_shape_t wi_shape_[1]
    cdef np.ndarray vs_
    cdef fw_shape_t vs_shape_[2]
    cdef np.ndarray work_
    cdef fw_shape_t work_shape_[1]
    cdef np.ndarray bwork_
    cdef fw_shape_t bwork_shape_[1]
    cdef fwi_integer_t fw_iserr__
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    select_ = 1 if select else 0
    a_, a = fw_asfortranarray(a, fwr_dbl_t_enum, 2, False)
    fw_copyshape(a_shape_, np.PyArray_DIMS(a_), 2)
    if lda != a_shape_[0]:
        raise ValueError("(lda == a.shape[0]) not satisifed")
    wr_, wr = fw_asfortranarray(wr, fwr_dbl_t_enum, 1, False)
    fw_copyshape(wr_shape_, np.PyArray_DIMS(wr_), 1)
    wi_, wi = fw_asfortranarray(wi, fwr_dbl_t_enum, 1, False)
    fw_copyshape(wi_shape_, np.PyArray_DIMS(wi_), 1)
    vs_, vs = fw_asfortranarray(vs, fwr_dbl_t_enum, 2, False)
    fw_copyshape(vs_shape_, np.PyArray_DIMS(vs_), 2)
    if ldvs != vs_shape_[0]:
        raise ValueError("(ldvs == vs.shape[0]) not satisifed")
    work_, work = fw_asfortranarray(work, fwr_dbl_t_enum, 1, False)
    fw_copyshape(work_shape_, np.PyArray_DIMS(work_), 1)
    bwork_, bwork = fw_asfortranarray(bwork, fwl_logical_t_enum, 1, False)
    fw_copyshape(bwork_shape_, np.PyArray_DIMS(bwork_), 1)
    fw_jobvs[0] = fw_aschar(jobvs)
    if fw_jobvs[0] == 0:
        raise ValueError("len(jobvs) != 1")
    fw_sort[0] = fw_aschar(sort)
    if fw_sort[0] == 0:
        raise ValueError("len(sort) != 1")
    dgees_c(fw_jobvs, fw_sort, &select_, &n, a_shape_, <fwr_dbl_t*>np.PyArray_DATA(a_), &lda, &sdim, wr_shape_, <fwr_dbl_t*>np.PyArray_DATA(wr_), wi_shape_, <fwr_dbl_t*>np.PyArray_DATA(wi_), vs_shape_, <fwr_dbl_t*>np.PyArray_DATA(vs_), &ldvs, work_shape_, <fwr_dbl_t*>np.PyArray_DATA(work_), &lwork, bwork_shape_, <fwl_logical_t*>np.PyArray_DATA(bwork_), &info, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the 'dgees' wrapper.")
    return (fw_jobvs, fw_sort, select_, n, a, lda, sdim, wr, wi, vs, ldvs, work, lwork, bwork, info,)


cpdef api object dgeev(object a, fwi_integer_t compute_vl=1, fwi_integer_t compute_vr=1, object wr=None, object wi=None, object vl=None, object vr=None, object lwork=None, bint overwrite_a=False):
    """dgeev(a[, compute_vl, compute_vr, wr, wi, vl, vr, lwork, overwrite_a]) -> (wr, wi, vl, vr, info)

    Parameters
    ----------
    a : fwr_dbl, 2D array, dimension(n, n), intent in
    compute_vl : fwi_integer, intent in
    compute_vr : fwi_integer, intent in
    wr : fwr_dbl, 1D array, dimension(n), intent out
    wi : fwr_dbl, 1D array, dimension(n), intent out
    vl : fwr_dbl, 2D array, dimension(ldvl, n), intent out
    vr : fwr_dbl, 2D array, dimension(ldvr, n), intent out
    lwork : fwi_integer, intent in
    overwrite_a : bint_, intent in

    Returns
    -------
    wr : fwr_dbl, 1D array, dimension(n), intent out
    wi : fwr_dbl, 1D array, dimension(n), intent out
    vl : fwr_dbl, 2D array, dimension(ldvl, n), intent out
    vr : fwr_dbl, 2D array, dimension(ldvr, n), intent out
    info : fwi_integer, intent out

    """
    cdef np.ndarray a_
    cdef fw_shape_t a_shape_[2]
    cdef np.ndarray wr_
    cdef fw_shape_t wr_shape_[1]
    cdef np.ndarray wi_
    cdef fw_shape_t wi_shape_[1]
    cdef np.ndarray vl_
    cdef fw_shape_t vl_shape_[2]
    cdef np.ndarray vr_
    cdef fw_shape_t vr_shape_[2]
    cdef fwi_integer_t lwork_
    cdef fwi_integer_t n
    cdef fwi_integer_t ldvl
    cdef fwi_integer_t ldvr
    cdef np.ndarray work_
    cdef fw_shape_t work_shape_[1]
    cdef fwi_integer_t fw_iserr__
    cdef char *fw_jobvl_f = [0, 0]
    cdef char *fw_jobvr_f = [0, 0]
    cdef fwi_integer_t info
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    jobvl_f = "V" if compute_vl else "N"
    jobvr_f = "V" if compute_vr else "N"
    a_, a = fw_asfortranarray(a, fwr_dbl_t_enum, 2, not overwrite_a)
    fw_copyshape(a_shape_, np.PyArray_DIMS(a_), 2)
    n = np.PyArray_DIMS(a_)[0]
    lwork_ = lwork if (lwork is not None) else 4 * n
    if not (np.PyArray_DIMS(a_)[0] == np.PyArray_DIMS(a_)[1]):
        raise ValueError('Condition on arguments not satisfied: a.shape[0] == a.shape[1]')
    if not ((compute_vl == 1) or (compute_vl == 0)):
        raise ValueError('Condition on arguments not satisfied: (compute_vl == 1) or (compute_vl == 0)')
    if not ((compute_vr == 1) or (compute_vr == 0)):
        raise ValueError('Condition on arguments not satisfied: (compute_vr == 1) or (compute_vr == 0)')
    if not (lwork_ >= ((4 * n) if (compute_vl or compute_vr) else (3 * n))):
        raise ValueError('Condition on arguments not satisfied: lwork >= ((4 * n) if (compute_vl or compute_vr) else (3 * n))')
    if n != a_shape_[0]:
        raise ValueError("(n == a.shape[0]) not satisifed")
    if not (0 <= n <= a_shape_[1]):
        raise ValueError("(0 <= n <= a.shape[1]) not satisifed")
    wr_, wr = fw_explicitshapearray(wr, fwr_dbl_t_enum, 1, [n], False)
    fw_copyshape(wr_shape_, np.PyArray_DIMS(wr_), 1)
    if n != wr_shape_[0]:
        raise ValueError("(n == wr.shape[0]) not satisifed")
    wi_, wi = fw_explicitshapearray(wi, fwr_dbl_t_enum, 1, [n], False)
    fw_copyshape(wi_shape_, np.PyArray_DIMS(wi_), 1)
    if n != wi_shape_[0]:
        raise ValueError("(n == wi.shape[0]) not satisifed")
    ldvl = n if compute_vl else 1
    vl_, vl = fw_explicitshapearray(vl, fwr_dbl_t_enum, 2, [ldvl, n], False)
    fw_copyshape(vl_shape_, np.PyArray_DIMS(vl_), 2)
    if ldvl != vl_shape_[0]:
        raise ValueError("(ldvl == vl.shape[0]) not satisifed")
    if not (0 <= n <= vl_shape_[1]):
        raise ValueError("(0 <= n <= vl.shape[1]) not satisifed")
    ldvr = n if compute_vr else 1
    vr_, vr = fw_explicitshapearray(vr, fwr_dbl_t_enum, 2, [ldvr, n], False)
    fw_copyshape(vr_shape_, np.PyArray_DIMS(vr_), 2)
    if ldvr != vr_shape_[0]:
        raise ValueError("(ldvr == vr.shape[0]) not satisifed")
    if not (0 <= n <= vr_shape_[1]):
        raise ValueError("(0 <= n <= vr.shape[1]) not satisifed")
    work_, work = fw_explicitshapearray(None, fwr_dbl_t_enum, 1, [lwork_], False)
    fw_copyshape(work_shape_, np.PyArray_DIMS(work_), 1)
    if lwork_ != work_shape_[0]:
        raise ValueError("(lwork == work.shape[0]) not satisifed")
    fw_jobvl_f[0] = fw_aschar(jobvl_f)
    if fw_jobvl_f[0] == 0:
        raise ValueError("len(jobvl_f) != 1")
    fw_jobvr_f[0] = fw_aschar(jobvr_f)
    if fw_jobvr_f[0] == 0:
        raise ValueError("len(jobvr_f) != 1")
    dgeev_c(fw_jobvl_f, fw_jobvr_f, &n, a_shape_, <fwr_dbl_t*>np.PyArray_DATA(a_), &n, wr_shape_, <fwr_dbl_t*>np.PyArray_DATA(wr_), wi_shape_, <fwr_dbl_t*>np.PyArray_DATA(wi_), vl_shape_, <fwr_dbl_t*>np.PyArray_DATA(vl_), &ldvl, vr_shape_, <fwr_dbl_t*>np.PyArray_DATA(vr_), &ldvr, work_shape_, <fwr_dbl_t*>np.PyArray_DATA(work_), &lwork_, &info, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the 'dgeev' wrapper.")
    return (wr, wi, vl, vr, info,)


cpdef api object dgegv(object a, object b, fwi_integer_t compute_vl=1, fwi_integer_t compute_vr=1, object alphar=None, object alphai=None, object beta=None, object vl=None, object vr=None, object lwork=None, bint overwrite_a=False, bint overwrite_b=False):
    """dgegv(a, b[, compute_vl, compute_vr, alphar, alphai, beta, vl, vr, lwork, overwrite_a, overwrite_b]) -> (alphar, alphai, beta, vl, vr, info)

    Parameters
    ----------
    a : fwr_dbl, 2D array, dimension(n, n), intent in
    b : fwr_dbl, 2D array, dimension(n, n), intent in
    compute_vl : fwi_integer, intent in
    compute_vr : fwi_integer, intent in
    alphar : fwr_dbl, 1D array, dimension(n), intent out
    alphai : fwr_dbl, 1D array, dimension(n), intent out
    beta : fwr_dbl, 1D array, dimension(n), intent out
    vl : fwr_dbl, 2D array, dimension(ldvl, n), intent out
    vr : fwr_dbl, 2D array, dimension(ldvr, n), intent out
    lwork : fwi_integer, intent in
    overwrite_a : bint_, intent in
    overwrite_b : bint_, intent in

    Returns
    -------
    alphar : fwr_dbl, 1D array, dimension(n), intent out
    alphai : fwr_dbl, 1D array, dimension(n), intent out
    beta : fwr_dbl, 1D array, dimension(n), intent out
    vl : fwr_dbl, 2D array, dimension(ldvl, n), intent out
    vr : fwr_dbl, 2D array, dimension(ldvr, n), intent out
    info : fwi_integer, intent out

    """
    cdef np.ndarray a_
    cdef fw_shape_t a_shape_[2]
    cdef np.ndarray b_
    cdef fw_shape_t b_shape_[2]
    cdef np.ndarray alphar_
    cdef fw_shape_t alphar_shape_[1]
    cdef np.ndarray alphai_
    cdef fw_shape_t alphai_shape_[1]
    cdef np.ndarray beta_
    cdef fw_shape_t beta_shape_[1]
    cdef np.ndarray vl_
    cdef fw_shape_t vl_shape_[2]
    cdef np.ndarray vr_
    cdef fw_shape_t vr_shape_[2]
    cdef fwi_integer_t lwork_
    cdef fwi_integer_t n
    cdef fwi_integer_t ldvl
    cdef fwi_integer_t ldvr
    cdef np.ndarray work_
    cdef fw_shape_t work_shape_[1]
    cdef fwi_integer_t fw_iserr__
    cdef char *fw_jobvl_f = [0, 0]
    cdef char *fw_jobvr_f = [0, 0]
    cdef fwi_integer_t info
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    jobvl_f = "V" if compute_vl else "N"
    jobvr_f = "V" if compute_vr else "N"
    a_, a = fw_asfortranarray(a, fwr_dbl_t_enum, 2, not overwrite_a)
    fw_copyshape(a_shape_, np.PyArray_DIMS(a_), 2)
    b_, b = fw_asfortranarray(b, fwr_dbl_t_enum, 2, not overwrite_b)
    fw_copyshape(b_shape_, np.PyArray_DIMS(b_), 2)
    n = np.PyArray_DIMS(a_)[0]
    lwork_ = lwork if (lwork is not None) else 8 * n
    if not (np.PyArray_DIMS(a_)[0] == np.PyArray_DIMS(a_)[1]):
        raise ValueError('Condition on arguments not satisfied: a.shape[0] == a.shape[1]')
    if not ((np.PyArray_DIMS(b_)[0] == np.PyArray_DIMS(b_)[1]) and (np.PyArray_DIMS(b_)[0] == n)):
        raise ValueError('Condition on arguments not satisfied: (b.shape[0] == b.shape[1]) and (b.shape[0] == n)')
    if not ((compute_vl == 1) or (compute_vl == 0)):
        raise ValueError('Condition on arguments not satisfied: (compute_vl == 1) or (compute_vl == 0)')
    if not ((compute_vr == 1) or (compute_vr == 0)):
        raise ValueError('Condition on arguments not satisfied: (compute_vr == 1) or (compute_vr == 0)')
    if not (lwork_ >= (8 * n)):
        raise ValueError('Condition on arguments not satisfied: lwork >= (8 * n)')
    if n != a_shape_[0]:
        raise ValueError("(n == a.shape[0]) not satisifed")
    if not (0 <= n <= a_shape_[1]):
        raise ValueError("(0 <= n <= a.shape[1]) not satisifed")
    if n != b_shape_[0]:
        raise ValueError("(n == b.shape[0]) not satisifed")
    if n != b_shape_[1]:
        raise ValueError("(n == b.shape[1]) not satisifed")
    alphar_, alphar = fw_explicitshapearray(alphar, fwr_dbl_t_enum, 1, [n], False)
    fw_copyshape(alphar_shape_, np.PyArray_DIMS(alphar_), 1)
    if n != alphar_shape_[0]:
        raise ValueError("(n == alphar.shape[0]) not satisifed")
    alphai_, alphai = fw_explicitshapearray(alphai, fwr_dbl_t_enum, 1, [n], False)
    fw_copyshape(alphai_shape_, np.PyArray_DIMS(alphai_), 1)
    if n != alphai_shape_[0]:
        raise ValueError("(n == alphai.shape[0]) not satisifed")
    beta_, beta = fw_explicitshapearray(beta, fwr_dbl_t_enum, 1, [n], False)
    fw_copyshape(beta_shape_, np.PyArray_DIMS(beta_), 1)
    if n != beta_shape_[0]:
        raise ValueError("(n == beta.shape[0]) not satisifed")
    ldvl = n if compute_vl else 1
    vl_, vl = fw_explicitshapearray(vl, fwr_dbl_t_enum, 2, [ldvl, n], False)
    fw_copyshape(vl_shape_, np.PyArray_DIMS(vl_), 2)
    if ldvl != vl_shape_[0]:
        raise ValueError("(ldvl == vl.shape[0]) not satisifed")
    if not (0 <= n <= vl_shape_[1]):
        raise ValueError("(0 <= n <= vl.shape[1]) not satisifed")
    ldvr = n if compute_vr else 1
    vr_, vr = fw_explicitshapearray(vr, fwr_dbl_t_enum, 2, [ldvr, n], False)
    fw_copyshape(vr_shape_, np.PyArray_DIMS(vr_), 2)
    if ldvr != vr_shape_[0]:
        raise ValueError("(ldvr == vr.shape[0]) not satisifed")
    if not (0 <= n <= vr_shape_[1]):
        raise ValueError("(0 <= n <= vr.shape[1]) not satisifed")
    work_, work = fw_explicitshapearray(None, fwr_dbl_t_enum, 1, [lwork_], False)
    fw_copyshape(work_shape_, np.PyArray_DIMS(work_), 1)
    if lwork_ != work_shape_[0]:
        raise ValueError("(lwork == work.shape[0]) not satisifed")
    fw_jobvl_f[0] = fw_aschar(jobvl_f)
    if fw_jobvl_f[0] == 0:
        raise ValueError("len(jobvl_f) != 1")
    fw_jobvr_f[0] = fw_aschar(jobvr_f)
    if fw_jobvr_f[0] == 0:
        raise ValueError("len(jobvr_f) != 1")
    dgegv_c(fw_jobvl_f, fw_jobvr_f, &n, a_shape_, <fwr_dbl_t*>np.PyArray_DATA(a_), &n, b_shape_, <fwr_dbl_t*>np.PyArray_DATA(b_), &n, alphar_shape_, <fwr_dbl_t*>np.PyArray_DATA(alphar_), alphai_shape_, <fwr_dbl_t*>np.PyArray_DATA(alphai_), beta_shape_, <fwr_dbl_t*>np.PyArray_DATA(beta_), vl_shape_, <fwr_dbl_t*>np.PyArray_DATA(vl_), &ldvl, vr_shape_, <fwr_dbl_t*>np.PyArray_DATA(vr_), &ldvr, work_shape_, <fwr_dbl_t*>np.PyArray_DATA(work_), &lwork_, &info, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the 'dgegv' wrapper.")
    return (alphar, alphai, beta, vl, vr, info,)


cpdef api object dgelss(object a, object b, object s=None, fwr_dbl_t cond=-1.0, object lwork=None, bint overwrite_a=False, bint overwrite_b=False):
    """dgelss(a, b[, s, cond, lwork, overwrite_a, overwrite_b]) -> (a, b, s, r, info)

    Parameters
    ----------
    a : fwr_dbl, 2D array, dimension(m, n), intent inout
    b : fwr_dbl, 2D array, dimension(maxmn, nrhs), intent inout
    s : fwr_dbl, 1D array, dimension(minmn), intent out
    cond : fwr_dbl, intent in
    lwork : fwi_integer, intent in
    overwrite_a : bint_, intent in
    overwrite_b : bint_, intent in

    Returns
    -------
    a : fwr_dbl, 2D array, dimension(m, n), intent inout
    b : fwr_dbl, 2D array, dimension(maxmn, nrhs), intent inout
    s : fwr_dbl, 1D array, dimension(minmn), intent out
    r : fwi_integer, intent out
    info : fwi_integer, intent out

    """
    cdef np.ndarray a_
    cdef fw_shape_t a_shape_[2]
    cdef np.ndarray b_
    cdef fw_shape_t b_shape_[2]
    cdef np.ndarray s_
    cdef fw_shape_t s_shape_[1]
    cdef fwi_integer_t lwork_
    cdef fwi_integer_t m
    cdef fwi_integer_t n
    cdef fwi_integer_t minmn
    cdef fwi_integer_t maxmn
    cdef fwi_integer_t nrhs
    cdef np.ndarray work_
    cdef fw_shape_t work_shape_[1]
    cdef fwi_integer_t fw_iserr__
    cdef fwi_integer_t r
    cdef fwi_integer_t info
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    b_, b = fw_asfortranarray(b, fwr_dbl_t_enum, 2, not overwrite_b)
    fw_copyshape(b_shape_, np.PyArray_DIMS(b_), 2)
    nrhs = np.PyArray_DIMS(b_)[1]
    a_, a = fw_asfortranarray(a, fwr_dbl_t_enum, 2, not overwrite_a)
    fw_copyshape(a_shape_, np.PyArray_DIMS(a_), 2)
    m = np.PyArray_DIMS(a_)[0]
    n = np.PyArray_DIMS(a_)[1]
    maxmn = max(m, n)
    minmn = min(m, n)
    lwork_ = lwork if (lwork is not None) else (3 * minmn) + max((2 * minmn), max(maxmn, nrhs))
    if not (maxmn == np.PyArray_DIMS(b_)[0]):
        raise ValueError('Condition on arguments not satisfied: maxmn == b.shape[0]')
    if not (lwork_ >= 1):
        raise ValueError('Condition on arguments not satisfied: lwork >= 1')
    if m != a_shape_[0]:
        raise ValueError("(m == a.shape[0]) not satisifed")
    if not (0 <= n <= a_shape_[1]):
        raise ValueError("(0 <= n <= a.shape[1]) not satisifed")
    if maxmn != b_shape_[0]:
        raise ValueError("(maxmn == b.shape[0]) not satisifed")
    if not (0 <= nrhs <= b_shape_[1]):
        raise ValueError("(0 <= nrhs <= b.shape[1]) not satisifed")
    s_, s = fw_explicitshapearray(s, fwr_dbl_t_enum, 1, [minmn], False)
    fw_copyshape(s_shape_, np.PyArray_DIMS(s_), 1)
    if minmn != s_shape_[0]:
        raise ValueError("(minmn == s.shape[0]) not satisifed")
    work_, work = fw_explicitshapearray(None, fwr_dbl_t_enum, 1, [lwork_], False)
    fw_copyshape(work_shape_, np.PyArray_DIMS(work_), 1)
    if lwork_ != work_shape_[0]:
        raise ValueError("(lwork == work.shape[0]) not satisifed")
    dgelss_c(&m, &n, &nrhs, a_shape_, <fwr_dbl_t*>np.PyArray_DATA(a_), &m, b_shape_, <fwr_dbl_t*>np.PyArray_DATA(b_), &maxmn, s_shape_, <fwr_dbl_t*>np.PyArray_DATA(s_), &cond, &r, work_shape_, <fwr_dbl_t*>np.PyArray_DATA(work_), &lwork_, &info, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the 'dgelss' wrapper.")
    return (a, b, s, r, info,)


cpdef api object dgesdd(object a, fwi_integer_t compute_uv=1, object u=None, object s=None, object vt=None, object lwork=None, bint overwrite_a=False):
    """dgesdd(a[, compute_uv, u, s, vt, lwork, overwrite_a]) -> (u, s, vt, info)

    Parameters
    ----------
    a : fwr_dbl, 2D array, dimension(m, n), intent in
    compute_uv : fwi_integer, intent in
    u : fwr_dbl, 2D array, dimension(du, du), intent out
    s : fwr_dbl, 1D array, dimension(minmn), intent out
    vt : fwr_dbl, 2D array, dimension(dvt, dvt), intent out
    lwork : fwi_integer, intent in
    overwrite_a : bint_, intent in

    Returns
    -------
    u : fwr_dbl, 2D array, dimension(du, du), intent out
    s : fwr_dbl, 1D array, dimension(minmn), intent out
    vt : fwr_dbl, 2D array, dimension(dvt, dvt), intent out
    info : fwi_integer, intent out

    """
    cdef np.ndarray a_
    cdef fw_shape_t a_shape_[2]
    cdef np.ndarray u_
    cdef fw_shape_t u_shape_[2]
    cdef np.ndarray s_
    cdef fw_shape_t s_shape_[1]
    cdef np.ndarray vt_
    cdef fw_shape_t vt_shape_[2]
    cdef fwi_integer_t lwork_
    cdef fwi_integer_t m
    cdef fwi_integer_t n
    cdef fwi_integer_t minmn
    cdef fwi_integer_t du
    cdef fwi_integer_t dvt
    cdef np.ndarray work_
    cdef fw_shape_t work_shape_[1]
    cdef np.ndarray iwork_
    cdef fw_shape_t iwork_shape_[1]
    cdef fwi_integer_t fw_iserr__
    cdef char *fw_jobz_f = [0, 0]
    cdef fwi_integer_t info
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    jobz_f = "A" if compute_uv else "N"
    if not ((compute_uv == 0) or (compute_uv == 1)):
        raise ValueError('Condition on arguments not satisfied: (compute_uv == 0) or (compute_uv == 1)')
    a_, a = fw_asfortranarray(a, fwr_dbl_t_enum, 2, not overwrite_a)
    fw_copyshape(a_shape_, np.PyArray_DIMS(a_), 2)
    m = np.PyArray_DIMS(a_)[0]
    n = np.PyArray_DIMS(a_)[1]
    if m != a_shape_[0]:
        raise ValueError("(m == a.shape[0]) not satisifed")
    if not (0 <= n <= a_shape_[1]):
        raise ValueError("(0 <= n <= a.shape[1]) not satisifed")
    du = m if compute_uv else 1
    u_, u = fw_explicitshapearray(u, fwr_dbl_t_enum, 2, [du, du], False)
    fw_copyshape(u_shape_, np.PyArray_DIMS(u_), 2)
    if du != u_shape_[0]:
        raise ValueError("(du == u.shape[0]) not satisifed")
    if du != u_shape_[1]:
        raise ValueError("(du == u.shape[1]) not satisifed")
    minmn = min(m, n)
    s_, s = fw_explicitshapearray(s, fwr_dbl_t_enum, 1, [minmn], False)
    fw_copyshape(s_shape_, np.PyArray_DIMS(s_), 1)
    if minmn != s_shape_[0]:
        raise ValueError("(minmn == s.shape[0]) not satisifed")
    dvt = n if compute_uv else 1
    vt_, vt = fw_explicitshapearray(vt, fwr_dbl_t_enum, 2, [dvt, dvt], False)
    fw_copyshape(vt_shape_, np.PyArray_DIMS(vt_), 2)
    if dvt != vt_shape_[0]:
        raise ValueError("(dvt == vt.shape[0]) not satisifed")
    if dvt != vt_shape_[1]:
        raise ValueError("(dvt == vt.shape[1]) not satisifed")
    lwork_ = lwork if (lwork is not None) else ((4 * minmn * minmn) + max(m, n) + (9 * minmn)) if compute_uv else (max(((14 * minmn) + 4), ((10 * minmn) + 2 + (25 * (25 + 8)))) + max(m, n))
    work_, work = fw_explicitshapearray(None, fwr_dbl_t_enum, 1, [lwork_], False)
    fw_copyshape(work_shape_, np.PyArray_DIMS(work_), 1)
    if lwork_ != work_shape_[0]:
        raise ValueError("(lwork == work.shape[0]) not satisifed")
    iwork_, iwork = fw_explicitshapearray(None, fwi_integer_t_enum, 1, [8 * minmn], False)
    fw_copyshape(iwork_shape_, np.PyArray_DIMS(iwork_), 1)
    if 8 * minmn != iwork_shape_[0]:
        raise ValueError("(8 * minmn == iwork.shape[0]) not satisifed")
    fw_jobz_f[0] = fw_aschar(jobz_f)
    if fw_jobz_f[0] == 0:
        raise ValueError("len(jobz_f) != 1")
    dgesdd_c(fw_jobz_f, &m, &n, a_shape_, <fwr_dbl_t*>np.PyArray_DATA(a_), &m, s_shape_, <fwr_dbl_t*>np.PyArray_DATA(s_), u_shape_, <fwr_dbl_t*>np.PyArray_DATA(u_), &du, vt_shape_, <fwr_dbl_t*>np.PyArray_DATA(vt_), &dvt, work_shape_, <fwr_dbl_t*>np.PyArray_DATA(work_), &lwork_, iwork_shape_, <fwi_integer_t*>np.PyArray_DATA(iwork_), &info, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the 'dgesdd' wrapper.")
    return (u, s, vt, info,)


cpdef api object dggev(object a, object b, fwi_integer_t compute_vl=1, fwi_integer_t compute_vr=1, object alphar=None, object alphai=None, object beta=None, object vl=None, object vr=None, object work=None, object lwork=None, bint overwrite_a=False, bint overwrite_b=False):
    """dggev(a, b[, compute_vl, compute_vr, alphar, alphai, beta, vl, vr, work, lwork, overwrite_a, overwrite_b]) -> (alphar, alphai, beta, vl, vr, work, info)

    Parameters
    ----------
    a : fwr_dbl, 2D array, dimension(n, n), intent in
    b : fwr_dbl, 2D array, dimension(n, n), intent in
    compute_vl : fwi_integer, intent in
    compute_vr : fwi_integer, intent in
    alphar : fwr_dbl, 1D array, dimension(n), intent out
    alphai : fwr_dbl, 1D array, dimension(n), intent out
    beta : fwr_dbl, 1D array, dimension(n), intent out
    vl : fwr_dbl, 2D array, dimension(ldvl, n), intent out
    vr : fwr_dbl, 2D array, dimension(ldvr, n), intent out
    work : fwr_dbl, 1D array, dimension(max(lwork,1)), intent out
    lwork : fwi_integer, intent in
    overwrite_a : bint_, intent in
    overwrite_b : bint_, intent in

    Returns
    -------
    alphar : fwr_dbl, 1D array, dimension(n), intent out
    alphai : fwr_dbl, 1D array, dimension(n), intent out
    beta : fwr_dbl, 1D array, dimension(n), intent out
    vl : fwr_dbl, 2D array, dimension(ldvl, n), intent out
    vr : fwr_dbl, 2D array, dimension(ldvr, n), intent out
    work : fwr_dbl, 1D array, dimension(max(lwork,1)), intent out
    info : fwi_integer, intent out

    """
    cdef np.ndarray a_
    cdef fw_shape_t a_shape_[2]
    cdef np.ndarray b_
    cdef fw_shape_t b_shape_[2]
    cdef np.ndarray alphar_
    cdef fw_shape_t alphar_shape_[1]
    cdef np.ndarray alphai_
    cdef fw_shape_t alphai_shape_[1]
    cdef np.ndarray beta_
    cdef fw_shape_t beta_shape_[1]
    cdef np.ndarray vl_
    cdef fw_shape_t vl_shape_[2]
    cdef np.ndarray vr_
    cdef fw_shape_t vr_shape_[2]
    cdef np.ndarray work_
    cdef fw_shape_t work_shape_[1]
    cdef fwi_integer_t lwork_
    cdef fwi_integer_t n
    cdef fwi_integer_t ldvl
    cdef fwi_integer_t ldvr
    cdef fwi_integer_t fw_iserr__
    cdef char *fw_jobvl_f = [0, 0]
    cdef char *fw_jobvr_f = [0, 0]
    cdef fwi_integer_t info
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    jobvl_f = "V" if compute_vl else "N"
    jobvr_f = "V" if compute_vr else "N"
    a_, a = fw_asfortranarray(a, fwr_dbl_t_enum, 2, not overwrite_a)
    fw_copyshape(a_shape_, np.PyArray_DIMS(a_), 2)
    b_, b = fw_asfortranarray(b, fwr_dbl_t_enum, 2, not overwrite_b)
    fw_copyshape(b_shape_, np.PyArray_DIMS(b_), 2)
    n = np.PyArray_DIMS(a_)[0]
    lwork_ = lwork if (lwork is not None) else 8 * n
    if not (np.PyArray_DIMS(a_)[0] == np.PyArray_DIMS(a_)[1]):
        raise ValueError('Condition on arguments not satisfied: a.shape[0] == a.shape[1]')
    if not (np.PyArray_DIMS(b_)[0] == np.PyArray_DIMS(b_)[1]):
        raise ValueError('Condition on arguments not satisfied: b.shape[0] == b.shape[1]')
    if not ((compute_vl == 1) or (compute_vl == 0)):
        raise ValueError('Condition on arguments not satisfied: (compute_vl == 1) or (compute_vl == 0)')
    if not ((compute_vr == 1) or (compute_vr == 0)):
        raise ValueError('Condition on arguments not satisfied: (compute_vr == 1) or (compute_vr == 0)')
    if not ((lwork_ == -1) or (lwork_ >= max(1, (8 * n)))):
        raise ValueError('Condition on arguments not satisfied: (lwork == -1) or (lwork >= max(1, (8 * n)))')
    if n != a_shape_[0]:
        raise ValueError("(n == a.shape[0]) not satisifed")
    if not (0 <= n <= a_shape_[1]):
        raise ValueError("(0 <= n <= a.shape[1]) not satisifed")
    if n != b_shape_[0]:
        raise ValueError("(n == b.shape[0]) not satisifed")
    if not (0 <= n <= b_shape_[1]):
        raise ValueError("(0 <= n <= b.shape[1]) not satisifed")
    alphar_, alphar = fw_explicitshapearray(alphar, fwr_dbl_t_enum, 1, [n], False)
    fw_copyshape(alphar_shape_, np.PyArray_DIMS(alphar_), 1)
    if n != alphar_shape_[0]:
        raise ValueError("(n == alphar.shape[0]) not satisifed")
    alphai_, alphai = fw_explicitshapearray(alphai, fwr_dbl_t_enum, 1, [n], False)
    fw_copyshape(alphai_shape_, np.PyArray_DIMS(alphai_), 1)
    if n != alphai_shape_[0]:
        raise ValueError("(n == alphai.shape[0]) not satisifed")
    beta_, beta = fw_explicitshapearray(beta, fwr_dbl_t_enum, 1, [n], False)
    fw_copyshape(beta_shape_, np.PyArray_DIMS(beta_), 1)
    if n != beta_shape_[0]:
        raise ValueError("(n == beta.shape[0]) not satisifed")
    ldvl = n if compute_vl else 1
    vl_, vl = fw_explicitshapearray(vl, fwr_dbl_t_enum, 2, [ldvl, n], False)
    fw_copyshape(vl_shape_, np.PyArray_DIMS(vl_), 2)
    if ldvl != vl_shape_[0]:
        raise ValueError("(ldvl == vl.shape[0]) not satisifed")
    if n != vl_shape_[1]:
        raise ValueError("(n == vl.shape[1]) not satisifed")
    ldvr = n if compute_vr else 1
    vr_, vr = fw_explicitshapearray(vr, fwr_dbl_t_enum, 2, [ldvr, n], False)
    fw_copyshape(vr_shape_, np.PyArray_DIMS(vr_), 2)
    if ldvr != vr_shape_[0]:
        raise ValueError("(ldvr == vr.shape[0]) not satisifed")
    if n != vr_shape_[1]:
        raise ValueError("(n == vr.shape[1]) not satisifed")
    work_, work = fw_explicitshapearray(work, fwr_dbl_t_enum, 1, [max(lwork_, 1)], False)
    fw_copyshape(work_shape_, np.PyArray_DIMS(work_), 1)
    if max(lwork_, 1) != work_shape_[0]:
        raise ValueError("(max(lwork, 1) == work.shape[0]) not satisifed")
    fw_jobvl_f[0] = fw_aschar(jobvl_f)
    if fw_jobvl_f[0] == 0:
        raise ValueError("len(jobvl_f) != 1")
    fw_jobvr_f[0] = fw_aschar(jobvr_f)
    if fw_jobvr_f[0] == 0:
        raise ValueError("len(jobvr_f) != 1")
    dggev_c(fw_jobvl_f, fw_jobvr_f, &n, a_shape_, <fwr_dbl_t*>np.PyArray_DATA(a_), &n, b_shape_, <fwr_dbl_t*>np.PyArray_DATA(b_), &n, alphar_shape_, <fwr_dbl_t*>np.PyArray_DATA(alphar_), alphai_shape_, <fwr_dbl_t*>np.PyArray_DATA(alphai_), beta_shape_, <fwr_dbl_t*>np.PyArray_DATA(beta_), vl_shape_, <fwr_dbl_t*>np.PyArray_DATA(vl_), &ldvl, vr_shape_, <fwr_dbl_t*>np.PyArray_DATA(vr_), &ldvr, work_shape_, <fwr_dbl_t*>np.PyArray_DATA(work_), &lwork_, &info, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the 'dggev' wrapper.")
    return (alphar, alphai, beta, vl, vr, work, info,)


{{for fc_name, ktp, name, npy_enum
      in zip(['sgbsv_c', 'dgbsv_c', 'cgbsv_c', 'zgbsv_c'],
             ['fwr_real_t', 'fwr_dbl_t', 'fwc_complex_t', 'fwc_dbl_complex_t'],
             ['sgbsv', 'dgbsv', 'cgbsv', 'zgbsv'],
             ['fwr_real_t_enum', 'fwr_dbl_t_enum', 'fwc_complex_t_enum', 'fwc_dbl_complex_t_enum'])}}
cpdef api object {{name}}(fwi_integer_t kl, fwi_integer_t ku, object ab, object b, object piv=None, bint overwrite_ab=False, bint overwrite_b=False):
    """{{name}}(kl, ku, ab, b[, piv, overwrite_ab, overwrite_b]) -> (ab, piv, b, info)

    Parameters
    ----------
    kl : fwi_integer, intent in
    ku : fwi_integer, intent in
    ab : {{ktp}}_, 2D array, dimension(2*kl+ku+1, n), intent inout
    b : {{ktp}}_, 2D array, dimension(n, nrhs), intent inout
    piv : fwi_integer, 1D array, dimension(n), intent out
    overwrite_ab : bint_, intent in
    overwrite_b : bint_, intent in

    Returns
    -------
    ab : {{ktp}}_, 2D array, dimension(2*kl+ku+1, n), intent inout
    piv : fwi_integer, 1D array, dimension(n), intent out
    b : {{ktp}}_, 2D array, dimension(n, nrhs), intent inout
    info : fwi_integer, intent out

    """
    cdef np.ndarray ab_
    cdef fw_shape_t ab_shape_[2]
    cdef np.ndarray b_
    cdef fw_shape_t b_shape_[2]
    cdef np.ndarray piv_
    cdef fw_shape_t piv_shape_[1]
    cdef fwi_integer_t n
    cdef fwi_integer_t nrhs
    cdef fwi_integer_t fw_iserr__
    cdef fwi_integer_t ldab_f
    cdef fwi_integer_t info
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    ldab_f = ##TODO (watch any dependencies that may be further down!) &i
    ab_, ab = fw_asfortranarray(ab, {{npy_enum}}, 2, not overwrite_ab)
    fw_copyshape(ab_shape_, np.PyArray_DIMS(ab_), 2)
    b_, b = fw_asfortranarray(b, {{npy_enum}}, 2, not overwrite_b)
    fw_copyshape(b_shape_, np.PyArray_DIMS(b_), 2)
    if not (((2 * kl) + ku + 1) == np.PyArray_DIMS(ab_)[0]):
        raise ValueError('Condition on arguments not satisfied: ((2 * kl) + ku + 1) == ab.shape[0]')
    if not (np.PyArray_DIMS(ab_)[1] == np.PyArray_DIMS(b_)[0]):
        raise ValueError('Condition on arguments not satisfied: ab.shape[1] == b.shape[0]')
    n = np.PyArray_DIMS(ab_)[1]
    if (2 * kl) + ku + 1 != ab_shape_[0]:
        raise ValueError("((2 * kl) + ku + 1 == ab.shape[0]) not satisifed")
    if not (0 <= n <= ab_shape_[1]):
        raise ValueError("(0 <= n <= ab.shape[1]) not satisifed")
    nrhs = np.PyArray_DIMS(b_)[1]
    if n != b_shape_[0]:
        raise ValueError("(n == b.shape[0]) not satisifed")
    if not (0 <= nrhs <= b_shape_[1]):
        raise ValueError("(0 <= nrhs <= b.shape[1]) not satisifed")
    piv_, piv = fw_explicitshapearray(piv, fwi_integer_t_enum, 1, [n], False)
    fw_copyshape(piv_shape_, np.PyArray_DIMS(piv_), 1)
    if n != piv_shape_[0]:
        raise ValueError("(n == piv.shape[0]) not satisifed")
    #TODO: int i=2*kl+ku+1;
    {{fc_name}}(&n, &kl, &ku, &nrhs, ab_shape_, <{{ktp}}*>np.PyArray_DATA(ab_), &ldab_f, piv_shape_, <fwi_integer_t*>np.PyArray_DATA(piv_), b_shape_, <{{ktp}}*>np.PyArray_DATA(b_), &n, &info, &fw_iserr__, fw_errstr__)
    try:
        if fw_iserr__ != FW_NO_ERR__:
            raise RuntimeError("an error was encountered when calling the '{{name}}' wrapper.")
    finally:
        #TODO: for(i=0;i<n;--piv[i++])
    return (ab, piv, b, info,)
{{endfor}}


{{for fc_name, ktp, name, npy_enum
      in zip(['sgbtrf_c', 'dgbtrf_c', 'cgbtrf_c', 'zgbtrf_c'],
             ['fwr_real_t', 'fwr_dbl_t', 'fwc_complex_t', 'fwc_dbl_complex_t'],
             ['sgbtrf', 'dgbtrf', 'cgbtrf', 'zgbtrf'],
             ['fwr_real_t_enum', 'fwr_dbl_t_enum', 'fwc_complex_t_enum', 'fwc_dbl_complex_t_enum'])}}
cpdef api object {{name}}(object ab, fwi_integer_t kl, fwi_integer_t ku, object m=None, object n=None, object ldab=None, object ipiv=None, bint overwrite_ab=False):
    """{{name}}(ab, kl, ku[, m, n, ldab, ipiv, overwrite_ab]) -> (ab, ipiv, info)

    Parameters
    ----------
    ab : {{ktp}}_, 2D array, dimension(ldab, *), intent inout
    kl : fwi_integer, intent in
    ku : fwi_integer, intent in
    m : fwi_integer, intent in
    n : fwi_integer, intent in
    ldab : fwi_integer, intent in
    ipiv : fwi_integer, 1D array, dimension(min(m,n)), intent out
    overwrite_ab : bint_, intent in

    Returns
    -------
    ab : {{ktp}}_, 2D array, dimension(ldab, *), intent inout
    ipiv : fwi_integer, 1D array, dimension(min(m,n)), intent out
    info : fwi_integer, intent out

    """
    cdef np.ndarray ab_
    cdef fw_shape_t ab_shape_[2]
    cdef fwi_integer_t m_
    cdef fwi_integer_t n_
    cdef fwi_integer_t ldab_
    cdef np.ndarray ipiv_
    cdef fw_shape_t ipiv_shape_[1]
    cdef fwi_integer_t fw_iserr__
    cdef fwi_integer_t info
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    ab_, ab = fw_asfortranarray(ab, {{npy_enum}}, 2, not overwrite_ab)
    fw_copyshape(ab_shape_, np.PyArray_DIMS(ab_), 2)
    ldab_ = ldab if (ldab is not None) else np.PyArray_DIMS(ab_)[0]
    if not (np.PyArray_DIMS(ab_)[0] == ldab_):
        raise ValueError('Condition on arguments not satisfied: ab.shape[0] == ldab')
    if ldab_ != ab_shape_[0]:
        raise ValueError("(ldab == ab.shape[0]) not satisifed")
    m_ = m if (m is not None) else np.PyArray_DIMS(ab_)[1]
    n_ = n if (n is not None) else np.PyArray_DIMS(ab_)[1]
    ipiv_, ipiv = fw_explicitshapearray(ipiv, fwi_integer_t_enum, 1, [min(m_, n_)], False)
    fw_copyshape(ipiv_shape_, np.PyArray_DIMS(ipiv_), 1)
    if min(m_, n_) != ipiv_shape_[0]:
        raise ValueError("(min(m, n) == ipiv.shape[0]) not satisifed")
    #TODO: int i;
    {{fc_name}}(&m_, &n_, &kl, &ku, ab_shape_, <{{ktp}}*>np.PyArray_DATA(ab_), &ldab_, ipiv_shape_, <fwi_integer_t*>np.PyArray_DATA(ipiv_), &info, &fw_iserr__, fw_errstr__)
    try:
        if fw_iserr__ != FW_NO_ERR__:
            raise RuntimeError("an error was encountered when calling the '{{name}}' wrapper.")
    finally:
        #TODO: for(i=0,n=MIN(m,n);i<n;--ipiv[i++])
    return (ab, ipiv, info,)
{{endfor}}


{{for fc_name, ktp, name, npy_enum
      in zip(['sgbtrs_c', 'dgbtrs_c', 'cgbtrs_c', 'zgbtrs_c'],
             ['fwr_real_t', 'fwr_dbl_t', 'fwc_complex_t', 'fwc_dbl_complex_t'],
             ['sgbtrs', 'dgbtrs', 'cgbtrs', 'zgbtrs'],
             ['fwr_real_t_enum', 'fwr_dbl_t_enum', 'fwc_complex_t_enum', 'fwc_dbl_complex_t_enum'])}}
cpdef api object {{name}}(object ab, fwi_integer_t kl, fwi_integer_t ku, object b, object ipiv, fwi_integer_t trans=0, object n=None, object ldab=None, object ldb=None, bint overwrite_b=False):
    """{{name}}(ab, kl, ku, b, ipiv[, trans, n, ldab, ldb, overwrite_b]) -> (b, info)

    Parameters
    ----------
    ab : {{ktp}}_, 2D array, dimension(ldab, *), intent in
    kl : fwi_integer, intent in
    ku : fwi_integer, intent in
    b : {{ktp}}_, 2D array, dimension(ldb, *), intent inout
    ipiv : fwi_integer, 1D array, dimension(n), intent in
    trans : fwi_integer, intent in
    n : fwi_integer, intent in
    ldab : fwi_integer, intent in
    ldb : fwi_integer, intent in
    overwrite_b : bint_, intent in

    Returns
    -------
    b : {{ktp}}_, 2D array, dimension(ldb, *), intent inout
    info : fwi_integer, intent out

    """
    cdef np.ndarray ab_
    cdef fw_shape_t ab_shape_[2]
    cdef np.ndarray b_
    cdef fw_shape_t b_shape_[2]
    cdef np.ndarray ipiv_
    cdef fw_shape_t ipiv_shape_[1]
    cdef fwi_integer_t n_
    cdef fwi_integer_t ldab_
    cdef fwi_integer_t ldb_
    cdef fwi_integer_t nrhs
    cdef fwi_integer_t fw_iserr__
    cdef char *fw_trans_f = [0, 0]
    cdef fwi_integer_t info
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    trans_f = ("T" if (trans == 1) else "C") if (trans > 0) else "N"
    b_, b = fw_asfortranarray(b, {{npy_enum}}, 2, not overwrite_b)
    fw_copyshape(b_shape_, np.PyArray_DIMS(b_), 2)
    nrhs = np.PyArray_DIMS(b_)[1]
    ab_, ab = fw_asfortranarray(ab, {{npy_enum}}, 2, False)
    fw_copyshape(ab_shape_, np.PyArray_DIMS(ab_), 2)
    ldab_ = ldab if (ldab is not None) else np.PyArray_DIMS(ab_)[0]
    ldb_ = ldb if (ldb is not None) else np.PyArray_DIMS(b_)[0]
    if not (np.PyArray_DIMS(ab_)[0] == ldab_):
        raise ValueError('Condition on arguments not satisfied: ab.shape[0] == ldab')
    if not (np.PyArray_DIMS(b_)[0] == ldb_):
        raise ValueError('Condition on arguments not satisfied: b.shape[0] == ldb')
    if not (np.PyArray_DIMS(b_)[0] == ldb_):
        raise ValueError('Condition on arguments not satisfied: b.shape[0] == ldb')
    if ldab_ != ab_shape_[0]:
        raise ValueError("(ldab == ab.shape[0]) not satisifed")
    if ldb_ != b_shape_[0]:
        raise ValueError("(ldb == b.shape[0]) not satisifed")
    ipiv_, ipiv = fw_asfortranarray(ipiv, fwi_integer_t_enum, 1, False)
    fw_copyshape(ipiv_shape_, np.PyArray_DIMS(ipiv_), 1)
    n_ = n if (n is not None) else np.PyArray_DIMS(ab_)[1]
    if not (0 <= n_ <= ipiv_shape_[0]):
        raise ValueError("(0 <= n <= ipiv.shape[0]) not satisifed")
    fw_trans_f[0] = fw_aschar(trans_f)
    if fw_trans_f[0] == 0:
        raise ValueError("len(trans_f) != 1")
    #TODO: int i;for(i=0;i<n;++ipiv[i++]);
    {{fc_name}}(fw_trans_f, &n_, &kl, &ku, &nrhs, ab_shape_, <{{ktp}}*>np.PyArray_DATA(ab_), &ldab_, ipiv_shape_, <fwi_integer_t*>np.PyArray_DATA(ipiv_), b_shape_, <{{ktp}}*>np.PyArray_DATA(b_), &ldb_, &info, &fw_iserr__, fw_errstr__)
    try:
        if fw_iserr__ != FW_NO_ERR__:
            raise RuntimeError("an error was encountered when calling the '{{name}}' wrapper.")
    finally:
        #TODO: for(i=0;i<n;--ipiv[i++])
    return (b, info,)
{{endfor}}


{{for fc_name, ktp, ktp2, name, npy_enum, npy_enum2
      in zip(['sgebal_c', 'dgebal_c', 'cgebal_c', 'zgebal_c'],
             ['fwr_real_t', 'fwr_dbl_t', 'fwc_complex_t', 'fwc_dbl_complex_t'],
             ['fwr_real_t', 'fwr_dbl_t', 'fwr_real_t', 'fwr_dbl_t'],
             ['sgebal', 'dgebal', 'cgebal', 'zgebal'],
             ['fwr_real_t_enum', 'fwr_dbl_t_enum', 'fwc_complex_t_enum', 'fwc_dbl_complex_t_enum'],
             ['fwr_real_t_enum', 'fwr_dbl_t_enum', 'fwr_real_t_enum', 'fwr_dbl_t_enum'])}}
cpdef api object {{name}}(object a, fwi_integer_t scale=0, fwi_integer_t permute=0, object pivscale=None, bint overwrite_a=False):
    """{{name}}(a[, scale, permute, pivscale, overwrite_a]) -> (a, lo, hi, pivscale, info)

    Parameters
    ----------
    a : {{ktp}}_, 2D array, dimension(m, n), intent inout
    scale : fwi_integer, intent in
    permute : fwi_integer, intent in
    pivscale : {{ktp2}}_, 1D array, dimension(n), intent out
    overwrite_a : bint_, intent in

    Returns
    -------
    a : {{ktp}}_, 2D array, dimension(m, n), intent inout
    lo : fwi_integer, intent out
    hi : fwi_integer, intent out
    pivscale : {{ktp2}}_, 1D array, dimension(n), intent out
    info : fwi_integer, intent out

    """
    cdef np.ndarray a_
    cdef fw_shape_t a_shape_[2]
    cdef np.ndarray pivscale_
    cdef fw_shape_t pivscale_shape_[1]
    cdef fwi_integer_t n
    cdef fwi_integer_t m
    cdef fwi_integer_t fw_iserr__
    cdef char *fw_job_f = [0, 0]
    cdef fwi_integer_t lo
    cdef fwi_integer_t hi
    cdef fwi_integer_t info
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    job_f = ("B" if scale else "P") if permute else ("S" if scale else "N")
    a_, a = fw_asfortranarray(a, {{npy_enum}}, 2, not overwrite_a)
    fw_copyshape(a_shape_, np.PyArray_DIMS(a_), 2)
    n = np.PyArray_DIMS(a_)[1]
    m = np.PyArray_DIMS(a_)[0]
    if not (m >= n):
        raise ValueError('Condition on arguments not satisfied: m >= n')
    if m != a_shape_[0]:
        raise ValueError("(m == a.shape[0]) not satisifed")
    if not (0 <= n <= a_shape_[1]):
        raise ValueError("(0 <= n <= a.shape[1]) not satisifed")
    pivscale_, pivscale = fw_explicitshapearray(pivscale, {{npy_enum2}}, 1, [n], False)
    fw_copyshape(pivscale_shape_, np.PyArray_DIMS(pivscale_), 1)
    if n != pivscale_shape_[0]:
        raise ValueError("(n == pivscale.shape[0]) not satisifed")
    fw_job_f[0] = fw_aschar(job_f)
    if fw_job_f[0] == 0:
        raise ValueError("len(job_f) != 1")
    {{fc_name}}(fw_job_f, &n, a_shape_, <{{ktp}}*>np.PyArray_DATA(a_), &m, &lo, &hi, pivscale_shape_, <{{ktp2}}*>np.PyArray_DATA(pivscale_), &info, &fw_iserr__, fw_errstr__)
    try:
        if fw_iserr__ != FW_NO_ERR__:
            raise RuntimeError("an error was encountered when calling the '{{name}}' wrapper.")
    finally:
        #TODO: hi--; lo--
    return (a, lo, hi, pivscale, info,)
{{endfor}}


cpdef api object sgees(object jobvs, object sort, bint select, fwi_integer_t n, object a, fwi_integer_t lda, fwi_integer_t sdim, object wr, object wi, object vs, fwi_integer_t ldvs, object work, fwi_integer_t lwork, object bwork, fwi_integer_t info):
    """sgees(jobvs, sort, select, n, a, lda, sdim, wr, wi, vs, ldvs, work, lwork, bwork, info[, jobvs, sort, select, n, a, lda, sdim, wr, wi, vs, ldvs, work, lwork, bwork, info]) -> (jobvs, sort, select_, n, a, lda, sdim, wr, wi, vs, ldvs, work, lwork, bwork, info)

    Parameters
    ----------
    jobvs : object_, intent inout
    sort : object_, intent inout
    select : fwl_logical, intent inout
    n : fwi_integer, intent inout
    a : fwr_real, 2D array, dimension(lda, *), intent inout
    lda : fwi_integer, intent inout
    sdim : fwi_integer, intent inout
    wr : fwr_real, 1D array, dimension(*), intent inout
    wi : fwr_real, 1D array, dimension(*), intent inout
    vs : fwr_real, 2D array, dimension(ldvs, *), intent inout
    ldvs : fwi_integer, intent inout
    work : fwr_real, 1D array, dimension(*), intent inout
    lwork : fwi_integer, intent inout
    bwork : fwl_logical, 1D array, dimension(*), intent inout
    info : fwi_integer, intent inout

    Returns
    -------
    jobvs : object_, intent inout
    sort : object_, intent inout
    select : fwl_logical, intent inout
    n : fwi_integer, intent inout
    a : fwr_real, 2D array, dimension(lda, *), intent inout
    lda : fwi_integer, intent inout
    sdim : fwi_integer, intent inout
    wr : fwr_real, 1D array, dimension(*), intent inout
    wi : fwr_real, 1D array, dimension(*), intent inout
    vs : fwr_real, 2D array, dimension(ldvs, *), intent inout
    ldvs : fwi_integer, intent inout
    work : fwr_real, 1D array, dimension(*), intent inout
    lwork : fwi_integer, intent inout
    bwork : fwl_logical, 1D array, dimension(*), intent inout
    info : fwi_integer, intent inout

    """
    cdef char *fw_jobvs = [0, 0]
    cdef char *fw_sort = [0, 0]
    cdef fwl_logical_t select_
    cdef np.ndarray a_
    cdef fw_shape_t a_shape_[2]
    cdef np.ndarray wr_
    cdef fw_shape_t wr_shape_[1]
    cdef np.ndarray wi_
    cdef fw_shape_t wi_shape_[1]
    cdef np.ndarray vs_
    cdef fw_shape_t vs_shape_[2]
    cdef np.ndarray work_
    cdef fw_shape_t work_shape_[1]
    cdef np.ndarray bwork_
    cdef fw_shape_t bwork_shape_[1]
    cdef fwi_integer_t fw_iserr__
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    select_ = 1 if select else 0
    a_, a = fw_asfortranarray(a, fwr_real_t_enum, 2, False)
    fw_copyshape(a_shape_, np.PyArray_DIMS(a_), 2)
    if lda != a_shape_[0]:
        raise ValueError("(lda == a.shape[0]) not satisifed")
    wr_, wr = fw_asfortranarray(wr, fwr_real_t_enum, 1, False)
    fw_copyshape(wr_shape_, np.PyArray_DIMS(wr_), 1)
    wi_, wi = fw_asfortranarray(wi, fwr_real_t_enum, 1, False)
    fw_copyshape(wi_shape_, np.PyArray_DIMS(wi_), 1)
    vs_, vs = fw_asfortranarray(vs, fwr_real_t_enum, 2, False)
    fw_copyshape(vs_shape_, np.PyArray_DIMS(vs_), 2)
    if ldvs != vs_shape_[0]:
        raise ValueError("(ldvs == vs.shape[0]) not satisifed")
    work_, work = fw_asfortranarray(work, fwr_real_t_enum, 1, False)
    fw_copyshape(work_shape_, np.PyArray_DIMS(work_), 1)
    bwork_, bwork = fw_asfortranarray(bwork, fwl_logical_t_enum, 1, False)
    fw_copyshape(bwork_shape_, np.PyArray_DIMS(bwork_), 1)
    fw_jobvs[0] = fw_aschar(jobvs)
    if fw_jobvs[0] == 0:
        raise ValueError("len(jobvs) != 1")
    fw_sort[0] = fw_aschar(sort)
    if fw_sort[0] == 0:
        raise ValueError("len(sort) != 1")
    sgees_c(fw_jobvs, fw_sort, &select_, &n, a_shape_, <fwr_real_t*>np.PyArray_DATA(a_), &lda, &sdim, wr_shape_, <fwr_real_t*>np.PyArray_DATA(wr_), wi_shape_, <fwr_real_t*>np.PyArray_DATA(wi_), vs_shape_, <fwr_real_t*>np.PyArray_DATA(vs_), &ldvs, work_shape_, <fwr_real_t*>np.PyArray_DATA(work_), &lwork, bwork_shape_, <fwl_logical_t*>np.PyArray_DATA(bwork_), &info, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the 'sgees' wrapper.")
    return (fw_jobvs, fw_sort, select_, n, a, lda, sdim, wr, wi, vs, ldvs, work, lwork, bwork, info,)


cpdef api object sgeev(object a, fwi_integer_t compute_vl=1, fwi_integer_t compute_vr=1, object wr=None, object wi=None, object vl=None, object vr=None, object lwork=None, bint overwrite_a=False):
    """sgeev(a[, compute_vl, compute_vr, wr, wi, vl, vr, lwork, overwrite_a]) -> (wr, wi, vl, vr, info)

    Parameters
    ----------
    a : fwr_real, 2D array, dimension(n, n), intent in
    compute_vl : fwi_integer, intent in
    compute_vr : fwi_integer, intent in
    wr : fwr_real, 1D array, dimension(n), intent out
    wi : fwr_real, 1D array, dimension(n), intent out
    vl : fwr_real, 2D array, dimension(ldvl, n), intent out
    vr : fwr_real, 2D array, dimension(ldvr, n), intent out
    lwork : fwi_integer, intent in
    overwrite_a : bint_, intent in

    Returns
    -------
    wr : fwr_real, 1D array, dimension(n), intent out
    wi : fwr_real, 1D array, dimension(n), intent out
    vl : fwr_real, 2D array, dimension(ldvl, n), intent out
    vr : fwr_real, 2D array, dimension(ldvr, n), intent out
    info : fwi_integer, intent out

    """
    cdef np.ndarray a_
    cdef fw_shape_t a_shape_[2]
    cdef np.ndarray wr_
    cdef fw_shape_t wr_shape_[1]
    cdef np.ndarray wi_
    cdef fw_shape_t wi_shape_[1]
    cdef np.ndarray vl_
    cdef fw_shape_t vl_shape_[2]
    cdef np.ndarray vr_
    cdef fw_shape_t vr_shape_[2]
    cdef fwi_integer_t lwork_
    cdef fwi_integer_t n
    cdef fwi_integer_t ldvl
    cdef fwi_integer_t ldvr
    cdef np.ndarray work_
    cdef fw_shape_t work_shape_[1]
    cdef fwi_integer_t fw_iserr__
    cdef char *fw_jobvl_f = [0, 0]
    cdef char *fw_jobvr_f = [0, 0]
    cdef fwi_integer_t info
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    jobvl_f = "V" if compute_vl else "N"
    jobvr_f = "V" if compute_vr else "N"
    a_, a = fw_asfortranarray(a, fwr_real_t_enum, 2, not overwrite_a)
    fw_copyshape(a_shape_, np.PyArray_DIMS(a_), 2)
    n = np.PyArray_DIMS(a_)[0]
    lwork_ = lwork if (lwork is not None) else 4 * n
    if not (np.PyArray_DIMS(a_)[0] == np.PyArray_DIMS(a_)[1]):
        raise ValueError('Condition on arguments not satisfied: a.shape[0] == a.shape[1]')
    if not ((compute_vl == 1) or (compute_vl == 0)):
        raise ValueError('Condition on arguments not satisfied: (compute_vl == 1) or (compute_vl == 0)')
    if not ((compute_vr == 1) or (compute_vr == 0)):
        raise ValueError('Condition on arguments not satisfied: (compute_vr == 1) or (compute_vr == 0)')
    if not (lwork_ >= ((4 * n) if (compute_vl or compute_vr) else (3 * n))):
        raise ValueError('Condition on arguments not satisfied: lwork >= ((4 * n) if (compute_vl or compute_vr) else (3 * n))')
    if n != a_shape_[0]:
        raise ValueError("(n == a.shape[0]) not satisifed")
    if not (0 <= n <= a_shape_[1]):
        raise ValueError("(0 <= n <= a.shape[1]) not satisifed")
    wr_, wr = fw_explicitshapearray(wr, fwr_real_t_enum, 1, [n], False)
    fw_copyshape(wr_shape_, np.PyArray_DIMS(wr_), 1)
    if n != wr_shape_[0]:
        raise ValueError("(n == wr.shape[0]) not satisifed")
    wi_, wi = fw_explicitshapearray(wi, fwr_real_t_enum, 1, [n], False)
    fw_copyshape(wi_shape_, np.PyArray_DIMS(wi_), 1)
    if n != wi_shape_[0]:
        raise ValueError("(n == wi.shape[0]) not satisifed")
    ldvl = n if compute_vl else 1
    vl_, vl = fw_explicitshapearray(vl, fwr_real_t_enum, 2, [ldvl, n], False)
    fw_copyshape(vl_shape_, np.PyArray_DIMS(vl_), 2)
    if ldvl != vl_shape_[0]:
        raise ValueError("(ldvl == vl.shape[0]) not satisifed")
    if not (0 <= n <= vl_shape_[1]):
        raise ValueError("(0 <= n <= vl.shape[1]) not satisifed")
    ldvr = n if compute_vr else 1
    vr_, vr = fw_explicitshapearray(vr, fwr_real_t_enum, 2, [ldvr, n], False)
    fw_copyshape(vr_shape_, np.PyArray_DIMS(vr_), 2)
    if ldvr != vr_shape_[0]:
        raise ValueError("(ldvr == vr.shape[0]) not satisifed")
    if not (0 <= n <= vr_shape_[1]):
        raise ValueError("(0 <= n <= vr.shape[1]) not satisifed")
    work_, work = fw_explicitshapearray(None, fwr_real_t_enum, 1, [lwork_], False)
    fw_copyshape(work_shape_, np.PyArray_DIMS(work_), 1)
    if lwork_ != work_shape_[0]:
        raise ValueError("(lwork == work.shape[0]) not satisifed")
    fw_jobvl_f[0] = fw_aschar(jobvl_f)
    if fw_jobvl_f[0] == 0:
        raise ValueError("len(jobvl_f) != 1")
    fw_jobvr_f[0] = fw_aschar(jobvr_f)
    if fw_jobvr_f[0] == 0:
        raise ValueError("len(jobvr_f) != 1")
    sgeev_c(fw_jobvl_f, fw_jobvr_f, &n, a_shape_, <fwr_real_t*>np.PyArray_DATA(a_), &n, wr_shape_, <fwr_real_t*>np.PyArray_DATA(wr_), wi_shape_, <fwr_real_t*>np.PyArray_DATA(wi_), vl_shape_, <fwr_real_t*>np.PyArray_DATA(vl_), &ldvl, vr_shape_, <fwr_real_t*>np.PyArray_DATA(vr_), &ldvr, work_shape_, <fwr_real_t*>np.PyArray_DATA(work_), &lwork_, &info, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the 'sgeev' wrapper.")
    return (wr, wi, vl, vr, info,)


cpdef api object sgegv(object a, object b, fwi_integer_t compute_vl=1, fwi_integer_t compute_vr=1, object alphar=None, object alphai=None, object beta=None, object vl=None, object vr=None, object lwork=None, bint overwrite_a=False, bint overwrite_b=False):
    """sgegv(a, b[, compute_vl, compute_vr, alphar, alphai, beta, vl, vr, lwork, overwrite_a, overwrite_b]) -> (alphar, alphai, beta, vl, vr, info)

    Parameters
    ----------
    a : fwr_real, 2D array, dimension(n, n), intent in
    b : fwr_real, 2D array, dimension(n, n), intent in
    compute_vl : fwi_integer, intent in
    compute_vr : fwi_integer, intent in
    alphar : fwr_real, 1D array, dimension(n), intent out
    alphai : fwr_real, 1D array, dimension(n), intent out
    beta : fwr_real, 1D array, dimension(n), intent out
    vl : fwr_real, 2D array, dimension(ldvl, n), intent out
    vr : fwr_real, 2D array, dimension(ldvr, n), intent out
    lwork : fwi_integer, intent in
    overwrite_a : bint_, intent in
    overwrite_b : bint_, intent in

    Returns
    -------
    alphar : fwr_real, 1D array, dimension(n), intent out
    alphai : fwr_real, 1D array, dimension(n), intent out
    beta : fwr_real, 1D array, dimension(n), intent out
    vl : fwr_real, 2D array, dimension(ldvl, n), intent out
    vr : fwr_real, 2D array, dimension(ldvr, n), intent out
    info : fwi_integer, intent out

    """
    cdef np.ndarray a_
    cdef fw_shape_t a_shape_[2]
    cdef np.ndarray b_
    cdef fw_shape_t b_shape_[2]
    cdef np.ndarray alphar_
    cdef fw_shape_t alphar_shape_[1]
    cdef np.ndarray alphai_
    cdef fw_shape_t alphai_shape_[1]
    cdef np.ndarray beta_
    cdef fw_shape_t beta_shape_[1]
    cdef np.ndarray vl_
    cdef fw_shape_t vl_shape_[2]
    cdef np.ndarray vr_
    cdef fw_shape_t vr_shape_[2]
    cdef fwi_integer_t lwork_
    cdef fwi_integer_t n
    cdef fwi_integer_t ldvl
    cdef fwi_integer_t ldvr
    cdef np.ndarray work_
    cdef fw_shape_t work_shape_[1]
    cdef fwi_integer_t fw_iserr__
    cdef char *fw_jobvl_f = [0, 0]
    cdef char *fw_jobvr_f = [0, 0]
    cdef fwi_integer_t info
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    jobvl_f = "V" if compute_vl else "N"
    jobvr_f = "V" if compute_vr else "N"
    a_, a = fw_asfortranarray(a, fwr_real_t_enum, 2, not overwrite_a)
    fw_copyshape(a_shape_, np.PyArray_DIMS(a_), 2)
    b_, b = fw_asfortranarray(b, fwr_real_t_enum, 2, not overwrite_b)
    fw_copyshape(b_shape_, np.PyArray_DIMS(b_), 2)
    n = np.PyArray_DIMS(a_)[0]
    lwork_ = lwork if (lwork is not None) else 8 * n
    if not (np.PyArray_DIMS(a_)[0] == np.PyArray_DIMS(a_)[1]):
        raise ValueError('Condition on arguments not satisfied: a.shape[0] == a.shape[1]')
    if not ((np.PyArray_DIMS(b_)[0] == np.PyArray_DIMS(b_)[1]) and (np.PyArray_DIMS(b_)[0] == n)):
        raise ValueError('Condition on arguments not satisfied: (b.shape[0] == b.shape[1]) and (b.shape[0] == n)')
    if not ((compute_vl == 1) or (compute_vl == 0)):
        raise ValueError('Condition on arguments not satisfied: (compute_vl == 1) or (compute_vl == 0)')
    if not ((compute_vr == 1) or (compute_vr == 0)):
        raise ValueError('Condition on arguments not satisfied: (compute_vr == 1) or (compute_vr == 0)')
    if not (lwork_ >= (8 * n)):
        raise ValueError('Condition on arguments not satisfied: lwork >= (8 * n)')
    if n != a_shape_[0]:
        raise ValueError("(n == a.shape[0]) not satisifed")
    if not (0 <= n <= a_shape_[1]):
        raise ValueError("(0 <= n <= a.shape[1]) not satisifed")
    if n != b_shape_[0]:
        raise ValueError("(n == b.shape[0]) not satisifed")
    if n != b_shape_[1]:
        raise ValueError("(n == b.shape[1]) not satisifed")
    alphar_, alphar = fw_explicitshapearray(alphar, fwr_real_t_enum, 1, [n], False)
    fw_copyshape(alphar_shape_, np.PyArray_DIMS(alphar_), 1)
    if n != alphar_shape_[0]:
        raise ValueError("(n == alphar.shape[0]) not satisifed")
    alphai_, alphai = fw_explicitshapearray(alphai, fwr_real_t_enum, 1, [n], False)
    fw_copyshape(alphai_shape_, np.PyArray_DIMS(alphai_), 1)
    if n != alphai_shape_[0]:
        raise ValueError("(n == alphai.shape[0]) not satisifed")
    beta_, beta = fw_explicitshapearray(beta, fwr_real_t_enum, 1, [n], False)
    fw_copyshape(beta_shape_, np.PyArray_DIMS(beta_), 1)
    if n != beta_shape_[0]:
        raise ValueError("(n == beta.shape[0]) not satisifed")
    ldvl = n if compute_vl else 1
    vl_, vl = fw_explicitshapearray(vl, fwr_real_t_enum, 2, [ldvl, n], False)
    fw_copyshape(vl_shape_, np.PyArray_DIMS(vl_), 2)
    if ldvl != vl_shape_[0]:
        raise ValueError("(ldvl == vl.shape[0]) not satisifed")
    if not (0 <= n <= vl_shape_[1]):
        raise ValueError("(0 <= n <= vl.shape[1]) not satisifed")
    ldvr = n if compute_vr else 1
    vr_, vr = fw_explicitshapearray(vr, fwr_real_t_enum, 2, [ldvr, n], False)
    fw_copyshape(vr_shape_, np.PyArray_DIMS(vr_), 2)
    if ldvr != vr_shape_[0]:
        raise ValueError("(ldvr == vr.shape[0]) not satisifed")
    if not (0 <= n <= vr_shape_[1]):
        raise ValueError("(0 <= n <= vr.shape[1]) not satisifed")
    work_, work = fw_explicitshapearray(None, fwr_real_t_enum, 1, [lwork_], False)
    fw_copyshape(work_shape_, np.PyArray_DIMS(work_), 1)
    if lwork_ != work_shape_[0]:
        raise ValueError("(lwork == work.shape[0]) not satisifed")
    fw_jobvl_f[0] = fw_aschar(jobvl_f)
    if fw_jobvl_f[0] == 0:
        raise ValueError("len(jobvl_f) != 1")
    fw_jobvr_f[0] = fw_aschar(jobvr_f)
    if fw_jobvr_f[0] == 0:
        raise ValueError("len(jobvr_f) != 1")
    sgegv_c(fw_jobvl_f, fw_jobvr_f, &n, a_shape_, <fwr_real_t*>np.PyArray_DATA(a_), &n, b_shape_, <fwr_real_t*>np.PyArray_DATA(b_), &n, alphar_shape_, <fwr_real_t*>np.PyArray_DATA(alphar_), alphai_shape_, <fwr_real_t*>np.PyArray_DATA(alphai_), beta_shape_, <fwr_real_t*>np.PyArray_DATA(beta_), vl_shape_, <fwr_real_t*>np.PyArray_DATA(vl_), &ldvl, vr_shape_, <fwr_real_t*>np.PyArray_DATA(vr_), &ldvr, work_shape_, <fwr_real_t*>np.PyArray_DATA(work_), &lwork_, &info, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the 'sgegv' wrapper.")
    return (alphar, alphai, beta, vl, vr, info,)


{{for fc_name, ktp, name, npy_enum
      in zip(['sgehrd_c', 'dgehrd_c', 'cgehrd_c', 'zgehrd_c'],
             ['fwr_real_t', 'fwr_dbl_t', 'fwc_complex_t', 'fwc_dbl_complex_t'],
             ['sgehrd', 'dgehrd', 'cgehrd', 'zgehrd'],
             ['fwr_real_t_enum', 'fwr_dbl_t_enum', 'fwc_complex_t_enum', 'fwc_dbl_complex_t_enum'])}}
cpdef api object {{name}}(object a, fwi_integer_t lo=0, object hi=None, object tau=None, object lwork=None, bint overwrite_a=False):
    """{{name}}(a[, lo, hi, tau, lwork, overwrite_a]) -> (a, tau, info)

    Parameters
    ----------
    a : {{ktp}}_, 2D array, dimension(n, n), intent inout
    lo : fwi_integer, intent in
    hi : fwi_integer, intent in
    tau : {{ktp}}_, 1D array, dimension(n-1), intent out
    lwork : fwi_integer, intent in
    overwrite_a : bint_, intent in

    Returns
    -------
    a : {{ktp}}_, 2D array, dimension(n, n), intent inout
    tau : {{ktp}}_, 1D array, dimension(n-1), intent out
    info : fwi_integer, intent out

    """
    cdef np.ndarray a_
    cdef fw_shape_t a_shape_[2]
    cdef fwi_integer_t hi_
    cdef np.ndarray tau_
    cdef fw_shape_t tau_shape_[1]
    cdef fwi_integer_t lwork_
    cdef fwi_integer_t n
    cdef np.ndarray work_
    cdef fw_shape_t work_shape_[1]
    cdef fwi_integer_t fw_iserr__
    cdef fwi_integer_t info
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    a_, a = fw_asfortranarray(a, {{npy_enum}}, 2, not overwrite_a)
    fw_copyshape(a_shape_, np.PyArray_DIMS(a_), 2)
    n = np.PyArray_DIMS(a_)[0]
    hi_ = hi if (hi is not None) else n - 1
    lwork_ = lwork if (lwork is not None) else max(n, 1)
    if not (np.PyArray_DIMS(a_)[0] == np.PyArray_DIMS(a_)[1]):
        raise ValueError('Condition on arguments not satisfied: a.shape[0] == a.shape[1]')
    if not (lwork_ >= max(n, 1)):
        raise ValueError('Condition on arguments not satisfied: lwork >= max(n, 1)')
    if n != a_shape_[0]:
        raise ValueError("(n == a.shape[0]) not satisifed")
    if not (0 <= n <= a_shape_[1]):
        raise ValueError("(0 <= n <= a.shape[1]) not satisifed")
    tau_, tau = fw_explicitshapearray(tau, {{npy_enum}}, 1, [n - 1], False)
    fw_copyshape(tau_shape_, np.PyArray_DIMS(tau_), 1)
    if n - 1 != tau_shape_[0]:
        raise ValueError("(n - 1 == tau.shape[0]) not satisifed")
    work_, work = fw_explicitshapearray(None, {{npy_enum}}, 1, [lwork_], False)
    fw_copyshape(work_shape_, np.PyArray_DIMS(work_), 1)
    if lwork_ != work_shape_[0]:
        raise ValueError("(lwork == work.shape[0]) not satisifed")
    #TODO: hi++; lo++;
    {{fc_name}}(&n, &lo, &hi_, a_shape_, <{{ktp}}*>np.PyArray_DATA(a_), &n, tau_shape_, <{{ktp}}*>np.PyArray_DATA(tau_), work_shape_, <{{ktp}}*>np.PyArray_DATA(work_), &lwork_, &info, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the '{{name}}' wrapper.")
    return (a, tau, info,)
{{endfor}}


cpdef api object sgelss(object a, object b, object s=None, fwr_real_t cond=-1.0, object lwork=None, bint overwrite_a=False, bint overwrite_b=False):
    """sgelss(a, b[, s, cond, lwork, overwrite_a, overwrite_b]) -> (a, b, s, r, info)

    Parameters
    ----------
    a : fwr_real, 2D array, dimension(m, n), intent inout
    b : fwr_real, 2D array, dimension(maxmn, nrhs), intent inout
    s : fwr_real, 1D array, dimension(minmn), intent out
    cond : fwr_real, intent in
    lwork : fwi_integer, intent in
    overwrite_a : bint_, intent in
    overwrite_b : bint_, intent in

    Returns
    -------
    a : fwr_real, 2D array, dimension(m, n), intent inout
    b : fwr_real, 2D array, dimension(maxmn, nrhs), intent inout
    s : fwr_real, 1D array, dimension(minmn), intent out
    r : fwi_integer, intent out
    info : fwi_integer, intent out

    """
    cdef np.ndarray a_
    cdef fw_shape_t a_shape_[2]
    cdef np.ndarray b_
    cdef fw_shape_t b_shape_[2]
    cdef np.ndarray s_
    cdef fw_shape_t s_shape_[1]
    cdef fwi_integer_t lwork_
    cdef fwi_integer_t m
    cdef fwi_integer_t n
    cdef fwi_integer_t minmn
    cdef fwi_integer_t maxmn
    cdef fwi_integer_t nrhs
    cdef np.ndarray work_
    cdef fw_shape_t work_shape_[1]
    cdef fwi_integer_t fw_iserr__
    cdef fwi_integer_t r
    cdef fwi_integer_t info
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    b_, b = fw_asfortranarray(b, fwr_real_t_enum, 2, not overwrite_b)
    fw_copyshape(b_shape_, np.PyArray_DIMS(b_), 2)
    nrhs = np.PyArray_DIMS(b_)[1]
    a_, a = fw_asfortranarray(a, fwr_real_t_enum, 2, not overwrite_a)
    fw_copyshape(a_shape_, np.PyArray_DIMS(a_), 2)
    m = np.PyArray_DIMS(a_)[0]
    n = np.PyArray_DIMS(a_)[1]
    maxmn = max(m, n)
    minmn = min(m, n)
    lwork_ = lwork if (lwork is not None) else (3 * minmn) + max((2 * minmn), max(maxmn, nrhs))
    if not (maxmn == np.PyArray_DIMS(b_)[0]):
        raise ValueError('Condition on arguments not satisfied: maxmn == b.shape[0]')
    if not (lwork_ >= 1):
        raise ValueError('Condition on arguments not satisfied: lwork >= 1')
    if m != a_shape_[0]:
        raise ValueError("(m == a.shape[0]) not satisifed")
    if not (0 <= n <= a_shape_[1]):
        raise ValueError("(0 <= n <= a.shape[1]) not satisifed")
    if maxmn != b_shape_[0]:
        raise ValueError("(maxmn == b.shape[0]) not satisifed")
    if not (0 <= nrhs <= b_shape_[1]):
        raise ValueError("(0 <= nrhs <= b.shape[1]) not satisifed")
    s_, s = fw_explicitshapearray(s, fwr_real_t_enum, 1, [minmn], False)
    fw_copyshape(s_shape_, np.PyArray_DIMS(s_), 1)
    if minmn != s_shape_[0]:
        raise ValueError("(minmn == s.shape[0]) not satisifed")
    work_, work = fw_explicitshapearray(None, fwr_real_t_enum, 1, [lwork_], False)
    fw_copyshape(work_shape_, np.PyArray_DIMS(work_), 1)
    if lwork_ != work_shape_[0]:
        raise ValueError("(lwork == work.shape[0]) not satisifed")
    sgelss_c(&m, &n, &nrhs, a_shape_, <fwr_real_t*>np.PyArray_DATA(a_), &m, b_shape_, <fwr_real_t*>np.PyArray_DATA(b_), &maxmn, s_shape_, <fwr_real_t*>np.PyArray_DATA(s_), &cond, &r, work_shape_, <fwr_real_t*>np.PyArray_DATA(work_), &lwork_, &info, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the 'sgelss' wrapper.")
    return (a, b, s, r, info,)


{{for fc_name, ktp, name, npy_enum
      in zip(['sgeqrf_c', 'dgeqrf_c', 'cgeqrf_c', 'zgeqrf_c'],
             ['fwr_real_t', 'fwr_dbl_t', 'fwc_complex_t', 'fwc_dbl_complex_t'],
             ['sgeqrf', 'dgeqrf', 'cgeqrf', 'zgeqrf'],
             ['fwr_real_t_enum', 'fwr_dbl_t_enum', 'fwc_complex_t_enum', 'fwc_dbl_complex_t_enum'])}}
cpdef api object {{name}}(object a, object tau=None, object work=None, object lwork=None, bint overwrite_a=False):
    """{{name}}(a[, tau, work, lwork, overwrite_a]) -> (a, tau, work, info)

    Parameters
    ----------
    a : {{ktp}}_, 2D array, dimension(m, n), intent inout
    tau : {{ktp}}_, 1D array, dimension(min(m,n)), intent out
    work : {{ktp}}_, 1D array, dimension(max(lwork,1)), intent out
    lwork : fwi_integer, intent in
    overwrite_a : bint_, intent in

    Returns
    -------
    a : {{ktp}}_, 2D array, dimension(m, n), intent inout
    tau : {{ktp}}_, 1D array, dimension(min(m,n)), intent out
    work : {{ktp}}_, 1D array, dimension(max(lwork,1)), intent out
    info : fwi_integer, intent out

    """
    cdef np.ndarray a_
    cdef fw_shape_t a_shape_[2]
    cdef np.ndarray tau_
    cdef fw_shape_t tau_shape_[1]
    cdef np.ndarray work_
    cdef fw_shape_t work_shape_[1]
    cdef fwi_integer_t lwork_
    cdef fwi_integer_t m
    cdef fwi_integer_t n
    cdef fwi_integer_t fw_iserr__
    cdef fwi_integer_t info
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    a_, a = fw_asfortranarray(a, {{npy_enum}}, 2, not overwrite_a)
    fw_copyshape(a_shape_, np.PyArray_DIMS(a_), 2)
    n = np.PyArray_DIMS(a_)[1]
    lwork_ = lwork if (lwork is not None) else 3 * n
    if not ((lwork_ >= n) or (lwork_ == -1)):
        raise ValueError('Condition on arguments not satisfied: (lwork >= n) or (lwork == -1)')
    m = np.PyArray_DIMS(a_)[0]
    if m != a_shape_[0]:
        raise ValueError("(m == a.shape[0]) not satisifed")
    if not (0 <= n <= a_shape_[1]):
        raise ValueError("(0 <= n <= a.shape[1]) not satisifed")
    tau_, tau = fw_explicitshapearray(tau, {{npy_enum}}, 1, [min(m, n)], False)
    fw_copyshape(tau_shape_, np.PyArray_DIMS(tau_), 1)
    if not (0 <= min(m, n) <= tau_shape_[0]):
        raise ValueError("(0 <= min(m, n) <= tau.shape[0]) not satisifed")
    work_, work = fw_explicitshapearray(work, {{npy_enum}}, 1, [max(lwork_, 1)], False)
    fw_copyshape(work_shape_, np.PyArray_DIMS(work_), 1)
    if max(lwork_, 1) != work_shape_[0]:
        raise ValueError("(max(lwork, 1) == work.shape[0]) not satisifed")
    {{fc_name}}(&m, &n, a_shape_, <{{ktp}}*>np.PyArray_DATA(a_), &m, tau_shape_, <{{ktp}}*>np.PyArray_DATA(tau_), work_shape_, <{{ktp}}*>np.PyArray_DATA(work_), &lwork_, &info, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the '{{name}}' wrapper.")
    return (a, tau, work, info,)
{{endfor}}


{{for fc_name, ktp, name, npy_enum
      in zip(['sgerqf_c', 'dgerqf_c', 'cgerqf_c', 'zgerqf_c'],
             ['fwr_real_t', 'fwr_dbl_t', 'fwc_complex_t', 'fwc_dbl_complex_t'],
             ['sgerqf', 'dgerqf', 'cgerqf', 'zgerqf'],
             ['fwr_real_t_enum', 'fwr_dbl_t_enum', 'fwc_complex_t_enum', 'fwc_dbl_complex_t_enum'])}}
cpdef api object {{name}}(object a, object tau=None, object work=None, object lwork=None, bint overwrite_a=False):
    """{{name}}(a[, tau, work, lwork, overwrite_a]) -> (a, tau, work, info)

    Parameters
    ----------
    a : {{ktp}}_, 2D array, dimension(m, n), intent inout
    tau : {{ktp}}_, 1D array, dimension(min(m,n)), intent out
    work : {{ktp}}_, 1D array, dimension(max(lwork,1)), intent out
    lwork : fwi_integer, intent in
    overwrite_a : bint_, intent in

    Returns
    -------
    a : {{ktp}}_, 2D array, dimension(m, n), intent inout
    tau : {{ktp}}_, 1D array, dimension(min(m,n)), intent out
    work : {{ktp}}_, 1D array, dimension(max(lwork,1)), intent out
    info : fwi_integer, intent out

    """
    cdef np.ndarray a_
    cdef fw_shape_t a_shape_[2]
    cdef np.ndarray tau_
    cdef fw_shape_t tau_shape_[1]
    cdef np.ndarray work_
    cdef fw_shape_t work_shape_[1]
    cdef fwi_integer_t lwork_
    cdef fwi_integer_t m
    cdef fwi_integer_t n
    cdef fwi_integer_t fw_iserr__
    cdef fwi_integer_t info
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    a_, a = fw_asfortranarray(a, {{npy_enum}}, 2, not overwrite_a)
    fw_copyshape(a_shape_, np.PyArray_DIMS(a_), 2)
    n = np.PyArray_DIMS(a_)[1]
    lwork_ = lwork if (lwork is not None) else 3 * n
    if not ((lwork_ >= n) or (lwork_ == -1)):
        raise ValueError('Condition on arguments not satisfied: (lwork >= n) or (lwork == -1)')
    m = np.PyArray_DIMS(a_)[0]
    if m != a_shape_[0]:
        raise ValueError("(m == a.shape[0]) not satisifed")
    if not (0 <= n <= a_shape_[1]):
        raise ValueError("(0 <= n <= a.shape[1]) not satisifed")
    tau_, tau = fw_explicitshapearray(tau, {{npy_enum}}, 1, [min(m, n)], False)
    fw_copyshape(tau_shape_, np.PyArray_DIMS(tau_), 1)
    if not (0 <= min(m, n) <= tau_shape_[0]):
        raise ValueError("(0 <= min(m, n) <= tau.shape[0]) not satisifed")
    work_, work = fw_explicitshapearray(work, {{npy_enum}}, 1, [max(lwork_, 1)], False)
    fw_copyshape(work_shape_, np.PyArray_DIMS(work_), 1)
    if max(lwork_, 1) != work_shape_[0]:
        raise ValueError("(max(lwork, 1) == work.shape[0]) not satisifed")
    {{fc_name}}(&m, &n, a_shape_, <{{ktp}}*>np.PyArray_DATA(a_), &m, tau_shape_, <{{ktp}}*>np.PyArray_DATA(tau_), work_shape_, <{{ktp}}*>np.PyArray_DATA(work_), &lwork_, &info, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the '{{name}}' wrapper.")
    return (a, tau, work, info,)
{{endfor}}


cpdef api object sgesdd(object a, fwi_integer_t compute_uv=1, object u=None, object s=None, object vt=None, object lwork=None, bint overwrite_a=False):
    """sgesdd(a[, compute_uv, u, s, vt, lwork, overwrite_a]) -> (u, s, vt, info)

    Parameters
    ----------
    a : fwr_real, 2D array, dimension(m, n), intent in
    compute_uv : fwi_integer, intent in
    u : fwr_real, 2D array, dimension(du, du), intent out
    s : fwr_real, 1D array, dimension(minmn), intent out
    vt : fwr_real, 2D array, dimension(dvt, dvt), intent out
    lwork : fwi_integer, intent in
    overwrite_a : bint_, intent in

    Returns
    -------
    u : fwr_real, 2D array, dimension(du, du), intent out
    s : fwr_real, 1D array, dimension(minmn), intent out
    vt : fwr_real, 2D array, dimension(dvt, dvt), intent out
    info : fwi_integer, intent out

    """
    cdef np.ndarray a_
    cdef fw_shape_t a_shape_[2]
    cdef np.ndarray u_
    cdef fw_shape_t u_shape_[2]
    cdef np.ndarray s_
    cdef fw_shape_t s_shape_[1]
    cdef np.ndarray vt_
    cdef fw_shape_t vt_shape_[2]
    cdef fwi_integer_t lwork_
    cdef fwi_integer_t m
    cdef fwi_integer_t n
    cdef fwi_integer_t minmn
    cdef fwi_integer_t du
    cdef fwi_integer_t dvt
    cdef np.ndarray work_
    cdef fw_shape_t work_shape_[1]
    cdef np.ndarray iwork_
    cdef fw_shape_t iwork_shape_[1]
    cdef fwi_integer_t fw_iserr__
    cdef char *fw_jobz_f = [0, 0]
    cdef fwi_integer_t info
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    jobz_f = "A" if compute_uv else "N"
    if not ((compute_uv == 0) or (compute_uv == 1)):
        raise ValueError('Condition on arguments not satisfied: (compute_uv == 0) or (compute_uv == 1)')
    a_, a = fw_asfortranarray(a, fwr_real_t_enum, 2, not overwrite_a)
    fw_copyshape(a_shape_, np.PyArray_DIMS(a_), 2)
    m = np.PyArray_DIMS(a_)[0]
    n = np.PyArray_DIMS(a_)[1]
    if m != a_shape_[0]:
        raise ValueError("(m == a.shape[0]) not satisifed")
    if not (0 <= n <= a_shape_[1]):
        raise ValueError("(0 <= n <= a.shape[1]) not satisifed")
    du = m if compute_uv else 1
    u_, u = fw_explicitshapearray(u, fwr_real_t_enum, 2, [du, du], False)
    fw_copyshape(u_shape_, np.PyArray_DIMS(u_), 2)
    if du != u_shape_[0]:
        raise ValueError("(du == u.shape[0]) not satisifed")
    if du != u_shape_[1]:
        raise ValueError("(du == u.shape[1]) not satisifed")
    minmn = min(m, n)
    s_, s = fw_explicitshapearray(s, fwr_real_t_enum, 1, [minmn], False)
    fw_copyshape(s_shape_, np.PyArray_DIMS(s_), 1)
    if minmn != s_shape_[0]:
        raise ValueError("(minmn == s.shape[0]) not satisifed")
    dvt = n if compute_uv else 1
    vt_, vt = fw_explicitshapearray(vt, fwr_real_t_enum, 2, [dvt, dvt], False)
    fw_copyshape(vt_shape_, np.PyArray_DIMS(vt_), 2)
    if dvt != vt_shape_[0]:
        raise ValueError("(dvt == vt.shape[0]) not satisifed")
    if dvt != vt_shape_[1]:
        raise ValueError("(dvt == vt.shape[1]) not satisifed")
    lwork_ = lwork if (lwork is not None) else ((4 * minmn * minmn) + max(m, n) + (9 * minmn)) if compute_uv else (max(((14 * minmn) + 4), ((10 * minmn) + 2 + (25 * (25 + 8)))) + max(m, n))
    work_, work = fw_explicitshapearray(None, fwr_real_t_enum, 1, [lwork_], False)
    fw_copyshape(work_shape_, np.PyArray_DIMS(work_), 1)
    if lwork_ != work_shape_[0]:
        raise ValueError("(lwork == work.shape[0]) not satisifed")
    iwork_, iwork = fw_explicitshapearray(None, fwi_integer_t_enum, 1, [8 * minmn], False)
    fw_copyshape(iwork_shape_, np.PyArray_DIMS(iwork_), 1)
    if 8 * minmn != iwork_shape_[0]:
        raise ValueError("(8 * minmn == iwork.shape[0]) not satisifed")
    fw_jobz_f[0] = fw_aschar(jobz_f)
    if fw_jobz_f[0] == 0:
        raise ValueError("len(jobz_f) != 1")
    sgesdd_c(fw_jobz_f, &m, &n, a_shape_, <fwr_real_t*>np.PyArray_DATA(a_), &m, s_shape_, <fwr_real_t*>np.PyArray_DATA(s_), u_shape_, <fwr_real_t*>np.PyArray_DATA(u_), &du, vt_shape_, <fwr_real_t*>np.PyArray_DATA(vt_), &dvt, work_shape_, <fwr_real_t*>np.PyArray_DATA(work_), &lwork_, iwork_shape_, <fwi_integer_t*>np.PyArray_DATA(iwork_), &info, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the 'sgesdd' wrapper.")
    return (u, s, vt, info,)


{{for fc_name, ktp, name, npy_enum
      in zip(['sgesv_c', 'dgesv_c', 'cgesv_c', 'zgesv_c'],
             ['fwr_real_t', 'fwr_dbl_t', 'fwc_complex_t', 'fwc_dbl_complex_t'],
             ['sgesv', 'dgesv', 'cgesv', 'zgesv'],
             ['fwr_real_t_enum', 'fwr_dbl_t_enum', 'fwc_complex_t_enum', 'fwc_dbl_complex_t_enum'])}}
cpdef api object {{name}}(object a, object b, object piv=None, bint overwrite_a=False, bint overwrite_b=False):
    """{{name}}(a, b[, piv, overwrite_a, overwrite_b]) -> (a, piv, b, info)

    Parameters
    ----------
    a : {{ktp}}_, 2D array, dimension(n, n), intent inout
    b : {{ktp}}_, 2D array, dimension(n, nrhs), intent inout
    piv : fwi_integer, 1D array, dimension(n), intent out
    overwrite_a : bint_, intent in
    overwrite_b : bint_, intent in

    Returns
    -------
    a : {{ktp}}_, 2D array, dimension(n, n), intent inout
    piv : fwi_integer, 1D array, dimension(n), intent out
    b : {{ktp}}_, 2D array, dimension(n, nrhs), intent inout
    info : fwi_integer, intent out

    """
    cdef np.ndarray a_
    cdef fw_shape_t a_shape_[2]
    cdef np.ndarray b_
    cdef fw_shape_t b_shape_[2]
    cdef np.ndarray piv_
    cdef fw_shape_t piv_shape_[1]
    cdef fwi_integer_t n
    cdef fwi_integer_t nrhs
    cdef fwi_integer_t fw_iserr__
    cdef fwi_integer_t info
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    a_, a = fw_asfortranarray(a, {{npy_enum}}, 2, not overwrite_a)
    fw_copyshape(a_shape_, np.PyArray_DIMS(a_), 2)
    b_, b = fw_asfortranarray(b, {{npy_enum}}, 2, not overwrite_b)
    fw_copyshape(b_shape_, np.PyArray_DIMS(b_), 2)
    if not (np.PyArray_DIMS(a_)[0] == np.PyArray_DIMS(a_)[1]):
        raise ValueError('Condition on arguments not satisfied: a.shape[0] == a.shape[1]')
    if not (np.PyArray_DIMS(a_)[0] == np.PyArray_DIMS(b_)[0]):
        raise ValueError('Condition on arguments not satisfied: a.shape[0] == b.shape[0]')
    n = np.PyArray_DIMS(a_)[0]
    if n != a_shape_[0]:
        raise ValueError("(n == a.shape[0]) not satisifed")
    if not (0 <= n <= a_shape_[1]):
        raise ValueError("(0 <= n <= a.shape[1]) not satisifed")
    nrhs = np.PyArray_DIMS(b_)[1]
    if n != b_shape_[0]:
        raise ValueError("(n == b.shape[0]) not satisifed")
    if not (0 <= nrhs <= b_shape_[1]):
        raise ValueError("(0 <= nrhs <= b.shape[1]) not satisifed")
    piv_, piv = fw_explicitshapearray(piv, fwi_integer_t_enum, 1, [n], False)
    fw_copyshape(piv_shape_, np.PyArray_DIMS(piv_), 1)
    if n != piv_shape_[0]:
        raise ValueError("(n == piv.shape[0]) not satisifed")
    #TODO: int i;
    {{fc_name}}(&n, &nrhs, a_shape_, <{{ktp}}*>np.PyArray_DATA(a_), &n, piv_shape_, <fwi_integer_t*>np.PyArray_DATA(piv_), b_shape_, <{{ktp}}*>np.PyArray_DATA(b_), &n, &info, &fw_iserr__, fw_errstr__)
    try:
        if fw_iserr__ != FW_NO_ERR__:
            raise RuntimeError("an error was encountered when calling the '{{name}}' wrapper.")
    finally:
        #TODO: for(i=0;i<n;--piv[i++])
    return (a, piv, b, info,)
{{endfor}}


{{for fc_name, ktp, name, npy_enum
      in zip(['sgetrf_c', 'dgetrf_c', 'cgetrf_c', 'zgetrf_c'],
             ['fwr_real_t', 'fwr_dbl_t', 'fwc_complex_t', 'fwc_dbl_complex_t'],
             ['sgetrf', 'dgetrf', 'cgetrf', 'zgetrf'],
             ['fwr_real_t_enum', 'fwr_dbl_t_enum', 'fwc_complex_t_enum', 'fwc_dbl_complex_t_enum'])}}
cpdef api object {{name}}(object a, object piv=None, bint overwrite_a=False):
    """{{name}}(a[, piv, overwrite_a]) -> (a, piv, info)

    Parameters
    ----------
    a : {{ktp}}_, 2D array, dimension(m, n), intent inout
    piv : fwi_integer, 1D array, dimension(min(m,n)), intent out
    overwrite_a : bint_, intent in

    Returns
    -------
    a : {{ktp}}_, 2D array, dimension(m, n), intent inout
    piv : fwi_integer, 1D array, dimension(min(m,n)), intent out
    info : fwi_integer, intent out

    """
    cdef np.ndarray a_
    cdef fw_shape_t a_shape_[2]
    cdef np.ndarray piv_
    cdef fw_shape_t piv_shape_[1]
    cdef fwi_integer_t m
    cdef fwi_integer_t n
    cdef fwi_integer_t fw_iserr__
    cdef fwi_integer_t info
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    a_, a = fw_asfortranarray(a, {{npy_enum}}, 2, not overwrite_a)
    fw_copyshape(a_shape_, np.PyArray_DIMS(a_), 2)
    m = np.PyArray_DIMS(a_)[0]
    n = np.PyArray_DIMS(a_)[1]
    if m != a_shape_[0]:
        raise ValueError("(m == a.shape[0]) not satisifed")
    if not (0 <= n <= a_shape_[1]):
        raise ValueError("(0 <= n <= a.shape[1]) not satisifed")
    piv_, piv = fw_explicitshapearray(piv, fwi_integer_t_enum, 1, [min(m, n)], False)
    fw_copyshape(piv_shape_, np.PyArray_DIMS(piv_), 1)
    if min(m, n) != piv_shape_[0]:
        raise ValueError("(min(m, n) == piv.shape[0]) not satisifed")
    #TODO: int i;
    {{fc_name}}(&m, &n, a_shape_, <{{ktp}}*>np.PyArray_DATA(a_), &m, piv_shape_, <fwi_integer_t*>np.PyArray_DATA(piv_), &info, &fw_iserr__, fw_errstr__)
    try:
        if fw_iserr__ != FW_NO_ERR__:
            raise RuntimeError("an error was encountered when calling the '{{name}}' wrapper.")
    finally:
        #TODO: for(i=0,n=MIN(m,n);i<n;--piv[i++])
    return (a, piv, info,)
{{endfor}}


{{for fc_name, ktp, name, npy_enum
      in zip(['sgetri_c', 'dgetri_c', 'cgetri_c', 'zgetri_c'],
             ['fwr_real_t', 'fwr_dbl_t', 'fwc_complex_t', 'fwc_dbl_complex_t'],
             ['sgetri', 'dgetri', 'cgetri', 'zgetri'],
             ['fwr_real_t_enum', 'fwr_dbl_t_enum', 'fwc_complex_t_enum', 'fwc_dbl_complex_t_enum'])}}
cpdef api object {{name}}(object lu, object piv, object lwork=None, bint overwrite_lu=False):
    """{{name}}(lu, piv[, lwork, overwrite_lu]) -> (lu, info)

    Parameters
    ----------
    lu : {{ktp}}_, 2D array, dimension(n, n), intent inout
    piv : fwi_integer, 1D array, dimension(n), intent in
    lwork : fwi_integer, intent in
    overwrite_lu : bint_, intent in

    Returns
    -------
    lu : {{ktp}}_, 2D array, dimension(n, n), intent inout
    info : fwi_integer, intent out

    """
    cdef np.ndarray lu_
    cdef fw_shape_t lu_shape_[2]
    cdef np.ndarray piv_
    cdef fw_shape_t piv_shape_[1]
    cdef fwi_integer_t lwork_
    cdef fwi_integer_t n
    cdef np.ndarray work_
    cdef fw_shape_t work_shape_[1]
    cdef fwi_integer_t fw_iserr__
    cdef fwi_integer_t info
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    lu_, lu = fw_asfortranarray(lu, {{npy_enum}}, 2, not overwrite_lu)
    fw_copyshape(lu_shape_, np.PyArray_DIMS(lu_), 2)
    n = np.PyArray_DIMS(lu_)[0]
    lwork_ = lwork if (lwork is not None) else 3 * n
    if not (np.PyArray_DIMS(lu_)[0] == np.PyArray_DIMS(lu_)[1]):
        raise ValueError('Condition on arguments not satisfied: lu.shape[0] == lu.shape[1]')
    if not (lwork_ >= n):
        raise ValueError('Condition on arguments not satisfied: lwork >= n')
    if n != lu_shape_[0]:
        raise ValueError("(n == lu.shape[0]) not satisifed")
    if not (0 <= n <= lu_shape_[1]):
        raise ValueError("(0 <= n <= lu.shape[1]) not satisifed")
    piv_, piv = fw_asfortranarray(piv, fwi_integer_t_enum, 1, False)
    fw_copyshape(piv_shape_, np.PyArray_DIMS(piv_), 1)
    if n != piv_shape_[0]:
        raise ValueError("(n == piv.shape[0]) not satisifed")
    work_, work = fw_explicitshapearray(None, {{npy_enum}}, 1, [lwork_], False)
    fw_copyshape(work_shape_, np.PyArray_DIMS(work_), 1)
    if lwork_ != work_shape_[0]:
        raise ValueError("(lwork == work.shape[0]) not satisifed")
    #TODO: int i;for(i=0;i<n;++piv[i++]);
    {{fc_name}}(&n, lu_shape_, <{{ktp}}*>np.PyArray_DATA(lu_), &n, piv_shape_, <fwi_integer_t*>np.PyArray_DATA(piv_), work_shape_, <{{ktp}}*>np.PyArray_DATA(work_), &lwork_, &info, &fw_iserr__, fw_errstr__)
    try:
        if fw_iserr__ != FW_NO_ERR__:
            raise RuntimeError("an error was encountered when calling the '{{name}}' wrapper.")
    finally:
        #TODO: for(i=0;i<n;--piv[i++])
    return (lu, info,)
{{endfor}}


{{for fc_name, ktp, name, npy_enum
      in zip(['sgetrs_c', 'dgetrs_c', 'cgetrs_c', 'zgetrs_c'],
             ['fwr_real_t', 'fwr_dbl_t', 'fwc_complex_t', 'fwc_dbl_complex_t'],
             ['sgetrs', 'dgetrs', 'cgetrs', 'zgetrs'],
             ['fwr_real_t_enum', 'fwr_dbl_t_enum', 'fwc_complex_t_enum', 'fwc_dbl_complex_t_enum'])}}
cpdef api object {{name}}(object lu, object piv, object b, fwi_integer_t trans=0, bint overwrite_b=False):
    """{{name}}(lu, piv, b[, trans, overwrite_b]) -> (b, info)

    Parameters
    ----------
    lu : {{ktp}}_, 2D array, dimension(n, n), intent in
    piv : fwi_integer, 1D array, dimension(n), intent in
    b : {{ktp}}_, 2D array, dimension(n, nrhs), intent inout
    trans : fwi_integer, intent in
    overwrite_b : bint_, intent in

    Returns
    -------
    b : {{ktp}}_, 2D array, dimension(n, nrhs), intent inout
    info : fwi_integer, intent out

    """
    cdef np.ndarray lu_
    cdef fw_shape_t lu_shape_[2]
    cdef np.ndarray piv_
    cdef fw_shape_t piv_shape_[1]
    cdef np.ndarray b_
    cdef fw_shape_t b_shape_[2]
    cdef fwi_integer_t n
    cdef fwi_integer_t nrhs
    cdef fwi_integer_t fw_iserr__
    cdef char *fw_trans_f = [0, 0]
    cdef fwi_integer_t info
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    trans_f = ("C" if (trans == 2) else "T") if trans else "N"
    lu_, lu = fw_asfortranarray(lu, {{npy_enum}}, 2, False)
    fw_copyshape(lu_shape_, np.PyArray_DIMS(lu_), 2)
    b_, b = fw_asfortranarray(b, {{npy_enum}}, 2, not overwrite_b)
    fw_copyshape(b_shape_, np.PyArray_DIMS(b_), 2)
    if not (np.PyArray_DIMS(lu_)[0] == np.PyArray_DIMS(lu_)[1]):
        raise ValueError('Condition on arguments not satisfied: lu.shape[0] == lu.shape[1]')
    if not (np.PyArray_DIMS(lu_)[0] == np.PyArray_DIMS(b_)[0]):
        raise ValueError('Condition on arguments not satisfied: lu.shape[0] == b.shape[0]')
    if not ((trans >= 0) and (trans <= 2)):
        raise ValueError('Condition on arguments not satisfied: (trans >= 0) and (trans <= 2)')
    n = np.PyArray_DIMS(lu_)[0]
    if n != lu_shape_[0]:
        raise ValueError("(n == lu.shape[0]) not satisifed")
    if not (0 <= n <= lu_shape_[1]):
        raise ValueError("(0 <= n <= lu.shape[1]) not satisifed")
    piv_, piv = fw_asfortranarray(piv, fwi_integer_t_enum, 1, False)
    fw_copyshape(piv_shape_, np.PyArray_DIMS(piv_), 1)
    if n != piv_shape_[0]:
        raise ValueError("(n == piv.shape[0]) not satisifed")
    nrhs = np.PyArray_DIMS(b_)[1]
    if n != b_shape_[0]:
        raise ValueError("(n == b.shape[0]) not satisifed")
    if not (0 <= nrhs <= b_shape_[1]):
        raise ValueError("(0 <= nrhs <= b.shape[1]) not satisifed")
    fw_trans_f[0] = fw_aschar(trans_f)
    if fw_trans_f[0] == 0:
        raise ValueError("len(trans_f) != 1")
    #TODO: int i;for(i=0;i<n;++piv[i++]);
    {{fc_name}}(fw_trans_f, &n, &nrhs, lu_shape_, <{{ktp}}*>np.PyArray_DATA(lu_), &n, piv_shape_, <fwi_integer_t*>np.PyArray_DATA(piv_), b_shape_, <{{ktp}}*>np.PyArray_DATA(b_), &n, &info, &fw_iserr__, fw_errstr__)
    try:
        if fw_iserr__ != FW_NO_ERR__:
            raise RuntimeError("an error was encountered when calling the '{{name}}' wrapper.")
    finally:
        #TODO: for(i=0;i<n;--piv[i++])
    return (b, info,)
{{endfor}}


cpdef api object sggev(object a, object b, fwi_integer_t compute_vl=1, fwi_integer_t compute_vr=1, object alphar=None, object alphai=None, object beta=None, object vl=None, object vr=None, object work=None, object lwork=None, bint overwrite_a=False, bint overwrite_b=False):
    """sggev(a, b[, compute_vl, compute_vr, alphar, alphai, beta, vl, vr, work, lwork, overwrite_a, overwrite_b]) -> (alphar, alphai, beta, vl, vr, work, info)

    Parameters
    ----------
    a : fwr_real, 2D array, dimension(n, n), intent in
    b : fwr_real, 2D array, dimension(n, n), intent in
    compute_vl : fwi_integer, intent in
    compute_vr : fwi_integer, intent in
    alphar : fwr_real, 1D array, dimension(n), intent out
    alphai : fwr_real, 1D array, dimension(n), intent out
    beta : fwr_real, 1D array, dimension(n), intent out
    vl : fwr_real, 2D array, dimension(ldvl, n), intent out
    vr : fwr_real, 2D array, dimension(ldvr, n), intent out
    work : fwr_real, 1D array, dimension(max(lwork,1)), intent out
    lwork : fwi_integer, intent in
    overwrite_a : bint_, intent in
    overwrite_b : bint_, intent in

    Returns
    -------
    alphar : fwr_real, 1D array, dimension(n), intent out
    alphai : fwr_real, 1D array, dimension(n), intent out
    beta : fwr_real, 1D array, dimension(n), intent out
    vl : fwr_real, 2D array, dimension(ldvl, n), intent out
    vr : fwr_real, 2D array, dimension(ldvr, n), intent out
    work : fwr_real, 1D array, dimension(max(lwork,1)), intent out
    info : fwi_integer, intent out

    """
    cdef np.ndarray a_
    cdef fw_shape_t a_shape_[2]
    cdef np.ndarray b_
    cdef fw_shape_t b_shape_[2]
    cdef np.ndarray alphar_
    cdef fw_shape_t alphar_shape_[1]
    cdef np.ndarray alphai_
    cdef fw_shape_t alphai_shape_[1]
    cdef np.ndarray beta_
    cdef fw_shape_t beta_shape_[1]
    cdef np.ndarray vl_
    cdef fw_shape_t vl_shape_[2]
    cdef np.ndarray vr_
    cdef fw_shape_t vr_shape_[2]
    cdef np.ndarray work_
    cdef fw_shape_t work_shape_[1]
    cdef fwi_integer_t lwork_
    cdef fwi_integer_t n
    cdef fwi_integer_t ldvl
    cdef fwi_integer_t ldvr
    cdef fwi_integer_t fw_iserr__
    cdef char *fw_jobvl_f = [0, 0]
    cdef char *fw_jobvr_f = [0, 0]
    cdef fwi_integer_t info
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    jobvl_f = "V" if compute_vl else "N"
    jobvr_f = "V" if compute_vr else "N"
    a_, a = fw_asfortranarray(a, fwr_real_t_enum, 2, not overwrite_a)
    fw_copyshape(a_shape_, np.PyArray_DIMS(a_), 2)
    b_, b = fw_asfortranarray(b, fwr_real_t_enum, 2, not overwrite_b)
    fw_copyshape(b_shape_, np.PyArray_DIMS(b_), 2)
    n = np.PyArray_DIMS(a_)[0]
    lwork_ = lwork if (lwork is not None) else 8 * n
    if not (np.PyArray_DIMS(a_)[0] == np.PyArray_DIMS(a_)[1]):
        raise ValueError('Condition on arguments not satisfied: a.shape[0] == a.shape[1]')
    if not (np.PyArray_DIMS(b_)[0] == np.PyArray_DIMS(b_)[1]):
        raise ValueError('Condition on arguments not satisfied: b.shape[0] == b.shape[1]')
    if not ((compute_vl == 1) or (compute_vl == 0)):
        raise ValueError('Condition on arguments not satisfied: (compute_vl == 1) or (compute_vl == 0)')
    if not ((compute_vr == 1) or (compute_vr == 0)):
        raise ValueError('Condition on arguments not satisfied: (compute_vr == 1) or (compute_vr == 0)')
    if not ((lwork_ == -1) or (lwork_ >= max(1, (8 * n)))):
        raise ValueError('Condition on arguments not satisfied: (lwork == -1) or (lwork >= max(1, (8 * n)))')
    if n != a_shape_[0]:
        raise ValueError("(n == a.shape[0]) not satisifed")
    if not (0 <= n <= a_shape_[1]):
        raise ValueError("(0 <= n <= a.shape[1]) not satisifed")
    if n != b_shape_[0]:
        raise ValueError("(n == b.shape[0]) not satisifed")
    if not (0 <= n <= b_shape_[1]):
        raise ValueError("(0 <= n <= b.shape[1]) not satisifed")
    alphar_, alphar = fw_explicitshapearray(alphar, fwr_real_t_enum, 1, [n], False)
    fw_copyshape(alphar_shape_, np.PyArray_DIMS(alphar_), 1)
    if n != alphar_shape_[0]:
        raise ValueError("(n == alphar.shape[0]) not satisifed")
    alphai_, alphai = fw_explicitshapearray(alphai, fwr_real_t_enum, 1, [n], False)
    fw_copyshape(alphai_shape_, np.PyArray_DIMS(alphai_), 1)
    if n != alphai_shape_[0]:
        raise ValueError("(n == alphai.shape[0]) not satisifed")
    beta_, beta = fw_explicitshapearray(beta, fwr_real_t_enum, 1, [n], False)
    fw_copyshape(beta_shape_, np.PyArray_DIMS(beta_), 1)
    if n != beta_shape_[0]:
        raise ValueError("(n == beta.shape[0]) not satisifed")
    ldvl = n if compute_vl else 1
    vl_, vl = fw_explicitshapearray(vl, fwr_real_t_enum, 2, [ldvl, n], False)
    fw_copyshape(vl_shape_, np.PyArray_DIMS(vl_), 2)
    if ldvl != vl_shape_[0]:
        raise ValueError("(ldvl == vl.shape[0]) not satisifed")
    if n != vl_shape_[1]:
        raise ValueError("(n == vl.shape[1]) not satisifed")
    ldvr = n if compute_vr else 1
    vr_, vr = fw_explicitshapearray(vr, fwr_real_t_enum, 2, [ldvr, n], False)
    fw_copyshape(vr_shape_, np.PyArray_DIMS(vr_), 2)
    if ldvr != vr_shape_[0]:
        raise ValueError("(ldvr == vr.shape[0]) not satisifed")
    if n != vr_shape_[1]:
        raise ValueError("(n == vr.shape[1]) not satisifed")
    work_, work = fw_explicitshapearray(work, fwr_real_t_enum, 1, [max(lwork_, 1)], False)
    fw_copyshape(work_shape_, np.PyArray_DIMS(work_), 1)
    if max(lwork_, 1) != work_shape_[0]:
        raise ValueError("(max(lwork, 1) == work.shape[0]) not satisifed")
    fw_jobvl_f[0] = fw_aschar(jobvl_f)
    if fw_jobvl_f[0] == 0:
        raise ValueError("len(jobvl_f) != 1")
    fw_jobvr_f[0] = fw_aschar(jobvr_f)
    if fw_jobvr_f[0] == 0:
        raise ValueError("len(jobvr_f) != 1")
    sggev_c(fw_jobvl_f, fw_jobvr_f, &n, a_shape_, <fwr_real_t*>np.PyArray_DATA(a_), &n, b_shape_, <fwr_real_t*>np.PyArray_DATA(b_), &n, alphar_shape_, <fwr_real_t*>np.PyArray_DATA(alphar_), alphai_shape_, <fwr_real_t*>np.PyArray_DATA(alphai_), beta_shape_, <fwr_real_t*>np.PyArray_DATA(beta_), vl_shape_, <fwr_real_t*>np.PyArray_DATA(vl_), &ldvl, vr_shape_, <fwr_real_t*>np.PyArray_DATA(vr_), &ldvr, work_shape_, <fwr_real_t*>np.PyArray_DATA(work_), &lwork_, &info, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the 'sggev' wrapper.")
    return (alphar, alphai, beta, vl, vr, work, info,)


{{for fc_name, ktp, name, npy_enum
      in zip(['slaswp_c', 'dlaswp_c', 'claswp_c', 'zlaswp_c'],
             ['fwr_real_t', 'fwr_dbl_t', 'fwc_complex_t', 'fwc_dbl_complex_t'],
             ['slaswp', 'dlaswp', 'claswp', 'zlaswp'],
             ['fwr_real_t_enum', 'fwr_dbl_t_enum', 'fwc_complex_t_enum', 'fwc_dbl_complex_t_enum'])}}
cpdef api object {{name}}(object a, object piv, fwi_integer_t k1=0, object k2=None, fwi_integer_t off=0, fwi_integer_t inc=1, bint overwrite_a=False):
    """{{name}}(a, piv[, k1, k2, off, inc, overwrite_a]) -> a

    Parameters
    ----------
    a : {{ktp}}_, 2D array, dimension(nrows, n), intent inout
    piv : fwi_integer, 1D array, dimension(*), intent in
    k1 : fwi_integer, intent in
    k2 : fwi_integer, intent in
    off : fwi_integer, intent in
    inc : fwi_integer, intent in
    overwrite_a : bint_, intent in

    Returns
    -------
    a : {{ktp}}_, 2D array, dimension(nrows, n), intent inout

    """
    cdef np.ndarray a_
    cdef fw_shape_t a_shape_[2]
    cdef np.ndarray piv_
    cdef fw_shape_t piv_shape_[1]
    cdef fwi_integer_t k2_
    cdef fwi_integer_t n
    cdef fwi_integer_t nrows
    cdef fwi_integer_t m
    cdef fwi_integer_t fw_iserr__
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    piv_, piv = fw_asfortranarray(piv, fwi_integer_t_enum, 1, False)
    fw_copyshape(piv_shape_, np.PyArray_DIMS(piv_), 1)
    piv_shape_[0] -= off
    k2_ = k2 if (k2 is not None) else np.PyArray_DIMS(piv_)[0] - 1
    a_, a = fw_asfortranarray(a, {{npy_enum}}, 2, not overwrite_a)
    fw_copyshape(a_shape_, np.PyArray_DIMS(a_), 2)
    nrows = np.PyArray_DIMS(a_)[0]
    m = (np.PyArray_DIMS(piv_)[0] - off) // abs(inc)
    if not (np.PyArray_DIMS(piv_)[0] <= nrows):
        raise ValueError('Condition on arguments not satisfied: piv.shape[0] <= nrows')
    if not (0 <= k1):
        raise ValueError('Condition on arguments not satisfied: 0 <= k1')
    if not ((k1 <= k2_) and (k2_ < (np.PyArray_DIMS(piv_)[0] - off))):
        raise ValueError('Condition on arguments not satisfied: (k1 <= k2) and (k2 < (piv.shape[0] - off))')
    if not ((off >= 0) and (off < np.PyArray_DIMS(piv_)[0])):
        raise ValueError('Condition on arguments not satisfied: (off >= 0) and (off < piv.shape[0])')
    if not ((inc > 0) or (inc < 0)):
        raise ValueError('Condition on arguments not satisfied: (inc > 0) or (inc < 0)')
    if not ((np.PyArray_DIMS(piv_)[0] - off) > ((m - 1) * abs(inc))):
        raise ValueError('Condition on arguments not satisfied: (piv.shape[0] - off) > ((m - 1) * abs(inc))')
    n = np.PyArray_DIMS(a_)[1]
    if nrows != a_shape_[0]:
        raise ValueError("(nrows == a.shape[0]) not satisifed")
    if not (0 <= n <= a_shape_[1]):
        raise ValueError("(0 <= n <= a.shape[1]) not satisifed")
    #TODO: int i;m=len(piv);for(i=0;i<m;++piv[i++]);++k1;++k2;
    {{fc_name}}(&n, a_shape_, <{{ktp}}*>np.PyArray_DATA(a_), &nrows, &k1, &k2_, piv_shape_, <fwi_integer_t*>np.PyArray_DATA(piv_) + off, &inc, &fw_iserr__, fw_errstr__)
    try:
        if fw_iserr__ != FW_NO_ERR__:
            raise RuntimeError("an error was encountered when calling the '{{name}}' wrapper.")
    finally:
        #TODO: for(i=0;i<m;--piv[i++])
    return a
{{endfor}}


{{for fc_name, ktp, name, npy_enum
      in zip(['slauum_c', 'dlauum_c', 'clauum_c', 'zlauum_c'],
             ['fwr_real_t', 'fwr_dbl_t', 'fwc_complex_t', 'fwc_dbl_complex_t'],
             ['slauum', 'dlauum', 'clauum', 'zlauum'],
             ['fwr_real_t_enum', 'fwr_dbl_t_enum', 'fwc_complex_t_enum', 'fwc_dbl_complex_t_enum'])}}
cpdef api object {{name}}(object c, fwi_integer_t lower=0, bint overwrite_c=False):
    """{{name}}(c[, lower, overwrite_c]) -> (c, info)

    Parameters
    ----------
    c : {{ktp}}_, 2D array, dimension(n, n), intent inout
    lower : fwi_integer, intent in
    overwrite_c : bint_, intent in

    Returns
    -------
    c : {{ktp}}_, 2D array, dimension(n, n), intent inout
    info : fwi_integer, intent out

    """
    cdef np.ndarray c_
    cdef fw_shape_t c_shape_[2]
    cdef fwi_integer_t n
    cdef fwi_integer_t fw_iserr__
    cdef char *fw_uplo_f = [0, 0]
    cdef fwi_integer_t info
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    uplo_f = "L" if lower else "U"
    c_, c = fw_asfortranarray(c, {{npy_enum}}, 2, not overwrite_c)
    fw_copyshape(c_shape_, np.PyArray_DIMS(c_), 2)
    if not (np.PyArray_DIMS(c_)[0] == np.PyArray_DIMS(c_)[1]):
        raise ValueError('Condition on arguments not satisfied: c.shape[0] == c.shape[1]')
    if not ((lower == 0) or (lower == 1)):
        raise ValueError('Condition on arguments not satisfied: (lower == 0) or (lower == 1)')
    n = np.PyArray_DIMS(c_)[0]
    if n != c_shape_[0]:
        raise ValueError("(n == c.shape[0]) not satisifed")
    if not (0 <= n <= c_shape_[1]):
        raise ValueError("(0 <= n <= c.shape[1]) not satisifed")
    fw_uplo_f[0] = fw_aschar(uplo_f)
    if fw_uplo_f[0] == 0:
        raise ValueError("len(uplo_f) != 1")
    {{fc_name}}(fw_uplo_f, &n, c_shape_, <{{ktp}}*>np.PyArray_DATA(c_), &n, &info, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the '{{name}}' wrapper.")
    return (c, info,)
{{endfor}}


{{for fc_name, ktp, name, npy_enum
      in zip(['sorgqr_c', 'dorgqr_c'],
             ['fwr_real_t', 'fwr_dbl_t'],
             ['sorgqr', 'dorgqr'],
             ['fwr_real_t_enum', 'fwr_dbl_t_enum'])}}
cpdef api object {{name}}(object a, object tau, object work=None, object lwork=None, bint overwrite_a=False):
    """{{name}}(a, tau[, work, lwork, overwrite_a]) -> (a, work, info)

    Parameters
    ----------
    a : {{ktp}}_, 2D array, dimension(m, n), intent inout
    tau : {{ktp}}_, 1D array, dimension(k), intent in
    work : {{ktp}}_, 1D array, dimension(max(lwork,1)), intent out
    lwork : fwi_integer, intent in
    overwrite_a : bint_, intent in

    Returns
    -------
    a : {{ktp}}_, 2D array, dimension(m, n), intent inout
    work : {{ktp}}_, 1D array, dimension(max(lwork,1)), intent out
    info : fwi_integer, intent out

    """
    cdef np.ndarray a_
    cdef fw_shape_t a_shape_[2]
    cdef np.ndarray tau_
    cdef fw_shape_t tau_shape_[1]
    cdef np.ndarray work_
    cdef fw_shape_t work_shape_[1]
    cdef fwi_integer_t lwork_
    cdef fwi_integer_t m
    cdef fwi_integer_t n
    cdef fwi_integer_t k
    cdef fwi_integer_t fw_iserr__
    cdef fwi_integer_t info
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    a_, a = fw_asfortranarray(a, {{npy_enum}}, 2, not overwrite_a)
    fw_copyshape(a_shape_, np.PyArray_DIMS(a_), 2)
    n = np.PyArray_DIMS(a_)[1]
    lwork_ = lwork if (lwork is not None) else 3 * n
    if not ((lwork_ >= n) or (lwork_ == -1)):
        raise ValueError('Condition on arguments not satisfied: (lwork >= n) or (lwork == -1)')
    m = np.PyArray_DIMS(a_)[0]
    if m != a_shape_[0]:
        raise ValueError("(m == a.shape[0]) not satisifed")
    if not (0 <= n <= a_shape_[1]):
        raise ValueError("(0 <= n <= a.shape[1]) not satisifed")
    tau_, tau = fw_asfortranarray(tau, {{npy_enum}}, 1, False)
    fw_copyshape(tau_shape_, np.PyArray_DIMS(tau_), 1)
    k = np.PyArray_DIMS(tau_)[0]
    if not (0 <= k <= tau_shape_[0]):
        raise ValueError("(0 <= k <= tau.shape[0]) not satisifed")
    work_, work = fw_explicitshapearray(work, {{npy_enum}}, 1, [max(lwork_, 1)], False)
    fw_copyshape(work_shape_, np.PyArray_DIMS(work_), 1)
    if max(lwork_, 1) != work_shape_[0]:
        raise ValueError("(max(lwork, 1) == work.shape[0]) not satisifed")
    {{fc_name}}(&m, &n, &k, a_shape_, <{{ktp}}*>np.PyArray_DATA(a_), &m, tau_shape_, <{{ktp}}*>np.PyArray_DATA(tau_), work_shape_, <{{ktp}}*>np.PyArray_DATA(work_), &lwork_, &info, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the '{{name}}' wrapper.")
    return (a, work, info,)
{{endfor}}


{{for fc_name, ktp, name, npy_enum
      in zip(['spbsv_c', 'dpbsv_c', 'cpbsv_c', 'zpbsv_c'],
             ['fwr_real_t', 'fwr_dbl_t', 'fwc_complex_t', 'fwc_dbl_complex_t'],
             ['spbsv', 'dpbsv', 'cpbsv', 'zpbsv'],
             ['fwr_real_t_enum', 'fwr_dbl_t_enum', 'fwc_complex_t_enum', 'fwc_dbl_complex_t_enum'])}}
cpdef api object {{name}}(object ab, object b, fwi_integer_t lower=0, object ldab=None, bint overwrite_ab=False, bint overwrite_b=False):
    """{{name}}(ab, b[, lower, ldab, overwrite_ab, overwrite_b]) -> (ab, b, info)

    Parameters
    ----------
    ab : {{ktp}}_, 2D array, dimension(ldab, n), intent inout
    b : {{ktp}}_, 2D array, dimension(ldb, nrhs), intent inout
    lower : fwi_integer, intent in
    ldab : fwi_integer, intent in
    overwrite_ab : bint_, intent in
    overwrite_b : bint_, intent in

    Returns
    -------
    ab : {{ktp}}_, 2D array, dimension(ldab, n), intent inout
    b : {{ktp}}_, 2D array, dimension(ldb, nrhs), intent inout
    info : fwi_integer, intent out

    """
    cdef np.ndarray ab_
    cdef fw_shape_t ab_shape_[2]
    cdef np.ndarray b_
    cdef fw_shape_t b_shape_[2]
    cdef fwi_integer_t ldab_
    cdef fwi_integer_t n
    cdef fwi_integer_t kd
    cdef fwi_integer_t nrhs
    cdef fwi_integer_t ldb
    cdef fwi_integer_t fw_iserr__
    cdef char *fw_uplo_f = [0, 0]
    cdef fwi_integer_t info
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    uplo_f = "L" if lower else "U"
    ab_, ab = fw_asfortranarray(ab, {{npy_enum}}, 2, not overwrite_ab)
    fw_copyshape(ab_shape_, np.PyArray_DIMS(ab_), 2)
    kd = np.PyArray_DIMS(ab_)[0] - 1
    ldab_ = ldab if (ldab is not None) else np.PyArray_DIMS(ab_)[0]
    if not ((lower == 0) or (lower == 1)):
        raise ValueError('Condition on arguments not satisfied: (lower == 0) or (lower == 1)')
    if not (np.PyArray_DIMS(ab_)[0] == ldab_):
        raise ValueError('Condition on arguments not satisfied: ab.shape[0] == ldab')
    n = np.PyArray_DIMS(ab_)[1]
    if ldab_ != ab_shape_[0]:
        raise ValueError("(ldab == ab.shape[0]) not satisifed")
    if not (0 <= n <= ab_shape_[1]):
        raise ValueError("(0 <= n <= ab.shape[1]) not satisifed")
    b_, b = fw_asfortranarray(b, {{npy_enum}}, 2, not overwrite_b)
    fw_copyshape(b_shape_, np.PyArray_DIMS(b_), 2)
    nrhs = np.PyArray_DIMS(b_)[1]
    ldb = np.PyArray_DIMS(b_)[0]
    if ldb != b_shape_[0]:
        raise ValueError("(ldb == b.shape[0]) not satisifed")
    if not (0 <= nrhs <= b_shape_[1]):
        raise ValueError("(0 <= nrhs <= b.shape[1]) not satisifed")
    fw_uplo_f[0] = fw_aschar(uplo_f)
    if fw_uplo_f[0] == 0:
        raise ValueError("len(uplo_f) != 1")
    {{fc_name}}(fw_uplo_f, &n, &kd, &nrhs, ab_shape_, <{{ktp}}*>np.PyArray_DATA(ab_), &ldab_, b_shape_, <{{ktp}}*>np.PyArray_DATA(b_), &ldb, &info, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the '{{name}}' wrapper.")
    return (ab, b, info,)
{{endfor}}


{{for fc_name, ktp, name, npy_enum
      in zip(['spbtrf_c', 'dpbtrf_c', 'cpbtrf_c', 'zpbtrf_c'],
             ['fwr_real_t', 'fwr_dbl_t', 'fwc_complex_t', 'fwc_dbl_complex_t'],
             ['spbtrf', 'dpbtrf', 'cpbtrf', 'zpbtrf'],
             ['fwr_real_t_enum', 'fwr_dbl_t_enum', 'fwc_complex_t_enum', 'fwc_dbl_complex_t_enum'])}}
cpdef api object {{name}}(object ab, fwi_integer_t lower=0, object ldab=None, bint overwrite_ab=False):
    """{{name}}(ab[, lower, ldab, overwrite_ab]) -> (ab, info)

    Parameters
    ----------
    ab : {{ktp}}_, 2D array, dimension(ldab, n), intent inout
    lower : fwi_integer, intent in
    ldab : fwi_integer, intent in
    overwrite_ab : bint_, intent in

    Returns
    -------
    ab : {{ktp}}_, 2D array, dimension(ldab, n), intent inout
    info : fwi_integer, intent out

    """
    cdef np.ndarray ab_
    cdef fw_shape_t ab_shape_[2]
    cdef fwi_integer_t ldab_
    cdef fwi_integer_t n
    cdef fwi_integer_t kd
    cdef fwi_integer_t fw_iserr__
    cdef char *fw_uplo_f = [0, 0]
    cdef fwi_integer_t info
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    uplo_f = "L" if lower else "U"
    ab_, ab = fw_asfortranarray(ab, {{npy_enum}}, 2, not overwrite_ab)
    fw_copyshape(ab_shape_, np.PyArray_DIMS(ab_), 2)
    kd = np.PyArray_DIMS(ab_)[0] - 1
    ldab_ = ldab if (ldab is not None) else np.PyArray_DIMS(ab_)[0]
    if not ((lower == 0) or (lower == 1)):
        raise ValueError('Condition on arguments not satisfied: (lower == 0) or (lower == 1)')
    if not (np.PyArray_DIMS(ab_)[0] == ldab_):
        raise ValueError('Condition on arguments not satisfied: ab.shape[0] == ldab')
    n = np.PyArray_DIMS(ab_)[1]
    if ldab_ != ab_shape_[0]:
        raise ValueError("(ldab == ab.shape[0]) not satisifed")
    if not (0 <= n <= ab_shape_[1]):
        raise ValueError("(0 <= n <= ab.shape[1]) not satisifed")
    fw_uplo_f[0] = fw_aschar(uplo_f)
    if fw_uplo_f[0] == 0:
        raise ValueError("len(uplo_f) != 1")
    {{fc_name}}(fw_uplo_f, &n, &kd, ab_shape_, <{{ktp}}*>np.PyArray_DATA(ab_), &ldab_, &info, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the '{{name}}' wrapper.")
    return (ab, info,)
{{endfor}}


{{for fc_name, ktp, name, npy_enum
      in zip(['spbtrs_c', 'dpbtrs_c', 'cpbtrs_c', 'zpbtrs_c'],
             ['fwr_real_t', 'fwr_dbl_t', 'fwc_complex_t', 'fwc_dbl_complex_t'],
             ['spbtrs', 'dpbtrs', 'cpbtrs', 'zpbtrs'],
             ['fwr_real_t_enum', 'fwr_dbl_t_enum', 'fwc_complex_t_enum', 'fwc_dbl_complex_t_enum'])}}
cpdef api object {{name}}(object ab, object b, fwi_integer_t lower=0, object ldab=None, bint overwrite_b=False):
    """{{name}}(ab, b[, lower, ldab, overwrite_b]) -> (b, info)

    Parameters
    ----------
    ab : {{ktp}}_, 2D array, dimension(ldab, n), intent in
    b : {{ktp}}_, 2D array, dimension(ldb, nrhs), intent inout
    lower : fwi_integer, intent in
    ldab : fwi_integer, intent in
    overwrite_b : bint_, intent in

    Returns
    -------
    b : {{ktp}}_, 2D array, dimension(ldb, nrhs), intent inout
    info : fwi_integer, intent out

    """
    cdef np.ndarray ab_
    cdef fw_shape_t ab_shape_[2]
    cdef np.ndarray b_
    cdef fw_shape_t b_shape_[2]
    cdef fwi_integer_t ldab_
    cdef fwi_integer_t n
    cdef fwi_integer_t kd
    cdef fwi_integer_t nrhs
    cdef fwi_integer_t ldb
    cdef fwi_integer_t fw_iserr__
    cdef char *fw_uplo_f = [0, 0]
    cdef fwi_integer_t info
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    uplo_f = "L" if lower else "U"
    ab_, ab = fw_asfortranarray(ab, {{npy_enum}}, 2, False)
    fw_copyshape(ab_shape_, np.PyArray_DIMS(ab_), 2)
    kd = np.PyArray_DIMS(ab_)[0] - 1
    ldab_ = ldab if (ldab is not None) else np.PyArray_DIMS(ab_)[0]
    if not ((lower == 0) or (lower == 1)):
        raise ValueError('Condition on arguments not satisfied: (lower == 0) or (lower == 1)')
    if not (np.PyArray_DIMS(ab_)[0] == ldab_):
        raise ValueError('Condition on arguments not satisfied: ab.shape[0] == ldab')
    n = np.PyArray_DIMS(ab_)[1]
    if ldab_ != ab_shape_[0]:
        raise ValueError("(ldab == ab.shape[0]) not satisifed")
    if not (0 <= n <= ab_shape_[1]):
        raise ValueError("(0 <= n <= ab.shape[1]) not satisifed")
    b_, b = fw_asfortranarray(b, {{npy_enum}}, 2, not overwrite_b)
    fw_copyshape(b_shape_, np.PyArray_DIMS(b_), 2)
    nrhs = np.PyArray_DIMS(b_)[1]
    ldb = np.PyArray_DIMS(b_)[0]
    if ldb != b_shape_[0]:
        raise ValueError("(ldb == b.shape[0]) not satisifed")
    if not (0 <= nrhs <= b_shape_[1]):
        raise ValueError("(0 <= nrhs <= b.shape[1]) not satisifed")
    fw_uplo_f[0] = fw_aschar(uplo_f)
    if fw_uplo_f[0] == 0:
        raise ValueError("len(uplo_f) != 1")
    {{fc_name}}(fw_uplo_f, &n, &kd, &nrhs, ab_shape_, <{{ktp}}*>np.PyArray_DATA(ab_), &ldab_, b_shape_, <{{ktp}}*>np.PyArray_DATA(b_), &ldb, &info, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the '{{name}}' wrapper.")
    return (b, info,)
{{endfor}}


{{for fc_name, ktp, name, npy_enum
      in zip(['sposv_c', 'dposv_c', 'cposv_c', 'zposv_c'],
             ['fwr_real_t', 'fwr_dbl_t', 'fwc_complex_t', 'fwc_dbl_complex_t'],
             ['sposv', 'dposv', 'cposv', 'zposv'],
             ['fwr_real_t_enum', 'fwr_dbl_t_enum', 'fwc_complex_t_enum', 'fwc_dbl_complex_t_enum'])}}
cpdef api object {{name}}(object a, object b, fwi_integer_t lower=0, bint overwrite_a=False, bint overwrite_b=False):
    """{{name}}(a, b[, lower, overwrite_a, overwrite_b]) -> (a, b, info)

    Parameters
    ----------
    a : {{ktp}}_, 2D array, dimension(n, n), intent inout
    b : {{ktp}}_, 2D array, dimension(n, nrhs), intent inout
    lower : fwi_integer, intent in
    overwrite_a : bint_, intent in
    overwrite_b : bint_, intent in

    Returns
    -------
    a : {{ktp}}_, 2D array, dimension(n, n), intent inout
    b : {{ktp}}_, 2D array, dimension(n, nrhs), intent inout
    info : fwi_integer, intent out

    """
    cdef np.ndarray a_
    cdef fw_shape_t a_shape_[2]
    cdef np.ndarray b_
    cdef fw_shape_t b_shape_[2]
    cdef fwi_integer_t n
    cdef fwi_integer_t nrhs
    cdef fwi_integer_t fw_iserr__
    cdef char *fw_uplo_f = [0, 0]
    cdef fwi_integer_t info
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    uplo_f = "L" if lower else "U"
    a_, a = fw_asfortranarray(a, {{npy_enum}}, 2, not overwrite_a)
    fw_copyshape(a_shape_, np.PyArray_DIMS(a_), 2)
    b_, b = fw_asfortranarray(b, {{npy_enum}}, 2, not overwrite_b)
    fw_copyshape(b_shape_, np.PyArray_DIMS(b_), 2)
    if not (np.PyArray_DIMS(a_)[0] == np.PyArray_DIMS(a_)[1]):
        raise ValueError('Condition on arguments not satisfied: a.shape[0] == a.shape[1]')
    if not (np.PyArray_DIMS(a_)[0] == np.PyArray_DIMS(b_)[0]):
        raise ValueError('Condition on arguments not satisfied: a.shape[0] == b.shape[0]')
    if not ((lower == 0) or (lower == 1)):
        raise ValueError('Condition on arguments not satisfied: (lower == 0) or (lower == 1)')
    n = np.PyArray_DIMS(a_)[0]
    if n != a_shape_[0]:
        raise ValueError("(n == a.shape[0]) not satisifed")
    if not (0 <= n <= a_shape_[1]):
        raise ValueError("(0 <= n <= a.shape[1]) not satisifed")
    nrhs = np.PyArray_DIMS(b_)[1]
    if n != b_shape_[0]:
        raise ValueError("(n == b.shape[0]) not satisifed")
    if not (0 <= nrhs <= b_shape_[1]):
        raise ValueError("(0 <= nrhs <= b.shape[1]) not satisifed")
    fw_uplo_f[0] = fw_aschar(uplo_f)
    if fw_uplo_f[0] == 0:
        raise ValueError("len(uplo_f) != 1")
    {{fc_name}}(fw_uplo_f, &n, &nrhs, a_shape_, <{{ktp}}*>np.PyArray_DATA(a_), &n, b_shape_, <{{ktp}}*>np.PyArray_DATA(b_), &n, &info, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the '{{name}}' wrapper.")
    return (a, b, info,)
{{endfor}}


{{for fc_name, ktp, name, npy_enum, pyf_post_call_code
      in zip(['spotrf_c', 'dpotrf_c', 'cpotrf_c', 'zpotrf_c'],
             ['fwr_real_t', 'fwr_dbl_t', 'fwc_complex_t', 'fwc_dbl_complex_t'],
             ['spotrf', 'dpotrf', 'cpotrf', 'zpotrf'],
             ['fwr_real_t_enum', 'fwr_dbl_t_enum', 'fwc_complex_t_enum', 'fwc_dbl_complex_t_enum'],
             ['if(clean){int i,j;if(lower){for(i=0;i<n;++i) for(j=i+1;j<n;++j) *(a+j*n+i)=0.0;} else {for(i=0;i<n;++i) for(j=i+1;j<n;++j) *(a+i*n+j)=0.0', 'if(clean){int i,j;if(lower){for(i=0;i<n;++i) for(j=i+1;j<n;++j) *(a+j*n+i)=0.0;} else {for(i=0;i<n;++i) for(j=i+1;j<n;++j) *(a+i*n+j)=0.0', 'if(clean){int i,j,k;if(lower){for(i=0;i<n;++i) for(j=i+1;j<n;++j) {k=j*n+i;(a+k)->r=(a+k)->i=0.0;}} else {for(i=0;i<n;++i) for(j=i+1;j<n;++j) {k=i*n+j;(a+k)->r=(a+k)->i=0.0', 'if(clean){int i,j,k;if(lower){for(i=0;i<n;++i) for(j=i+1;j<n;++j) {k=j*n+i;(a+k)->r=(a+k)->i=0.0;}} else {for(i=0;i<n;++i) for(j=i+1;j<n;++j) {k=i*n+j;(a+k)->r=(a+k)->i=0.0'])}}
cpdef api object {{name}}(object a, fwi_integer_t lower=0, fwi_integer_t clean=1, bint overwrite_a=False):
    """{{name}}(a[, lower, clean, overwrite_a]) -> (a, info)

    Parameters
    ----------
    a : {{ktp}}_, 2D array, dimension(n, n), intent inout
    lower : fwi_integer, intent in
    clean : fwi_integer, intent in
    overwrite_a : bint_, intent in

    Returns
    -------
    a : {{ktp}}_, 2D array, dimension(n, n), intent inout
    info : fwi_integer, intent out

    """
    cdef np.ndarray a_
    cdef fw_shape_t a_shape_[2]
    cdef fwi_integer_t n
    cdef fwi_integer_t fw_iserr__
    cdef char *fw_uplo_f = [0, 0]
    cdef fwi_integer_t info
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    uplo_f = "L" if lower else "U"
    a_, a = fw_asfortranarray(a, {{npy_enum}}, 2, not overwrite_a)
    fw_copyshape(a_shape_, np.PyArray_DIMS(a_), 2)
    if not (np.PyArray_DIMS(a_)[0] == np.PyArray_DIMS(a_)[1]):
        raise ValueError('Condition on arguments not satisfied: a.shape[0] == a.shape[1]')
    if not ((lower == 0) or (lower == 1)):
        raise ValueError('Condition on arguments not satisfied: (lower == 0) or (lower == 1)')
    if not ((clean == 0) or (clean == 1)):
        raise ValueError('Condition on arguments not satisfied: (clean == 0) or (clean == 1)')
    n = np.PyArray_DIMS(a_)[0]
    if n != a_shape_[0]:
        raise ValueError("(n == a.shape[0]) not satisifed")
    if not (0 <= n <= a_shape_[1]):
        raise ValueError("(0 <= n <= a.shape[1]) not satisifed")
    fw_uplo_f[0] = fw_aschar(uplo_f)
    if fw_uplo_f[0] == 0:
        raise ValueError("len(uplo_f) != 1")
    {{fc_name}}(fw_uplo_f, &n, a_shape_, <{{ktp}}*>np.PyArray_DATA(a_), &n, &info, &fw_iserr__, fw_errstr__)
    try:
        if fw_iserr__ != FW_NO_ERR__:
            raise RuntimeError("an error was encountered when calling the '{{name}}' wrapper.")
    finally:
        #TODO: {{pyf_post_call_code}}
    return (a, info,)
{{endfor}}


{{for fc_name, ktp, name, npy_enum
      in zip(['spotri_c', 'dpotri_c', 'cpotri_c', 'zpotri_c'],
             ['fwr_real_t', 'fwr_dbl_t', 'fwc_complex_t', 'fwc_dbl_complex_t'],
             ['spotri', 'dpotri', 'cpotri', 'zpotri'],
             ['fwr_real_t_enum', 'fwr_dbl_t_enum', 'fwc_complex_t_enum', 'fwc_dbl_complex_t_enum'])}}
cpdef api object {{name}}(object c, fwi_integer_t lower=0, bint overwrite_c=False):
    """{{name}}(c[, lower, overwrite_c]) -> (c, info)

    Parameters
    ----------
    c : {{ktp}}_, 2D array, dimension(n, n), intent inout
    lower : fwi_integer, intent in
    overwrite_c : bint_, intent in

    Returns
    -------
    c : {{ktp}}_, 2D array, dimension(n, n), intent inout
    info : fwi_integer, intent out

    """
    cdef np.ndarray c_
    cdef fw_shape_t c_shape_[2]
    cdef fwi_integer_t n
    cdef fwi_integer_t fw_iserr__
    cdef char *fw_uplo_f = [0, 0]
    cdef fwi_integer_t info
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    uplo_f = "L" if lower else "U"
    c_, c = fw_asfortranarray(c, {{npy_enum}}, 2, not overwrite_c)
    fw_copyshape(c_shape_, np.PyArray_DIMS(c_), 2)
    if not (np.PyArray_DIMS(c_)[0] == np.PyArray_DIMS(c_)[1]):
        raise ValueError('Condition on arguments not satisfied: c.shape[0] == c.shape[1]')
    if not ((lower == 0) or (lower == 1)):
        raise ValueError('Condition on arguments not satisfied: (lower == 0) or (lower == 1)')
    n = np.PyArray_DIMS(c_)[0]
    if n != c_shape_[0]:
        raise ValueError("(n == c.shape[0]) not satisifed")
    if not (0 <= n <= c_shape_[1]):
        raise ValueError("(0 <= n <= c.shape[1]) not satisifed")
    fw_uplo_f[0] = fw_aschar(uplo_f)
    if fw_uplo_f[0] == 0:
        raise ValueError("len(uplo_f) != 1")
    {{fc_name}}(fw_uplo_f, &n, c_shape_, <{{ktp}}*>np.PyArray_DATA(c_), &n, &info, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the '{{name}}' wrapper.")
    return (c, info,)
{{endfor}}


{{for fc_name, ktp, name, npy_enum
      in zip(['spotrs_c', 'dpotrs_c', 'cpotrs_c', 'zpotrs_c'],
             ['fwr_real_t', 'fwr_dbl_t', 'fwc_complex_t', 'fwc_dbl_complex_t'],
             ['spotrs', 'dpotrs', 'cpotrs', 'zpotrs'],
             ['fwr_real_t_enum', 'fwr_dbl_t_enum', 'fwc_complex_t_enum', 'fwc_dbl_complex_t_enum'])}}
cpdef api object {{name}}(object c, object b, fwi_integer_t lower=0, bint overwrite_b=False):
    """{{name}}(c, b[, lower, overwrite_b]) -> (b, info)

    Parameters
    ----------
    c : {{ktp}}_, 2D array, dimension(n, n), intent in
    b : {{ktp}}_, 2D array, dimension(n, nrhs), intent inout
    lower : fwi_integer, intent in
    overwrite_b : bint_, intent in

    Returns
    -------
    b : {{ktp}}_, 2D array, dimension(n, nrhs), intent inout
    info : fwi_integer, intent out

    """
    cdef np.ndarray c_
    cdef fw_shape_t c_shape_[2]
    cdef np.ndarray b_
    cdef fw_shape_t b_shape_[2]
    cdef fwi_integer_t n
    cdef fwi_integer_t nrhs
    cdef fwi_integer_t fw_iserr__
    cdef char *fw_uplo_f = [0, 0]
    cdef fwi_integer_t info
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    uplo_f = "L" if lower else "U"
    c_, c = fw_asfortranarray(c, {{npy_enum}}, 2, False)
    fw_copyshape(c_shape_, np.PyArray_DIMS(c_), 2)
    b_, b = fw_asfortranarray(b, {{npy_enum}}, 2, not overwrite_b)
    fw_copyshape(b_shape_, np.PyArray_DIMS(b_), 2)
    if not (np.PyArray_DIMS(c_)[0] == np.PyArray_DIMS(c_)[1]):
        raise ValueError('Condition on arguments not satisfied: c.shape[0] == c.shape[1]')
    if not (np.PyArray_DIMS(c_)[0] == np.PyArray_DIMS(b_)[0]):
        raise ValueError('Condition on arguments not satisfied: c.shape[0] == b.shape[0]')
    if not ((lower == 0) or (lower == 1)):
        raise ValueError('Condition on arguments not satisfied: (lower == 0) or (lower == 1)')
    n = np.PyArray_DIMS(c_)[0]
    if n != c_shape_[0]:
        raise ValueError("(n == c.shape[0]) not satisifed")
    if not (0 <= n <= c_shape_[1]):
        raise ValueError("(0 <= n <= c.shape[1]) not satisifed")
    nrhs = np.PyArray_DIMS(b_)[1]
    if n != b_shape_[0]:
        raise ValueError("(n == b.shape[0]) not satisifed")
    if not (0 <= nrhs <= b_shape_[1]):
        raise ValueError("(0 <= nrhs <= b.shape[1]) not satisifed")
    fw_uplo_f[0] = fw_aschar(uplo_f)
    if fw_uplo_f[0] == 0:
        raise ValueError("len(uplo_f) != 1")
    {{fc_name}}(fw_uplo_f, &n, &nrhs, c_shape_, <{{ktp}}*>np.PyArray_DATA(c_), &n, b_shape_, <{{ktp}}*>np.PyArray_DATA(b_), &n, &info, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the '{{name}}' wrapper.")
    return (b, info,)
{{endfor}}


{{for fc_name, ktp, name, npy_enum
      in zip(['ssbev_c', 'dsbev_c'],
             ['fwr_real_t', 'fwr_dbl_t'],
             ['ssbev', 'dsbev'],
             ['fwr_real_t_enum', 'fwr_dbl_t_enum'])}}
cpdef api object {{name}}(object ab, fwi_integer_t compute_v=1, fwi_integer_t lower=0, object ldab=None, object w=None, object z=None, bint overwrite_ab=True):
    """{{name}}(ab[, compute_v, lower, ldab, w, z, overwrite_ab]) -> (w, z, info)

    Parameters
    ----------
    ab : {{ktp}}_, 2D array, dimension(ldab, *), intent in
    compute_v : fwi_integer, intent in
    lower : fwi_integer, intent in
    ldab : fwi_integer, intent in
    w : {{ktp}}_, 1D array, dimension(n), intent out
    z : {{ktp}}_, 2D array, dimension(ldz, ldz), intent out
    overwrite_ab : bint_, intent in

    Returns
    -------
    w : {{ktp}}_, 1D array, dimension(n), intent out
    z : {{ktp}}_, 2D array, dimension(ldz, ldz), intent out
    info : fwi_integer, intent out

    """
    cdef np.ndarray ab_
    cdef fw_shape_t ab_shape_[2]
    cdef fwi_integer_t ldab_
    cdef np.ndarray w_
    cdef fw_shape_t w_shape_[1]
    cdef np.ndarray z_
    cdef fw_shape_t z_shape_[2]
    cdef fwi_integer_t n
    cdef fwi_integer_t kd
    cdef fwi_integer_t ldz
    cdef np.ndarray work_
    cdef fw_shape_t work_shape_[1]
    cdef fwi_integer_t fw_iserr__
    cdef char *fw_jobz_f = [0, 0]
    cdef char *fw_uplo_f = [0, 0]
    cdef fwi_integer_t info
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    jobz_f = "V" if compute_v else "N"
    uplo_f = "L" if lower else "U"
    ab_, ab = fw_asfortranarray(ab, {{npy_enum}}, 2, not overwrite_ab)
    fw_copyshape(ab_shape_, np.PyArray_DIMS(ab_), 2)
    kd = np.PyArray_DIMS(ab_)[0] - 1
    ldab_ = ldab if (ldab is not None) else np.PyArray_DIMS(ab_)[0]
    if not ((compute_v == 1) or (compute_v == 0)):
        raise ValueError('Condition on arguments not satisfied: (compute_v == 1) or (compute_v == 0)')
    if not ((lower == 0) or (lower == 1)):
        raise ValueError('Condition on arguments not satisfied: (lower == 0) or (lower == 1)')
    if not (np.PyArray_DIMS(ab_)[0] == ldab_):
        raise ValueError('Condition on arguments not satisfied: ab.shape[0] == ldab')
    if ldab_ != ab_shape_[0]:
        raise ValueError("(ldab == ab.shape[0]) not satisifed")
    n = np.PyArray_DIMS(ab_)[1]
    w_, w = fw_explicitshapearray(w, {{npy_enum}}, 1, [n], False)
    fw_copyshape(w_shape_, np.PyArray_DIMS(w_), 1)
    if n != w_shape_[0]:
        raise ValueError("(n == w.shape[0]) not satisifed")
    ldz = n if compute_v else 1
    z_, z = fw_explicitshapearray(z, {{npy_enum}}, 2, [ldz, ldz], False)
    fw_copyshape(z_shape_, np.PyArray_DIMS(z_), 2)
    if ldz != z_shape_[0]:
        raise ValueError("(ldz == z.shape[0]) not satisifed")
    if ldz != z_shape_[1]:
        raise ValueError("(ldz == z.shape[1]) not satisifed")
    work_, work = fw_explicitshapearray(None, {{npy_enum}}, 1, [max(1, ((3 * n) - 1))], False)
    fw_copyshape(work_shape_, np.PyArray_DIMS(work_), 1)
    if max(1, ((3 * n) - 1)) != work_shape_[0]:
        raise ValueError("(max(1, ((3 * n) - 1)) == work.shape[0]) not satisifed")
    fw_jobz_f[0] = fw_aschar(jobz_f)
    if fw_jobz_f[0] == 0:
        raise ValueError("len(jobz_f) != 1")
    fw_uplo_f[0] = fw_aschar(uplo_f)
    if fw_uplo_f[0] == 0:
        raise ValueError("len(uplo_f) != 1")
    {{fc_name}}(fw_jobz_f, fw_uplo_f, &n, &kd, ab_shape_, <{{ktp}}*>np.PyArray_DATA(ab_), &ldab_, w_shape_, <{{ktp}}*>np.PyArray_DATA(w_), z_shape_, <{{ktp}}*>np.PyArray_DATA(z_), &ldz, work_shape_, <{{ktp}}*>np.PyArray_DATA(work_), &info, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the '{{name}}' wrapper.")
    return (w, z, info,)
{{endfor}}


{{for fc_name, ktp, name, npy_enum
      in zip(['ssbevd_c', 'dsbevd_c'],
             ['fwr_real_t', 'fwr_dbl_t'],
             ['ssbevd', 'dsbevd'],
             ['fwr_real_t_enum', 'fwr_dbl_t_enum'])}}
cpdef api object {{name}}(object ab, fwi_integer_t compute_v=1, fwi_integer_t lower=0, object ldab=None, object w=None, object z=None, object liwork=None, bint overwrite_ab=True):
    """{{name}}(ab[, compute_v, lower, ldab, w, z, liwork, overwrite_ab]) -> (w, z, info)

    Parameters
    ----------
    ab : {{ktp}}_, 2D array, dimension(ldab, *), intent in
    compute_v : fwi_integer, intent in
    lower : fwi_integer, intent in
    ldab : fwi_integer, intent in
    w : {{ktp}}_, 1D array, dimension(n), intent out
    z : {{ktp}}_, 2D array, dimension(ldz, ldz), intent out
    liwork : fwi_integer, intent in
    overwrite_ab : bint_, intent in

    Returns
    -------
    w : {{ktp}}_, 1D array, dimension(n), intent out
    z : {{ktp}}_, 2D array, dimension(ldz, ldz), intent out
    info : fwi_integer, intent out

    """
    cdef np.ndarray ab_
    cdef fw_shape_t ab_shape_[2]
    cdef fwi_integer_t ldab_
    cdef np.ndarray w_
    cdef fw_shape_t w_shape_[1]
    cdef np.ndarray z_
    cdef fw_shape_t z_shape_[2]
    cdef fwi_integer_t liwork_
    cdef fwi_integer_t n
    cdef fwi_integer_t kd
    cdef fwi_integer_t ldz
    cdef np.ndarray work_
    cdef fw_shape_t work_shape_[1]
    cdef fwi_integer_t lwork
    cdef np.ndarray iwork_
    cdef fw_shape_t iwork_shape_[1]
    cdef fwi_integer_t fw_iserr__
    cdef char *fw_jobz_f = [0, 0]
    cdef char *fw_uplo_f = [0, 0]
    cdef fwi_integer_t info
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    jobz_f = "V" if compute_v else "N"
    uplo_f = "L" if lower else "U"
    ab_, ab = fw_asfortranarray(ab, {{npy_enum}}, 2, not overwrite_ab)
    fw_copyshape(ab_shape_, np.PyArray_DIMS(ab_), 2)
    kd = np.PyArray_DIMS(ab_)[0] - 1
    ldab_ = ldab if (ldab is not None) else np.PyArray_DIMS(ab_)[0]
    n = np.PyArray_DIMS(ab_)[1]
    liwork_ = liwork if (liwork is not None) else (3 + (5 * n)) if compute_v else 1
    if not ((compute_v == 1) or (compute_v == 0)):
        raise ValueError('Condition on arguments not satisfied: (compute_v == 1) or (compute_v == 0)')
    if not ((lower == 0) or (lower == 1)):
        raise ValueError('Condition on arguments not satisfied: (lower == 0) or (lower == 1)')
    if not (np.PyArray_DIMS(ab_)[0] == ldab_):
        raise ValueError('Condition on arguments not satisfied: ab.shape[0] == ldab')
    if not (liwork_ >= ((3 + (5 * n)) if compute_v else 1)):
        raise ValueError('Condition on arguments not satisfied: liwork >= ((3 + (5 * n)) if compute_v else 1)')
    if ldab_ != ab_shape_[0]:
        raise ValueError("(ldab == ab.shape[0]) not satisifed")
    w_, w = fw_explicitshapearray(w, {{npy_enum}}, 1, [n], False)
    fw_copyshape(w_shape_, np.PyArray_DIMS(w_), 1)
    if n != w_shape_[0]:
        raise ValueError("(n == w.shape[0]) not satisifed")
    ldz = n if compute_v else 1
    z_, z = fw_explicitshapearray(z, {{npy_enum}}, 2, [ldz, ldz], False)
    fw_copyshape(z_shape_, np.PyArray_DIMS(z_), 2)
    if ldz != z_shape_[0]:
        raise ValueError("(ldz == z.shape[0]) not satisifed")
    if ldz != z_shape_[1]:
        raise ValueError("(ldz == z.shape[1]) not satisifed")
    lwork = (1 + (5 * n) + (2 * n * n)) if compute_v else (2 * n)
    work_, work = fw_explicitshapearray(None, {{npy_enum}}, 1, [lwork], False)
    fw_copyshape(work_shape_, np.PyArray_DIMS(work_), 1)
    if lwork != work_shape_[0]:
        raise ValueError("(lwork == work.shape[0]) not satisifed")
    iwork_, iwork = fw_explicitshapearray(None, fwi_integer_t_enum, 1, [liwork_], False)
    fw_copyshape(iwork_shape_, np.PyArray_DIMS(iwork_), 1)
    if liwork_ != iwork_shape_[0]:
        raise ValueError("(liwork == iwork.shape[0]) not satisifed")
    fw_jobz_f[0] = fw_aschar(jobz_f)
    if fw_jobz_f[0] == 0:
        raise ValueError("len(jobz_f) != 1")
    fw_uplo_f[0] = fw_aschar(uplo_f)
    if fw_uplo_f[0] == 0:
        raise ValueError("len(uplo_f) != 1")
    {{fc_name}}(fw_jobz_f, fw_uplo_f, &n, &kd, ab_shape_, <{{ktp}}*>np.PyArray_DATA(ab_), &ldab_, w_shape_, <{{ktp}}*>np.PyArray_DATA(w_), z_shape_, <{{ktp}}*>np.PyArray_DATA(z_), &ldz, work_shape_, <{{ktp}}*>np.PyArray_DATA(work_), &lwork, iwork_shape_, <fwi_integer_t*>np.PyArray_DATA(iwork_), &liwork_, &info, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the '{{name}}' wrapper.")
    return (w, z, info,)
{{endfor}}


{{for fc_name, ktp, name, npy_enum
      in zip(['ssbevx_c', 'dsbevx_c'],
             ['fwr_real_t', 'fwr_dbl_t'],
             ['ssbevx', 'dsbevx'],
             ['fwr_real_t_enum', 'fwr_dbl_t_enum'])}}
cpdef api object {{name}}(object ab, {{ktp}} vl, {{ktp}} vu, fwi_integer_t il, fwi_integer_t iu, object ldab=None, fwi_integer_t compute_v=1, fwi_integer_t range=0, fwi_integer_t lower=0, {{ktp}} abstol=0.0, object w=None, object z=None, object mmax=None, object ifail=None, bint overwrite_ab=True):
    """{{name}}(ab, vl, vu, il, iu[, ldab, compute_v, range, lower, abstol, w, z, mmax, ifail, overwrite_ab]) -> (w, z, m, ifail, info)

    Parameters
    ----------
    ab : {{ktp}}_, 2D array, dimension(ldab, *), intent in
    vl : {{ktp}}_, intent in
    vu : {{ktp}}_, intent in
    il : fwi_integer, intent in
    iu : fwi_integer, intent in
    ldab : fwi_integer, intent in
    compute_v : fwi_integer, intent in
    range : fwi_integer, intent in
    lower : fwi_integer, intent in
    abstol : {{ktp}}_, intent in
    w : {{ktp}}_, 1D array, dimension(n), intent out
    z : {{ktp}}_, 2D array, dimension(ldz, mmax), intent out
    mmax : fwi_integer, intent in
    ifail : fwi_integer, 1D array, dimension(ifail_len), intent out
    overwrite_ab : bint_, intent in

    Returns
    -------
    w : {{ktp}}_, 1D array, dimension(n), intent out
    z : {{ktp}}_, 2D array, dimension(ldz, mmax), intent out
    m : fwi_integer, intent out
    ifail : fwi_integer, 1D array, dimension(ifail_len), intent out
    info : fwi_integer, intent out

    """
    cdef np.ndarray ab_
    cdef fw_shape_t ab_shape_[2]
    cdef fwi_integer_t ldab_
    cdef np.ndarray w_
    cdef fw_shape_t w_shape_[1]
    cdef np.ndarray z_
    cdef fw_shape_t z_shape_[2]
    cdef fwi_integer_t mmax_
    cdef np.ndarray ifail_
    cdef fw_shape_t ifail_shape_[1]
    cdef fwi_integer_t n
    cdef fwi_integer_t kd
    cdef np.ndarray q_
    cdef fw_shape_t q_shape_[2]
    cdef fwi_integer_t ldq
    cdef fwi_integer_t ldz
    cdef np.ndarray work_
    cdef fw_shape_t work_shape_[1]
    cdef np.ndarray iwork_
    cdef fw_shape_t iwork_shape_[1]
    cdef fwi_integer_t ifail_len
    cdef fwi_integer_t fw_iserr__
    cdef char *fw_jobz_f = [0, 0]
    cdef char *fw_range_f = [0, 0]
    cdef char *fw_uplo_f = [0, 0]
    cdef fwi_integer_t m
    cdef fwi_integer_t info
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    jobz_f = "V" if compute_v else "N"
    range_f = ("V" if (range == 1) else "I") if (range > 0) else "A"
    uplo_f = "L" if lower else "U"
    ab_, ab = fw_asfortranarray(ab, {{npy_enum}}, 2, not overwrite_ab)
    fw_copyshape(ab_shape_, np.PyArray_DIMS(ab_), 2)
    kd = np.PyArray_DIMS(ab_)[0] - 1
    ldab_ = ldab if (ldab is not None) else np.PyArray_DIMS(ab_)[0]
    n = np.PyArray_DIMS(ab_)[1]
    if not ((il >= 1) and (il <= n)):
        raise ValueError('Condition on arguments not satisfied: (il >= 1) and (il <= n)')
    if not ((iu >= 1) and (iu <= n) and (iu >= il)):
        raise ValueError('Condition on arguments not satisfied: (iu >= 1) and (iu <= n) and (iu >= il)')
    if not (np.PyArray_DIMS(ab_)[0] == ldab_):
        raise ValueError('Condition on arguments not satisfied: ab.shape[0] == ldab')
    if not ((compute_v == 1) or (compute_v == 0)):
        raise ValueError('Condition on arguments not satisfied: (compute_v == 1) or (compute_v == 0)')
    if not ((range == 2) or (range == 1) or (range == 0)):
        raise ValueError('Condition on arguments not satisfied: (range == 2) or (range == 1) or (range == 0)')
    if not ((lower == 0) or (lower == 1)):
        raise ValueError('Condition on arguments not satisfied: (lower == 0) or (lower == 1)')
    if ldab_ != ab_shape_[0]:
        raise ValueError("(ldab == ab.shape[0]) not satisifed")
    w_, w = fw_explicitshapearray(w, {{npy_enum}}, 1, [n], False)
    fw_copyshape(w_shape_, np.PyArray_DIMS(w_), 1)
    if n != w_shape_[0]:
        raise ValueError("(n == w.shape[0]) not satisifed")
    mmax_ = mmax if (mmax is not None) else ((iu - il + 1) if (range == 2) else n) if compute_v else 1
    ldz = n if compute_v else 1
    z_, z = fw_explicitshapearray(z, {{npy_enum}}, 2, [ldz, mmax_], False)
    fw_copyshape(z_shape_, np.PyArray_DIMS(z_), 2)
    if ldz != z_shape_[0]:
        raise ValueError("(ldz == z.shape[0]) not satisifed")
    if not (0 <= mmax_ <= z_shape_[1]):
        raise ValueError("(0 <= mmax <= z.shape[1]) not satisifed")
    ifail_len = n if compute_v else 1
    ifail_, ifail = fw_explicitshapearray(ifail, fwi_integer_t_enum, 1, [ifail_len], False)
    fw_copyshape(ifail_shape_, np.PyArray_DIMS(ifail_), 1)
    if not (0 <= ifail_len <= ifail_shape_[0]):
        raise ValueError("(0 <= ifail_len <= ifail.shape[0]) not satisifed")
    ldq = n if compute_v else 1
    q_, q = fw_explicitshapearray(None, {{npy_enum}}, 2, [ldq, ldq], False)
    fw_copyshape(q_shape_, np.PyArray_DIMS(q_), 2)
    if ldq != q_shape_[0]:
        raise ValueError("(ldq == q.shape[0]) not satisifed")
    if ldq != q_shape_[1]:
        raise ValueError("(ldq == q.shape[1]) not satisifed")
    work_, work = fw_explicitshapearray(None, {{npy_enum}}, 1, [7 * n], False)
    fw_copyshape(work_shape_, np.PyArray_DIMS(work_), 1)
    if not (0 <= 7 * n <= work_shape_[0]):
        raise ValueError("(0 <= 7 * n <= work.shape[0]) not satisifed")
    iwork_, iwork = fw_explicitshapearray(None, fwi_integer_t_enum, 1, [5 * n], False)
    fw_copyshape(iwork_shape_, np.PyArray_DIMS(iwork_), 1)
    if not (0 <= 5 * n <= iwork_shape_[0]):
        raise ValueError("(0 <= 5 * n <= iwork.shape[0]) not satisifed")
    fw_jobz_f[0] = fw_aschar(jobz_f)
    if fw_jobz_f[0] == 0:
        raise ValueError("len(jobz_f) != 1")
    fw_range_f[0] = fw_aschar(range_f)
    if fw_range_f[0] == 0:
        raise ValueError("len(range_f) != 1")
    fw_uplo_f[0] = fw_aschar(uplo_f)
    if fw_uplo_f[0] == 0:
        raise ValueError("len(uplo_f) != 1")
    {{fc_name}}(fw_jobz_f, fw_range_f, fw_uplo_f, &n, &kd, ab_shape_, <{{ktp}}*>np.PyArray_DATA(ab_), &ldab_, q_shape_, <{{ktp}}*>np.PyArray_DATA(q_), &ldq, &vl, &vu, &il, &iu, &abstol, &m, w_shape_, <{{ktp}}*>np.PyArray_DATA(w_), z_shape_, <{{ktp}}*>np.PyArray_DATA(z_), &ldz, work_shape_, <{{ktp}}*>np.PyArray_DATA(work_), iwork_shape_, <fwi_integer_t*>np.PyArray_DATA(iwork_), ifail_shape_, <fwi_integer_t*>np.PyArray_DATA(ifail_), &info, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the '{{name}}' wrapper.")
    return (w, z, m, ifail, info,)
{{endfor}}


{{for fc_name, ktp, name, npy_enum
      in zip(['ssyev_c', 'dsyev_c'],
             ['fwr_real_t', 'fwr_dbl_t'],
             ['ssyev', 'dsyev'],
             ['fwr_real_t_enum', 'fwr_dbl_t_enum'])}}
cpdef api object {{name}}(object a, fwi_integer_t compute_v=1, fwi_integer_t lower=0, object w=None, object lwork=None, bint overwrite_a=False):
    """{{name}}(a[, compute_v, lower, w, lwork, overwrite_a]) -> (w, a, info)

    Parameters
    ----------
    a : {{ktp}}_, 2D array, dimension(n, n), intent inout
    compute_v : fwi_integer, intent in
    lower : fwi_integer, intent in
    w : {{ktp}}_, 1D array, dimension(n), intent out
    lwork : fwi_integer, intent in
    overwrite_a : bint_, intent in

    Returns
    -------
    w : {{ktp}}_, 1D array, dimension(n), intent out
    a : {{ktp}}_, 2D array, dimension(n, n), intent inout
    info : fwi_integer, intent out

    """
    cdef np.ndarray a_
    cdef fw_shape_t a_shape_[2]
    cdef np.ndarray w_
    cdef fw_shape_t w_shape_[1]
    cdef fwi_integer_t lwork_
    cdef fwi_integer_t n
    cdef np.ndarray work_
    cdef fw_shape_t work_shape_[1]
    cdef fwi_integer_t fw_iserr__
    cdef char *fw_jobz_f = [0, 0]
    cdef char *fw_uplo_f = [0, 0]
    cdef fwi_integer_t info
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    jobz_f = "V" if compute_v else "N"
    uplo_f = "L" if lower else "U"
    a_, a = fw_asfortranarray(a, {{npy_enum}}, 2, not overwrite_a)
    fw_copyshape(a_shape_, np.PyArray_DIMS(a_), 2)
    n = np.PyArray_DIMS(a_)[0]
    lwork_ = lwork if (lwork is not None) else (3 * n) - 1
    if not (np.PyArray_DIMS(a_)[0] == np.PyArray_DIMS(a_)[1]):
        raise ValueError('Condition on arguments not satisfied: a.shape[0] == a.shape[1]')
    if not ((compute_v == 1) or (compute_v == 0)):
        raise ValueError('Condition on arguments not satisfied: (compute_v == 1) or (compute_v == 0)')
    if not ((lower == 0) or (lower == 1)):
        raise ValueError('Condition on arguments not satisfied: (lower == 0) or (lower == 1)')
    if not (lwork_ >= ((3 * n) - 1)):
        raise ValueError('Condition on arguments not satisfied: lwork >= ((3 * n) - 1)')
    if n != a_shape_[0]:
        raise ValueError("(n == a.shape[0]) not satisifed")
    if not (0 <= n <= a_shape_[1]):
        raise ValueError("(0 <= n <= a.shape[1]) not satisifed")
    w_, w = fw_explicitshapearray(w, {{npy_enum}}, 1, [n], False)
    fw_copyshape(w_shape_, np.PyArray_DIMS(w_), 1)
    if n != w_shape_[0]:
        raise ValueError("(n == w.shape[0]) not satisifed")
    work_, work = fw_explicitshapearray(None, {{npy_enum}}, 1, [lwork_], False)
    fw_copyshape(work_shape_, np.PyArray_DIMS(work_), 1)
    if lwork_ != work_shape_[0]:
        raise ValueError("(lwork == work.shape[0]) not satisifed")
    fw_jobz_f[0] = fw_aschar(jobz_f)
    if fw_jobz_f[0] == 0:
        raise ValueError("len(jobz_f) != 1")
    fw_uplo_f[0] = fw_aschar(uplo_f)
    if fw_uplo_f[0] == 0:
        raise ValueError("len(uplo_f) != 1")
    {{fc_name}}(fw_jobz_f, fw_uplo_f, &n, a_shape_, <{{ktp}}*>np.PyArray_DATA(a_), &n, w_shape_, <{{ktp}}*>np.PyArray_DATA(w_), work_shape_, <{{ktp}}*>np.PyArray_DATA(work_), &lwork_, &info, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the '{{name}}' wrapper.")
    return (w, a, info,)
{{endfor}}


{{for fc_name, ktp, name, npy_enum
      in zip(['ssyevr_c', 'dsyevr_c'],
             ['fwr_real_t', 'fwr_dbl_t'],
             ['ssyevr', 'dsyevr'],
             ['fwr_real_t_enum', 'fwr_dbl_t_enum'])}}
cpdef api object {{name}}(object a, object jobz='V', object range='A', object uplo='L', fwi_integer_t il=1, object iu=None, object w=None, object z=None, object lwork=None, bint overwrite_a=False):
    """{{name}}(a[, jobz, range, uplo, il, iu, w, z, lwork, overwrite_a]) -> (w, z, info)

    Parameters
    ----------
    a : {{ktp}}_, 2D array, dimension(n, n), intent in
    jobz : object_, intent in
    range : object_, intent in
    uplo : object_, intent in
    il : fwi_integer, intent in
    iu : fwi_integer, intent in
    w : {{ktp}}_, 1D array, dimension(n), intent out
    z : {{ktp}}_, 2D array, dimension(n, m), intent out
    lwork : fwi_integer, intent in
    overwrite_a : bint_, intent in

    Returns
    -------
    w : {{ktp}}_, 1D array, dimension(n), intent out
    z : {{ktp}}_, 2D array, dimension(n, m), intent out
    info : fwi_integer, intent out

    """
    cdef np.ndarray a_
    cdef fw_shape_t a_shape_[2]
    cdef char *fw_jobz = [0, 0]
    cdef char *fw_range = [0, 0]
    cdef char *fw_uplo = [0, 0]
    cdef fwi_integer_t iu_
    cdef np.ndarray w_
    cdef fw_shape_t w_shape_[1]
    cdef np.ndarray z_
    cdef fw_shape_t z_shape_[2]
    cdef fwi_integer_t lwork_
    cdef fwi_integer_t n
    cdef fwi_integer_t lda
    cdef {{ktp}} vl
    cdef {{ktp}} vu
    cdef {{ktp}} abstol
    cdef fwi_integer_t m
    cdef fwi_integer_t ldz
    cdef np.ndarray isuppz_
    cdef fw_shape_t isuppz_shape_[1]
    cdef np.ndarray work_
    cdef fw_shape_t work_shape_[1]
    cdef np.ndarray iwork_
    cdef fw_shape_t iwork_shape_[1]
    cdef fwi_integer_t liwork
    cdef fwi_integer_t fw_iserr__
    cdef fwi_integer_t info
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    a_, a = fw_asfortranarray(a, {{npy_enum}}, 2, not overwrite_a)
    fw_copyshape(a_shape_, np.PyArray_DIMS(a_), 2)
    n = np.PyArray_DIMS(a_)[0]
    lda = n
    vl = 0
    vu = 1
    abstol = 0.
    iu_ = iu if (iu is not None) else n
    m = iu_ - il + 1
    z_, z = fw_explicitshapearray(z, {{npy_enum}}, 2, [n, m], False)
    fw_copyshape(z_shape_, np.PyArray_DIMS(z_), 2)
    ldz = n
    if not (np.PyArray_DIMS(z_)[0] == ldz):
        raise ValueError('Condition on arguments not satisfied: z.shape[0] == ldz')
    if n != a_shape_[0]:
        raise ValueError("(n == a.shape[0]) not satisifed")
    if not (0 <= n <= a_shape_[1]):
        raise ValueError("(0 <= n <= a.shape[1]) not satisifed")
    w_, w = fw_explicitshapearray(w, {{npy_enum}}, 1, [n], False)
    fw_copyshape(w_shape_, np.PyArray_DIMS(w_), 1)
    if n != w_shape_[0]:
        raise ValueError("(n == w.shape[0]) not satisifed")
    if n != z_shape_[0]:
        raise ValueError("(n == z.shape[0]) not satisifed")
    if m != z_shape_[1]:
        raise ValueError("(m == z.shape[1]) not satisifed")
    isuppz_, isuppz = fw_explicitshapearray(None, fwi_integer_t_enum, 1, [2 * m], False)
    fw_copyshape(isuppz_shape_, np.PyArray_DIMS(isuppz_), 1)
    if not (0 <= 2 * m <= isuppz_shape_[0]):
        raise ValueError("(0 <= 2 * m <= isuppz.shape[0]) not satisifed")
    lwork_ = lwork if (lwork is not None) else 26 * n
    work_, work = fw_explicitshapearray(None, {{npy_enum}}, 1, [lwork_], False)
    fw_copyshape(work_shape_, np.PyArray_DIMS(work_), 1)
    if not (0 <= lwork_ <= work_shape_[0]):
        raise ValueError("(0 <= lwork <= work.shape[0]) not satisifed")
    liwork = 10 * n
    iwork_, iwork = fw_explicitshapearray(None, fwi_integer_t_enum, 1, [liwork], False)
    fw_copyshape(iwork_shape_, np.PyArray_DIMS(iwork_), 1)
    if not (0 <= liwork <= iwork_shape_[0]):
        raise ValueError("(0 <= liwork <= iwork.shape[0]) not satisifed")
    fw_jobz[0] = fw_aschar(jobz)
    if fw_jobz[0] == 0:
        raise ValueError("len(jobz) != 1")
    fw_range[0] = fw_aschar(range)
    if fw_range[0] == 0:
        raise ValueError("len(range) != 1")
    fw_uplo[0] = fw_aschar(uplo)
    if fw_uplo[0] == 0:
        raise ValueError("len(uplo) != 1")
    {{fc_name}}(fw_jobz, fw_range, fw_uplo, &n, a_shape_, <{{ktp}}*>np.PyArray_DATA(a_), &lda, &vl, &vu, &il, &iu_, &abstol, &m, w_shape_, <{{ktp}}*>np.PyArray_DATA(w_), z_shape_, <{{ktp}}*>np.PyArray_DATA(z_), &ldz, isuppz_shape_, <fwi_integer_t*>np.PyArray_DATA(isuppz_), work_shape_, <{{ktp}}*>np.PyArray_DATA(work_), &lwork_, iwork_shape_, <fwi_integer_t*>np.PyArray_DATA(iwork_), &liwork, &info, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the '{{name}}' wrapper.")
    return (w, z, info,)
{{endfor}}


{{for fc_name, ktp, name, npy_enum
      in zip(['ssygv_c', 'dsygv_c'],
             ['fwr_real_t', 'fwr_dbl_t'],
             ['ssygv', 'dsygv'],
             ['fwr_real_t_enum', 'fwr_dbl_t_enum'])}}
cpdef api object {{name}}(object a, object b, fwi_integer_t itype=1, object jobz='V', object uplo='L', object w=None, bint overwrite_a=False, bint overwrite_b=False):
    """{{name}}(a, b[, itype, jobz, uplo, w, overwrite_a, overwrite_b]) -> (a, w, info)

    Parameters
    ----------
    a : {{ktp}}_, 2D array, dimension(n, n), intent inout
    b : {{ktp}}_, 2D array, dimension(n, n), intent in
    itype : fwi_integer, intent in
    jobz : object_, intent in
    uplo : object_, intent in
    w : {{ktp}}_, 1D array, dimension(n), intent out
    overwrite_a : bint_, intent in
    overwrite_b : bint_, intent in

    Returns
    -------
    a : {{ktp}}_, 2D array, dimension(n, n), intent inout
    w : {{ktp}}_, 1D array, dimension(n), intent out
    info : fwi_integer, intent out

    """
    cdef np.ndarray a_
    cdef fw_shape_t a_shape_[2]
    cdef np.ndarray b_
    cdef fw_shape_t b_shape_[2]
    cdef char *fw_jobz = [0, 0]
    cdef char *fw_uplo = [0, 0]
    cdef np.ndarray w_
    cdef fw_shape_t w_shape_[1]
    cdef fwi_integer_t n
    cdef fwi_integer_t lda
    cdef fwi_integer_t ldb
    cdef np.ndarray work_
    cdef fw_shape_t work_shape_[1]
    cdef fwi_integer_t lwork
    cdef fwi_integer_t fw_iserr__
    cdef fwi_integer_t info
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    a_, a = fw_asfortranarray(a, {{npy_enum}}, 2, not overwrite_a)
    fw_copyshape(a_shape_, np.PyArray_DIMS(a_), 2)
    n = np.PyArray_DIMS(a_)[0]
    lda = n
    ldb = n
    if n != a_shape_[0]:
        raise ValueError("(n == a.shape[0]) not satisifed")
    if not (0 <= n <= a_shape_[1]):
        raise ValueError("(0 <= n <= a.shape[1]) not satisifed")
    b_, b = fw_asfortranarray(b, {{npy_enum}}, 2, not overwrite_b)
    fw_copyshape(b_shape_, np.PyArray_DIMS(b_), 2)
    if n != b_shape_[0]:
        raise ValueError("(n == b.shape[0]) not satisifed")
    if not (0 <= n <= b_shape_[1]):
        raise ValueError("(0 <= n <= b.shape[1]) not satisifed")
    w_, w = fw_explicitshapearray(w, {{npy_enum}}, 1, [n], False)
    fw_copyshape(w_shape_, np.PyArray_DIMS(w_), 1)
    if n != w_shape_[0]:
        raise ValueError("(n == w.shape[0]) not satisifed")
    lwork = (3 * n) - 1
    work_, work = fw_explicitshapearray(None, {{npy_enum}}, 1, [lwork], False)
    fw_copyshape(work_shape_, np.PyArray_DIMS(work_), 1)
    if not (0 <= lwork <= work_shape_[0]):
        raise ValueError("(0 <= lwork <= work.shape[0]) not satisifed")
    fw_jobz[0] = fw_aschar(jobz)
    if fw_jobz[0] == 0:
        raise ValueError("len(jobz) != 1")
    fw_uplo[0] = fw_aschar(uplo)
    if fw_uplo[0] == 0:
        raise ValueError("len(uplo) != 1")
    {{fc_name}}(&itype, fw_jobz, fw_uplo, &n, a_shape_, <{{ktp}}*>np.PyArray_DATA(a_), &lda, b_shape_, <{{ktp}}*>np.PyArray_DATA(b_), &ldb, w_shape_, <{{ktp}}*>np.PyArray_DATA(w_), work_shape_, <{{ktp}}*>np.PyArray_DATA(work_), &lwork, &info, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the '{{name}}' wrapper.")
    return (a, w, info,)
{{endfor}}


{{for fc_name, ktp, name, npy_enum
      in zip(['ssygvd_c', 'dsygvd_c'],
             ['fwr_real_t', 'fwr_dbl_t'],
             ['ssygvd', 'dsygvd'],
             ['fwr_real_t_enum', 'fwr_dbl_t_enum'])}}
cpdef api object {{name}}(object a, object b, fwi_integer_t itype=1, object jobz='V', object uplo='L', object w=None, object lwork=None, bint overwrite_a=False, bint overwrite_b=False):
    """{{name}}(a, b[, itype, jobz, uplo, w, lwork, overwrite_a, overwrite_b]) -> (a, w, info)

    Parameters
    ----------
    a : {{ktp}}_, 2D array, dimension(n, n), intent inout
    b : {{ktp}}_, 2D array, dimension(n, n), intent in
    itype : fwi_integer, intent in
    jobz : object_, intent in
    uplo : object_, intent in
    w : {{ktp}}_, 1D array, dimension(n), intent out
    lwork : fwi_integer, intent in
    overwrite_a : bint_, intent in
    overwrite_b : bint_, intent in

    Returns
    -------
    a : {{ktp}}_, 2D array, dimension(n, n), intent inout
    w : {{ktp}}_, 1D array, dimension(n), intent out
    info : fwi_integer, intent out

    """
    cdef np.ndarray a_
    cdef fw_shape_t a_shape_[2]
    cdef np.ndarray b_
    cdef fw_shape_t b_shape_[2]
    cdef char *fw_jobz = [0, 0]
    cdef char *fw_uplo = [0, 0]
    cdef np.ndarray w_
    cdef fw_shape_t w_shape_[1]
    cdef fwi_integer_t lwork_
    cdef fwi_integer_t n
    cdef fwi_integer_t lda
    cdef fwi_integer_t ldb
    cdef np.ndarray work_
    cdef fw_shape_t work_shape_[1]
    cdef np.ndarray iwork_
    cdef fw_shape_t iwork_shape_[1]
    cdef fwi_integer_t liwork
    cdef fwi_integer_t fw_iserr__
    cdef fwi_integer_t info
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    a_, a = fw_asfortranarray(a, {{npy_enum}}, 2, not overwrite_a)
    fw_copyshape(a_shape_, np.PyArray_DIMS(a_), 2)
    n = np.PyArray_DIMS(a_)[0]
    lda = n
    ldb = n
    if n != a_shape_[0]:
        raise ValueError("(n == a.shape[0]) not satisifed")
    if not (0 <= n <= a_shape_[1]):
        raise ValueError("(0 <= n <= a.shape[1]) not satisifed")
    b_, b = fw_asfortranarray(b, {{npy_enum}}, 2, not overwrite_b)
    fw_copyshape(b_shape_, np.PyArray_DIMS(b_), 2)
    if n != b_shape_[0]:
        raise ValueError("(n == b.shape[0]) not satisifed")
    if not (0 <= n <= b_shape_[1]):
        raise ValueError("(0 <= n <= b.shape[1]) not satisifed")
    w_, w = fw_explicitshapearray(w, {{npy_enum}}, 1, [n], False)
    fw_copyshape(w_shape_, np.PyArray_DIMS(w_), 1)
    if n != w_shape_[0]:
        raise ValueError("(n == w.shape[0]) not satisifed")
    lwork_ = lwork if (lwork is not None) else 1 + (6 * n) + (2 * n * n)
    work_, work = fw_explicitshapearray(None, {{npy_enum}}, 1, [lwork_], False)
    fw_copyshape(work_shape_, np.PyArray_DIMS(work_), 1)
    if not (0 <= lwork_ <= work_shape_[0]):
        raise ValueError("(0 <= lwork <= work.shape[0]) not satisifed")
    liwork = 3 + (5 * n)
    iwork_, iwork = fw_explicitshapearray(None, fwi_integer_t_enum, 1, [liwork], False)
    fw_copyshape(iwork_shape_, np.PyArray_DIMS(iwork_), 1)
    if not (0 <= liwork <= iwork_shape_[0]):
        raise ValueError("(0 <= liwork <= iwork.shape[0]) not satisifed")
    fw_jobz[0] = fw_aschar(jobz)
    if fw_jobz[0] == 0:
        raise ValueError("len(jobz) != 1")
    fw_uplo[0] = fw_aschar(uplo)
    if fw_uplo[0] == 0:
        raise ValueError("len(uplo) != 1")
    {{fc_name}}(&itype, fw_jobz, fw_uplo, &n, a_shape_, <{{ktp}}*>np.PyArray_DATA(a_), &lda, b_shape_, <{{ktp}}*>np.PyArray_DATA(b_), &ldb, w_shape_, <{{ktp}}*>np.PyArray_DATA(w_), work_shape_, <{{ktp}}*>np.PyArray_DATA(work_), &lwork_, iwork_shape_, <fwi_integer_t*>np.PyArray_DATA(iwork_), &liwork, &info, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the '{{name}}' wrapper.")
    return (a, w, info,)
{{endfor}}


{{for fc_name, ktp, name, npy_enum
      in zip(['ssygvx_c', 'dsygvx_c'],
             ['fwr_real_t', 'fwr_dbl_t'],
             ['ssygvx', 'dsygvx'],
             ['fwr_real_t_enum', 'fwr_dbl_t_enum'])}}
cpdef api object {{name}}(object a, object b, fwi_integer_t iu, fwi_integer_t itype=1, object jobz='V', object uplo='L', fwi_integer_t il=1, object w=None, object z=None, object lwork=None, object ifail=None, bint overwrite_a=False, bint overwrite_b=False):
    """{{name}}(a, b, iu[, itype, jobz, uplo, il, w, z, lwork, ifail, overwrite_a, overwrite_b]) -> (w, z, ifail, info)

    Parameters
    ----------
    a : {{ktp}}_, 2D array, dimension(n, n), intent in
    b : {{ktp}}_, 2D array, dimension(n, n), intent in
    iu : fwi_integer, intent in
    itype : fwi_integer, intent in
    jobz : object_, intent in
    uplo : object_, intent in
    il : fwi_integer, intent in
    w : {{ktp}}_, 1D array, dimension(n), intent out
    z : {{ktp}}_, 2D array, dimension(n, m), intent out
    lwork : fwi_integer, intent in
    ifail : fwi_integer, 1D array, dimension(n), intent out
    overwrite_a : bint_, intent in
    overwrite_b : bint_, intent in

    Returns
    -------
    w : {{ktp}}_, 1D array, dimension(n), intent out
    z : {{ktp}}_, 2D array, dimension(n, m), intent out
    ifail : fwi_integer, 1D array, dimension(n), intent out
    info : fwi_integer, intent out

    """
    cdef np.ndarray a_
    cdef fw_shape_t a_shape_[2]
    cdef np.ndarray b_
    cdef fw_shape_t b_shape_[2]
    cdef char *fw_jobz = [0, 0]
    cdef char *fw_uplo = [0, 0]
    cdef np.ndarray w_
    cdef fw_shape_t w_shape_[1]
    cdef np.ndarray z_
    cdef fw_shape_t z_shape_[2]
    cdef fwi_integer_t lwork_
    cdef np.ndarray ifail_
    cdef fw_shape_t ifail_shape_[1]
    cdef char *fw_range = [0, 0]
    cdef fwi_integer_t n
    cdef fwi_integer_t lda
    cdef fwi_integer_t ldb
    cdef {{ktp}} vl
    cdef {{ktp}} vu
    cdef {{ktp}} abstol
    cdef fwi_integer_t m
    cdef fwi_integer_t ldz
    cdef np.ndarray work_
    cdef fw_shape_t work_shape_[1]
    cdef np.ndarray iwork_
    cdef fw_shape_t iwork_shape_[1]
    cdef fwi_integer_t fw_iserr__
    cdef fwi_integer_t info
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    range = 'I'
    a_, a = fw_asfortranarray(a, {{npy_enum}}, 2, not overwrite_a)
    fw_copyshape(a_shape_, np.PyArray_DIMS(a_), 2)
    n = np.PyArray_DIMS(a_)[0]
    lda = n
    ldb = n
    vl = 0.
    vu = 0.
    abstol = 0.
    m = iu - il + 1
    z_, z = fw_explicitshapearray(z, {{npy_enum}}, 2, [n, m], False)
    fw_copyshape(z_shape_, np.PyArray_DIMS(z_), 2)
    ldz = n
    if not (np.PyArray_DIMS(z_)[0] == ldz):
        raise ValueError('Condition on arguments not satisfied: z.shape[0] == ldz')
    if n != a_shape_[0]:
        raise ValueError("(n == a.shape[0]) not satisifed")
    if not (0 <= n <= a_shape_[1]):
        raise ValueError("(0 <= n <= a.shape[1]) not satisifed")
    b_, b = fw_asfortranarray(b, {{npy_enum}}, 2, not overwrite_b)
    fw_copyshape(b_shape_, np.PyArray_DIMS(b_), 2)
    if n != b_shape_[0]:
        raise ValueError("(n == b.shape[0]) not satisifed")
    if not (0 <= n <= b_shape_[1]):
        raise ValueError("(0 <= n <= b.shape[1]) not satisifed")
    w_, w = fw_explicitshapearray(w, {{npy_enum}}, 1, [n], False)
    fw_copyshape(w_shape_, np.PyArray_DIMS(w_), 1)
    if n != w_shape_[0]:
        raise ValueError("(n == w.shape[0]) not satisifed")
    if n != z_shape_[0]:
        raise ValueError("(n == z.shape[0]) not satisifed")
    if m != z_shape_[1]:
        raise ValueError("(m == z.shape[1]) not satisifed")
    ifail_, ifail = fw_explicitshapearray(ifail, fwi_integer_t_enum, 1, [n], False)
    fw_copyshape(ifail_shape_, np.PyArray_DIMS(ifail_), 1)
    if n != ifail_shape_[0]:
        raise ValueError("(n == ifail.shape[0]) not satisifed")
    lwork_ = lwork if (lwork is not None) else 8 * n
    work_, work = fw_explicitshapearray(None, {{npy_enum}}, 1, [lwork_], False)
    fw_copyshape(work_shape_, np.PyArray_DIMS(work_), 1)
    if lwork_ != work_shape_[0]:
        raise ValueError("(lwork == work.shape[0]) not satisifed")
    iwork_, iwork = fw_explicitshapearray(None, fwi_integer_t_enum, 1, [5 * n], False)
    fw_copyshape(iwork_shape_, np.PyArray_DIMS(iwork_), 1)
    if not (0 <= 5 * n <= iwork_shape_[0]):
        raise ValueError("(0 <= 5 * n <= iwork.shape[0]) not satisifed")
    fw_jobz[0] = fw_aschar(jobz)
    if fw_jobz[0] == 0:
        raise ValueError("len(jobz) != 1")
    fw_range[0] = fw_aschar(range)
    if fw_range[0] == 0:
        raise ValueError("len(range) != 1")
    fw_uplo[0] = fw_aschar(uplo)
    if fw_uplo[0] == 0:
        raise ValueError("len(uplo) != 1")
    {{fc_name}}(&itype, fw_jobz, fw_range, fw_uplo, &n, a_shape_, <{{ktp}}*>np.PyArray_DATA(a_), &lda, b_shape_, <{{ktp}}*>np.PyArray_DATA(b_), &ldb, &vl, &vu, &il, &iu, &abstol, &m, w_shape_, <{{ktp}}*>np.PyArray_DATA(w_), z_shape_, <{{ktp}}*>np.PyArray_DATA(z_), &ldz, work_shape_, <{{ktp}}*>np.PyArray_DATA(work_), &lwork_, iwork_shape_, <fwi_integer_t*>np.PyArray_DATA(iwork_), ifail_shape_, <fwi_integer_t*>np.PyArray_DATA(ifail_), &info, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the '{{name}}' wrapper.")
    return (w, z, ifail, info,)
{{endfor}}


{{for fc_name, ktp, name, npy_enum
      in zip(['strtri_c', 'dtrtri_c', 'ctrtri_c', 'ztrtri_c'],
             ['fwr_real_t', 'fwr_dbl_t', 'fwc_complex_t', 'fwc_dbl_complex_t'],
             ['strtri', 'dtrtri', 'ctrtri', 'ztrtri'],
             ['fwr_real_t_enum', 'fwr_dbl_t_enum', 'fwc_complex_t_enum', 'fwc_dbl_complex_t_enum'])}}
cpdef api object {{name}}(object c, fwi_integer_t lower=0, fwi_integer_t unitdiag=0, bint overwrite_c=False):
    """{{name}}(c[, lower, unitdiag, overwrite_c]) -> (c, info)

    Parameters
    ----------
    c : {{ktp}}_, 2D array, dimension(n, n), intent inout
    lower : fwi_integer, intent in
    unitdiag : fwi_integer, intent in
    overwrite_c : bint_, intent in

    Returns
    -------
    c : {{ktp}}_, 2D array, dimension(n, n), intent inout
    info : fwi_integer, intent out

    """
    cdef np.ndarray c_
    cdef fw_shape_t c_shape_[2]
    cdef fwi_integer_t n
    cdef fwi_integer_t fw_iserr__
    cdef char *fw_uplo_f = [0, 0]
    cdef char *fw_diag_f = [0, 0]
    cdef fwi_integer_t info
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    uplo_f = "L" if lower else "U"
    diag_f = "U" if unitdiag else "N"
    c_, c = fw_asfortranarray(c, {{npy_enum}}, 2, not overwrite_c)
    fw_copyshape(c_shape_, np.PyArray_DIMS(c_), 2)
    if not (np.PyArray_DIMS(c_)[0] == np.PyArray_DIMS(c_)[1]):
        raise ValueError('Condition on arguments not satisfied: c.shape[0] == c.shape[1]')
    if not ((lower == 0) or (lower == 1)):
        raise ValueError('Condition on arguments not satisfied: (lower == 0) or (lower == 1)')
    if not ((unitdiag == 0) or (unitdiag == 1)):
        raise ValueError('Condition on arguments not satisfied: (unitdiag == 0) or (unitdiag == 1)')
    n = np.PyArray_DIMS(c_)[0]
    if n != c_shape_[0]:
        raise ValueError("(n == c.shape[0]) not satisifed")
    if not (0 <= n <= c_shape_[1]):
        raise ValueError("(0 <= n <= c.shape[1]) not satisifed")
    fw_uplo_f[0] = fw_aschar(uplo_f)
    if fw_uplo_f[0] == 0:
        raise ValueError("len(uplo_f) != 1")
    fw_diag_f[0] = fw_aschar(diag_f)
    if fw_diag_f[0] == 0:
        raise ValueError("len(diag_f) != 1")
    {{fc_name}}(fw_uplo_f, fw_diag_f, &n, c_shape_, <{{ktp}}*>np.PyArray_DATA(c_), &n, &info, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the '{{name}}' wrapper.")
    return (c, info,)
{{endfor}}


{{for fc_name, ktp, name, npy_enum
      in zip(['strtrs_c', 'dtrtrs_c', 'ctrtrs_c', 'ztrtrs_c'],
             ['fwr_real_t', 'fwr_dbl_t', 'fwc_complex_t', 'fwc_dbl_complex_t'],
             ['strtrs', 'dtrtrs', 'ctrtrs', 'ztrtrs'],
             ['fwr_real_t_enum', 'fwr_dbl_t_enum', 'fwc_complex_t_enum', 'fwc_dbl_complex_t_enum'])}}
cpdef api object {{name}}(object a, object b, fwi_integer_t lower=0, fwi_integer_t trans=0, fwi_integer_t unitdiag=0, object lda=None, bint overwrite_b=False):
    """{{name}}(a, b[, lower, trans, unitdiag, lda, overwrite_b]) -> (b, info)

    Parameters
    ----------
    a : {{ktp}}_, 2D array, dimension(lda, n), intent in
    b : {{ktp}}_, 2D array, dimension(ldb, nrhs), intent inout
    lower : fwi_integer, intent in
    trans : fwi_integer, intent in
    unitdiag : fwi_integer, intent in
    lda : fwi_integer, intent in
    overwrite_b : bint_, intent in

    Returns
    -------
    b : {{ktp}}_, 2D array, dimension(ldb, nrhs), intent inout
    info : fwi_integer, intent out

    """
    cdef np.ndarray a_
    cdef fw_shape_t a_shape_[2]
    cdef np.ndarray b_
    cdef fw_shape_t b_shape_[2]
    cdef fwi_integer_t lda_
    cdef fwi_integer_t n
    cdef fwi_integer_t nrhs
    cdef fwi_integer_t ldb
    cdef fwi_integer_t fw_iserr__
    cdef char *fw_uplo_f = [0, 0]
    cdef char *fw_trans_f = [0, 0]
    cdef char *fw_diag_f = [0, 0]
    cdef fwi_integer_t info
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    uplo_f = "L" if lower else "U"
    trans_f = ("C" if (trans == 2) else "T") if trans else "N"
    diag_f = "U" if unitdiag else "N"
    a_, a = fw_asfortranarray(a, {{npy_enum}}, 2, False)
    fw_copyshape(a_shape_, np.PyArray_DIMS(a_), 2)
    lda_ = lda if (lda is not None) else np.PyArray_DIMS(a_)[0]
    if not ((lower == 0) or (lower == 1)):
        raise ValueError('Condition on arguments not satisfied: (lower == 0) or (lower == 1)')
    if not ((trans >= 0) and (trans <= 2)):
        raise ValueError('Condition on arguments not satisfied: (trans >= 0) and (trans <= 2)')
    if not ((unitdiag == 0) or (unitdiag == 1)):
        raise ValueError('Condition on arguments not satisfied: (unitdiag == 0) or (unitdiag == 1)')
    if not (np.PyArray_DIMS(a_)[0] == lda_):
        raise ValueError('Condition on arguments not satisfied: a.shape[0] == lda')
    n = np.PyArray_DIMS(a_)[1]
    if lda_ != a_shape_[0]:
        raise ValueError("(lda == a.shape[0]) not satisifed")
    if not (0 <= n <= a_shape_[1]):
        raise ValueError("(0 <= n <= a.shape[1]) not satisifed")
    b_, b = fw_asfortranarray(b, {{npy_enum}}, 2, not overwrite_b)
    fw_copyshape(b_shape_, np.PyArray_DIMS(b_), 2)
    nrhs = np.PyArray_DIMS(b_)[1]
    ldb = np.PyArray_DIMS(b_)[0]
    if ldb != b_shape_[0]:
        raise ValueError("(ldb == b.shape[0]) not satisifed")
    if not (0 <= nrhs <= b_shape_[1]):
        raise ValueError("(0 <= nrhs <= b.shape[1]) not satisifed")
    fw_uplo_f[0] = fw_aschar(uplo_f)
    if fw_uplo_f[0] == 0:
        raise ValueError("len(uplo_f) != 1")
    fw_trans_f[0] = fw_aschar(trans_f)
    if fw_trans_f[0] == 0:
        raise ValueError("len(trans_f) != 1")
    fw_diag_f[0] = fw_aschar(diag_f)
    if fw_diag_f[0] == 0:
        raise ValueError("len(diag_f) != 1")
    {{fc_name}}(fw_uplo_f, fw_trans_f, fw_diag_f, &n, &nrhs, a_shape_, <{{ktp}}*>np.PyArray_DATA(a_), &lda_, b_shape_, <{{ktp}}*>np.PyArray_DATA(b_), &ldb, &info, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the '{{name}}' wrapper.")
    return (b, info,)
{{endfor}}


cpdef api object zgees(object jobvs, object sort, bint select, fwi_integer_t n, object a, fwi_integer_t lda, fwi_integer_t sdim, object w, object vs, fwi_integer_t ldvs, object work, fwi_integer_t lwork, object rwork, object bwork, fwi_integer_t info):
    """zgees(jobvs, sort, select, n, a, lda, sdim, w, vs, ldvs, work, lwork, rwork, bwork, info[, jobvs, sort, select, n, a, lda, sdim, w, vs, ldvs, work, lwork, rwork, bwork, info]) -> (jobvs, sort, select_, n, a, lda, sdim, w, vs, ldvs, work, lwork, rwork, bwork, info)

    Parameters
    ----------
    jobvs : object_, intent inout
    sort : object_, intent inout
    select : fwl_logical, intent inout
    n : fwi_integer, intent inout
    a : fwc_complex_x16, 2D array, dimension(lda, *), intent inout
    lda : fwi_integer, intent inout
    sdim : fwi_integer, intent inout
    w : fwc_complex_x16, 1D array, dimension(*), intent inout
    vs : fwc_complex_x16, 2D array, dimension(ldvs, *), intent inout
    ldvs : fwi_integer, intent inout
    work : fwc_complex_x16, 1D array, dimension(*), intent inout
    lwork : fwi_integer, intent inout
    rwork : fwr_dbl, 1D array, dimension(*), intent inout
    bwork : fwl_logical, 1D array, dimension(*), intent inout
    info : fwi_integer, intent inout

    Returns
    -------
    jobvs : object_, intent inout
    sort : object_, intent inout
    select : fwl_logical, intent inout
    n : fwi_integer, intent inout
    a : fwc_complex_x16, 2D array, dimension(lda, *), intent inout
    lda : fwi_integer, intent inout
    sdim : fwi_integer, intent inout
    w : fwc_complex_x16, 1D array, dimension(*), intent inout
    vs : fwc_complex_x16, 2D array, dimension(ldvs, *), intent inout
    ldvs : fwi_integer, intent inout
    work : fwc_complex_x16, 1D array, dimension(*), intent inout
    lwork : fwi_integer, intent inout
    rwork : fwr_dbl, 1D array, dimension(*), intent inout
    bwork : fwl_logical, 1D array, dimension(*), intent inout
    info : fwi_integer, intent inout

    """
    cdef char *fw_jobvs = [0, 0]
    cdef char *fw_sort = [0, 0]
    cdef fwl_logical_t select_
    cdef np.ndarray a_
    cdef fw_shape_t a_shape_[2]
    cdef np.ndarray w_
    cdef fw_shape_t w_shape_[1]
    cdef np.ndarray vs_
    cdef fw_shape_t vs_shape_[2]
    cdef np.ndarray work_
    cdef fw_shape_t work_shape_[1]
    cdef np.ndarray rwork_
    cdef fw_shape_t rwork_shape_[1]
    cdef np.ndarray bwork_
    cdef fw_shape_t bwork_shape_[1]
    cdef fwi_integer_t fw_iserr__
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    select_ = 1 if select else 0
    a_, a = fw_asfortranarray(a, fwc_complex_x16_t_enum, 2, False)
    fw_copyshape(a_shape_, np.PyArray_DIMS(a_), 2)
    if lda != a_shape_[0]:
        raise ValueError("(lda == a.shape[0]) not satisifed")
    w_, w = fw_asfortranarray(w, fwc_complex_x16_t_enum, 1, False)
    fw_copyshape(w_shape_, np.PyArray_DIMS(w_), 1)
    vs_, vs = fw_asfortranarray(vs, fwc_complex_x16_t_enum, 2, False)
    fw_copyshape(vs_shape_, np.PyArray_DIMS(vs_), 2)
    if ldvs != vs_shape_[0]:
        raise ValueError("(ldvs == vs.shape[0]) not satisifed")
    work_, work = fw_asfortranarray(work, fwc_complex_x16_t_enum, 1, False)
    fw_copyshape(work_shape_, np.PyArray_DIMS(work_), 1)
    rwork_, rwork = fw_asfortranarray(rwork, fwr_dbl_t_enum, 1, False)
    fw_copyshape(rwork_shape_, np.PyArray_DIMS(rwork_), 1)
    bwork_, bwork = fw_asfortranarray(bwork, fwl_logical_t_enum, 1, False)
    fw_copyshape(bwork_shape_, np.PyArray_DIMS(bwork_), 1)
    fw_jobvs[0] = fw_aschar(jobvs)
    if fw_jobvs[0] == 0:
        raise ValueError("len(jobvs) != 1")
    fw_sort[0] = fw_aschar(sort)
    if fw_sort[0] == 0:
        raise ValueError("len(sort) != 1")
    zgees_c(fw_jobvs, fw_sort, &select_, &n, a_shape_, <fwc_complex_x16_t*>np.PyArray_DATA(a_), &lda, &sdim, w_shape_, <fwc_complex_x16_t*>np.PyArray_DATA(w_), vs_shape_, <fwc_complex_x16_t*>np.PyArray_DATA(vs_), &ldvs, work_shape_, <fwc_complex_x16_t*>np.PyArray_DATA(work_), &lwork, rwork_shape_, <fwr_dbl_t*>np.PyArray_DATA(rwork_), bwork_shape_, <fwl_logical_t*>np.PyArray_DATA(bwork_), &info, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the 'zgees' wrapper.")
    return (fw_jobvs, fw_sort, select_, n, a, lda, sdim, w, vs, ldvs, work, lwork, rwork, bwork, info,)


cpdef api object zgeev(object a, fwi_integer_t compute_vl=1, fwi_integer_t compute_vr=1, object w=None, object vl=None, object vr=None, object lwork=None, bint overwrite_a=False):
    """zgeev(a[, compute_vl, compute_vr, w, vl, vr, lwork, overwrite_a]) -> (w, vl, vr, info)

    Parameters
    ----------
    a : fwc_dbl_complex, 2D array, dimension(n, n), intent in
    compute_vl : fwi_integer, intent in
    compute_vr : fwi_integer, intent in
    w : fwc_dbl_complex, 1D array, dimension(n), intent out
    vl : fwc_dbl_complex, 2D array, dimension(ldvl, n), intent out
    vr : fwc_dbl_complex, 2D array, dimension(ldvr, n), intent out
    lwork : fwi_integer, intent in
    overwrite_a : bint_, intent in

    Returns
    -------
    w : fwc_dbl_complex, 1D array, dimension(n), intent out
    vl : fwc_dbl_complex, 2D array, dimension(ldvl, n), intent out
    vr : fwc_dbl_complex, 2D array, dimension(ldvr, n), intent out
    info : fwi_integer, intent out

    """
    cdef np.ndarray a_
    cdef fw_shape_t a_shape_[2]
    cdef np.ndarray w_
    cdef fw_shape_t w_shape_[1]
    cdef np.ndarray vl_
    cdef fw_shape_t vl_shape_[2]
    cdef np.ndarray vr_
    cdef fw_shape_t vr_shape_[2]
    cdef fwi_integer_t lwork_
    cdef fwi_integer_t n
    cdef fwi_integer_t ldvl
    cdef fwi_integer_t ldvr
    cdef np.ndarray work_
    cdef fw_shape_t work_shape_[1]
    cdef np.ndarray rwork_
    cdef fw_shape_t rwork_shape_[1]
    cdef fwi_integer_t fw_iserr__
    cdef char *fw_jobvl_f = [0, 0]
    cdef char *fw_jobvr_f = [0, 0]
    cdef fwi_integer_t info
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    jobvl_f = "V" if compute_vl else "N"
    jobvr_f = "V" if compute_vr else "N"
    a_, a = fw_asfortranarray(a, fwc_dbl_complex_t_enum, 2, not overwrite_a)
    fw_copyshape(a_shape_, np.PyArray_DIMS(a_), 2)
    n = np.PyArray_DIMS(a_)[0]
    lwork_ = lwork if (lwork is not None) else 2 * n
    if not (np.PyArray_DIMS(a_)[0] == np.PyArray_DIMS(a_)[1]):
        raise ValueError('Condition on arguments not satisfied: a.shape[0] == a.shape[1]')
    if not ((compute_vl == 1) or (compute_vl == 0)):
        raise ValueError('Condition on arguments not satisfied: (compute_vl == 1) or (compute_vl == 0)')
    if not ((compute_vr == 1) or (compute_vr == 0)):
        raise ValueError('Condition on arguments not satisfied: (compute_vr == 1) or (compute_vr == 0)')
    if not (lwork_ >= (2 * n)):
        raise ValueError('Condition on arguments not satisfied: lwork >= (2 * n)')
    if n != a_shape_[0]:
        raise ValueError("(n == a.shape[0]) not satisifed")
    if not (0 <= n <= a_shape_[1]):
        raise ValueError("(0 <= n <= a.shape[1]) not satisifed")
    w_, w = fw_explicitshapearray(w, fwc_dbl_complex_t_enum, 1, [n], False)
    fw_copyshape(w_shape_, np.PyArray_DIMS(w_), 1)
    if n != w_shape_[0]:
        raise ValueError("(n == w.shape[0]) not satisifed")
    ldvl = n if compute_vl else 1
    vl_, vl = fw_explicitshapearray(vl, fwc_dbl_complex_t_enum, 2, [ldvl, n], False)
    fw_copyshape(vl_shape_, np.PyArray_DIMS(vl_), 2)
    if ldvl != vl_shape_[0]:
        raise ValueError("(ldvl == vl.shape[0]) not satisifed")
    if not (0 <= n <= vl_shape_[1]):
        raise ValueError("(0 <= n <= vl.shape[1]) not satisifed")
    ldvr = n if compute_vr else 1
    vr_, vr = fw_explicitshapearray(vr, fwc_dbl_complex_t_enum, 2, [ldvr, n], False)
    fw_copyshape(vr_shape_, np.PyArray_DIMS(vr_), 2)
    if ldvr != vr_shape_[0]:
        raise ValueError("(ldvr == vr.shape[0]) not satisifed")
    if not (0 <= n <= vr_shape_[1]):
        raise ValueError("(0 <= n <= vr.shape[1]) not satisifed")
    work_, work = fw_explicitshapearray(None, fwc_dbl_complex_t_enum, 1, [lwork_], False)
    fw_copyshape(work_shape_, np.PyArray_DIMS(work_), 1)
    if lwork_ != work_shape_[0]:
        raise ValueError("(lwork == work.shape[0]) not satisifed")
    rwork_, rwork = fw_explicitshapearray(None, fwr_dbl_t_enum, 1, [2 * n], False)
    fw_copyshape(rwork_shape_, np.PyArray_DIMS(rwork_), 1)
    if 2 * n != rwork_shape_[0]:
        raise ValueError("(2 * n == rwork.shape[0]) not satisifed")
    fw_jobvl_f[0] = fw_aschar(jobvl_f)
    if fw_jobvl_f[0] == 0:
        raise ValueError("len(jobvl_f) != 1")
    fw_jobvr_f[0] = fw_aschar(jobvr_f)
    if fw_jobvr_f[0] == 0:
        raise ValueError("len(jobvr_f) != 1")
    zgeev_c(fw_jobvl_f, fw_jobvr_f, &n, a_shape_, <fwc_dbl_complex_t*>np.PyArray_DATA(a_), &n, w_shape_, <fwc_dbl_complex_t*>np.PyArray_DATA(w_), vl_shape_, <fwc_dbl_complex_t*>np.PyArray_DATA(vl_), &ldvl, vr_shape_, <fwc_dbl_complex_t*>np.PyArray_DATA(vr_), &ldvr, work_shape_, <fwc_dbl_complex_t*>np.PyArray_DATA(work_), &lwork_, rwork_shape_, <fwr_dbl_t*>np.PyArray_DATA(rwork_), &info, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the 'zgeev' wrapper.")
    return (w, vl, vr, info,)


cpdef api object zgegv(object a, object b, fwi_integer_t compute_vl=1, fwi_integer_t compute_vr=1, object alpha=None, object beta=None, object vl=None, object vr=None, object lwork=None, bint overwrite_a=False, bint overwrite_b=False):
    """zgegv(a, b[, compute_vl, compute_vr, alpha, beta, vl, vr, lwork, overwrite_a, overwrite_b]) -> (alpha, beta, vl, vr, info)

    Parameters
    ----------
    a : fwc_dbl_complex, 2D array, dimension(n, n), intent in
    b : fwc_dbl_complex, 2D array, dimension(n, n), intent in
    compute_vl : fwi_integer, intent in
    compute_vr : fwi_integer, intent in
    alpha : fwc_dbl_complex, 1D array, dimension(n), intent out
    beta : fwc_dbl_complex, 1D array, dimension(n), intent out
    vl : fwc_dbl_complex, 2D array, dimension(ldvl, n), intent out
    vr : fwc_dbl_complex, 2D array, dimension(ldvr, n), intent out
    lwork : fwi_integer, intent in
    overwrite_a : bint_, intent in
    overwrite_b : bint_, intent in

    Returns
    -------
    alpha : fwc_dbl_complex, 1D array, dimension(n), intent out
    beta : fwc_dbl_complex, 1D array, dimension(n), intent out
    vl : fwc_dbl_complex, 2D array, dimension(ldvl, n), intent out
    vr : fwc_dbl_complex, 2D array, dimension(ldvr, n), intent out
    info : fwi_integer, intent out

    """
    cdef np.ndarray a_
    cdef fw_shape_t a_shape_[2]
    cdef np.ndarray b_
    cdef fw_shape_t b_shape_[2]
    cdef np.ndarray alpha_
    cdef fw_shape_t alpha_shape_[1]
    cdef np.ndarray beta_
    cdef fw_shape_t beta_shape_[1]
    cdef np.ndarray vl_
    cdef fw_shape_t vl_shape_[2]
    cdef np.ndarray vr_
    cdef fw_shape_t vr_shape_[2]
    cdef fwi_integer_t lwork_
    cdef fwi_integer_t n
    cdef fwi_integer_t ldvl
    cdef fwi_integer_t ldvr
    cdef np.ndarray work_
    cdef fw_shape_t work_shape_[1]
    cdef np.ndarray rwork_
    cdef fw_shape_t rwork_shape_[1]
    cdef fwi_integer_t fw_iserr__
    cdef char *fw_jobvl_f = [0, 0]
    cdef char *fw_jobvr_f = [0, 0]
    cdef fwi_integer_t info
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    jobvl_f = "V" if compute_vl else "N"
    jobvr_f = "V" if compute_vr else "N"
    a_, a = fw_asfortranarray(a, fwc_dbl_complex_t_enum, 2, not overwrite_a)
    fw_copyshape(a_shape_, np.PyArray_DIMS(a_), 2)
    b_, b = fw_asfortranarray(b, fwc_dbl_complex_t_enum, 2, not overwrite_b)
    fw_copyshape(b_shape_, np.PyArray_DIMS(b_), 2)
    n = np.PyArray_DIMS(a_)[0]
    lwork_ = lwork if (lwork is not None) else 2 * n
    if not (np.PyArray_DIMS(a_)[0] == np.PyArray_DIMS(a_)[1]):
        raise ValueError('Condition on arguments not satisfied: a.shape[0] == a.shape[1]')
    if not ((np.PyArray_DIMS(b_)[0] == np.PyArray_DIMS(b_)[1]) and (np.PyArray_DIMS(b_)[0] == n)):
        raise ValueError('Condition on arguments not satisfied: (b.shape[0] == b.shape[1]) and (b.shape[0] == n)')
    if not ((compute_vl == 1) or (compute_vl == 0)):
        raise ValueError('Condition on arguments not satisfied: (compute_vl == 1) or (compute_vl == 0)')
    if not ((compute_vr == 1) or (compute_vr == 0)):
        raise ValueError('Condition on arguments not satisfied: (compute_vr == 1) or (compute_vr == 0)')
    if not (lwork_ >= (2 * n)):
        raise ValueError('Condition on arguments not satisfied: lwork >= (2 * n)')
    if n != a_shape_[0]:
        raise ValueError("(n == a.shape[0]) not satisifed")
    if not (0 <= n <= a_shape_[1]):
        raise ValueError("(0 <= n <= a.shape[1]) not satisifed")
    if n != b_shape_[0]:
        raise ValueError("(n == b.shape[0]) not satisifed")
    if n != b_shape_[1]:
        raise ValueError("(n == b.shape[1]) not satisifed")
    alpha_, alpha = fw_explicitshapearray(alpha, fwc_dbl_complex_t_enum, 1, [n], False)
    fw_copyshape(alpha_shape_, np.PyArray_DIMS(alpha_), 1)
    if n != alpha_shape_[0]:
        raise ValueError("(n == alpha.shape[0]) not satisifed")
    beta_, beta = fw_explicitshapearray(beta, fwc_dbl_complex_t_enum, 1, [n], False)
    fw_copyshape(beta_shape_, np.PyArray_DIMS(beta_), 1)
    if n != beta_shape_[0]:
        raise ValueError("(n == beta.shape[0]) not satisifed")
    ldvl = n if compute_vl else 1
    vl_, vl = fw_explicitshapearray(vl, fwc_dbl_complex_t_enum, 2, [ldvl, n], False)
    fw_copyshape(vl_shape_, np.PyArray_DIMS(vl_), 2)
    if ldvl != vl_shape_[0]:
        raise ValueError("(ldvl == vl.shape[0]) not satisifed")
    if not (0 <= n <= vl_shape_[1]):
        raise ValueError("(0 <= n <= vl.shape[1]) not satisifed")
    ldvr = n if compute_vr else 1
    vr_, vr = fw_explicitshapearray(vr, fwc_dbl_complex_t_enum, 2, [ldvr, n], False)
    fw_copyshape(vr_shape_, np.PyArray_DIMS(vr_), 2)
    if ldvr != vr_shape_[0]:
        raise ValueError("(ldvr == vr.shape[0]) not satisifed")
    if not (0 <= n <= vr_shape_[1]):
        raise ValueError("(0 <= n <= vr.shape[1]) not satisifed")
    work_, work = fw_explicitshapearray(None, fwc_dbl_complex_t_enum, 1, [lwork_], False)
    fw_copyshape(work_shape_, np.PyArray_DIMS(work_), 1)
    if lwork_ != work_shape_[0]:
        raise ValueError("(lwork == work.shape[0]) not satisifed")
    rwork_, rwork = fw_explicitshapearray(None, fwr_dbl_t_enum, 1, [8 * n], False)
    fw_copyshape(rwork_shape_, np.PyArray_DIMS(rwork_), 1)
    if 8 * n != rwork_shape_[0]:
        raise ValueError("(8 * n == rwork.shape[0]) not satisifed")
    fw_jobvl_f[0] = fw_aschar(jobvl_f)
    if fw_jobvl_f[0] == 0:
        raise ValueError("len(jobvl_f) != 1")
    fw_jobvr_f[0] = fw_aschar(jobvr_f)
    if fw_jobvr_f[0] == 0:
        raise ValueError("len(jobvr_f) != 1")
    zgegv_c(fw_jobvl_f, fw_jobvr_f, &n, a_shape_, <fwc_dbl_complex_t*>np.PyArray_DATA(a_), &n, b_shape_, <fwc_dbl_complex_t*>np.PyArray_DATA(b_), &n, alpha_shape_, <fwc_dbl_complex_t*>np.PyArray_DATA(alpha_), beta_shape_, <fwc_dbl_complex_t*>np.PyArray_DATA(beta_), vl_shape_, <fwc_dbl_complex_t*>np.PyArray_DATA(vl_), &ldvl, vr_shape_, <fwc_dbl_complex_t*>np.PyArray_DATA(vr_), &ldvr, work_shape_, <fwc_dbl_complex_t*>np.PyArray_DATA(work_), &lwork_, rwork_shape_, <fwr_dbl_t*>np.PyArray_DATA(rwork_), &info, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the 'zgegv' wrapper.")
    return (alpha, beta, vl, vr, info,)


cpdef api object zgelss(object a, object b, object s=None, fwr_dbl_t cond=-1.0, object lwork=None, bint overwrite_a=False, bint overwrite_b=False):
    """zgelss(a, b[, s, cond, lwork, overwrite_a, overwrite_b]) -> (a, b, s, r, info)

    Parameters
    ----------
    a : fwc_dbl_complex, 2D array, dimension(m, n), intent inout
    b : fwc_dbl_complex, 2D array, dimension(maxmn, nrhs), intent inout
    s : fwr_dbl, 1D array, dimension(minmn), intent out
    cond : fwr_dbl, intent in
    lwork : fwi_integer, intent in
    overwrite_a : bint_, intent in
    overwrite_b : bint_, intent in

    Returns
    -------
    a : fwc_dbl_complex, 2D array, dimension(m, n), intent inout
    b : fwc_dbl_complex, 2D array, dimension(maxmn, nrhs), intent inout
    s : fwr_dbl, 1D array, dimension(minmn), intent out
    r : fwi_integer, intent out
    info : fwi_integer, intent out

    """
    cdef np.ndarray a_
    cdef fw_shape_t a_shape_[2]
    cdef np.ndarray b_
    cdef fw_shape_t b_shape_[2]
    cdef np.ndarray s_
    cdef fw_shape_t s_shape_[1]
    cdef fwi_integer_t lwork_
    cdef fwi_integer_t m
    cdef fwi_integer_t n
    cdef fwi_integer_t minmn
    cdef fwi_integer_t maxmn
    cdef fwi_integer_t nrhs
    cdef np.ndarray work_
    cdef fw_shape_t work_shape_[1]
    cdef np.ndarray rwork_
    cdef fw_shape_t rwork_shape_[1]
    cdef fwi_integer_t fw_iserr__
    cdef fwi_integer_t r
    cdef fwi_integer_t info
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    b_, b = fw_asfortranarray(b, fwc_dbl_complex_t_enum, 2, not overwrite_b)
    fw_copyshape(b_shape_, np.PyArray_DIMS(b_), 2)
    nrhs = np.PyArray_DIMS(b_)[1]
    a_, a = fw_asfortranarray(a, fwc_dbl_complex_t_enum, 2, not overwrite_a)
    fw_copyshape(a_shape_, np.PyArray_DIMS(a_), 2)
    m = np.PyArray_DIMS(a_)[0]
    n = np.PyArray_DIMS(a_)[1]
    maxmn = max(m, n)
    minmn = min(m, n)
    lwork_ = lwork if (lwork is not None) else (2 * minmn) + max(maxmn, nrhs)
    if not (maxmn == np.PyArray_DIMS(b_)[0]):
        raise ValueError('Condition on arguments not satisfied: maxmn == b.shape[0]')
    if not (lwork_ >= 1):
        raise ValueError('Condition on arguments not satisfied: lwork >= 1')
    if m != a_shape_[0]:
        raise ValueError("(m == a.shape[0]) not satisifed")
    if not (0 <= n <= a_shape_[1]):
        raise ValueError("(0 <= n <= a.shape[1]) not satisifed")
    if maxmn != b_shape_[0]:
        raise ValueError("(maxmn == b.shape[0]) not satisifed")
    if not (0 <= nrhs <= b_shape_[1]):
        raise ValueError("(0 <= nrhs <= b.shape[1]) not satisifed")
    s_, s = fw_explicitshapearray(s, fwr_dbl_t_enum, 1, [minmn], False)
    fw_copyshape(s_shape_, np.PyArray_DIMS(s_), 1)
    if minmn != s_shape_[0]:
        raise ValueError("(minmn == s.shape[0]) not satisifed")
    work_, work = fw_explicitshapearray(None, fwc_dbl_complex_t_enum, 1, [lwork_], False)
    fw_copyshape(work_shape_, np.PyArray_DIMS(work_), 1)
    if lwork_ != work_shape_[0]:
        raise ValueError("(lwork == work.shape[0]) not satisifed")
    rwork_, rwork = fw_explicitshapearray(None, fwr_dbl_t_enum, 1, [(5 * minmn) - 1], False)
    fw_copyshape(rwork_shape_, np.PyArray_DIMS(rwork_), 1)
    if not (0 <= (5 * minmn) - 1 <= rwork_shape_[0]):
        raise ValueError("(0 <= (5 * minmn) - 1 <= rwork.shape[0]) not satisifed")
    zgelss_c(&m, &n, &nrhs, a_shape_, <fwc_dbl_complex_t*>np.PyArray_DATA(a_), &m, b_shape_, <fwc_dbl_complex_t*>np.PyArray_DATA(b_), &maxmn, s_shape_, <fwr_dbl_t*>np.PyArray_DATA(s_), &cond, &r, work_shape_, <fwc_dbl_complex_t*>np.PyArray_DATA(work_), &lwork_, rwork_shape_, <fwr_dbl_t*>np.PyArray_DATA(rwork_), &info, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the 'zgelss' wrapper.")
    return (a, b, s, r, info,)


cpdef api object zgesdd(object a, fwi_integer_t compute_uv=1, object u=None, object s=None, object vt=None, object lwork=None, bint overwrite_a=False):
    """zgesdd(a[, compute_uv, u, s, vt, lwork, overwrite_a]) -> (u, s, vt, info)

    Parameters
    ----------
    a : fwc_dbl_complex, 2D array, dimension(m, n), intent in
    compute_uv : fwi_integer, intent in
    u : fwc_dbl_complex, 2D array, dimension(du, du), intent out
    s : fwr_dbl, 1D array, dimension(minmn), intent out
    vt : fwc_dbl_complex, 2D array, dimension(dvt, dvt), intent out
    lwork : fwi_integer, intent in
    overwrite_a : bint_, intent in

    Returns
    -------
    u : fwc_dbl_complex, 2D array, dimension(du, du), intent out
    s : fwr_dbl, 1D array, dimension(minmn), intent out
    vt : fwc_dbl_complex, 2D array, dimension(dvt, dvt), intent out
    info : fwi_integer, intent out

    """
    cdef np.ndarray a_
    cdef fw_shape_t a_shape_[2]
    cdef np.ndarray u_
    cdef fw_shape_t u_shape_[2]
    cdef np.ndarray s_
    cdef fw_shape_t s_shape_[1]
    cdef np.ndarray vt_
    cdef fw_shape_t vt_shape_[2]
    cdef fwi_integer_t lwork_
    cdef fwi_integer_t m
    cdef fwi_integer_t n
    cdef fwi_integer_t minmn
    cdef fwi_integer_t du
    cdef fwi_integer_t dvt
    cdef np.ndarray work_
    cdef fw_shape_t work_shape_[1]
    cdef np.ndarray rwork_
    cdef fw_shape_t rwork_shape_[1]
    cdef np.ndarray iwork_
    cdef fw_shape_t iwork_shape_[1]
    cdef fwi_integer_t rwork_len
    cdef fwi_integer_t fw_iserr__
    cdef char *fw_jobz_f = [0, 0]
    cdef fwi_integer_t info
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    jobz_f = "A" if compute_uv else "N"
    a_, a = fw_asfortranarray(a, fwc_dbl_complex_t_enum, 2, not overwrite_a)
    fw_copyshape(a_shape_, np.PyArray_DIMS(a_), 2)
    m = np.PyArray_DIMS(a_)[0]
    n = np.PyArray_DIMS(a_)[1]
    minmn = min(m, n)
    lwork_ = lwork if (lwork is not None) else ((2 * minmn * minmn) + max(m, n) + (2 * minmn)) if compute_uv else ((2 * minmn) + max(m, n))
    if not ((compute_uv == 0) or (compute_uv == 1)):
        raise ValueError('Condition on arguments not satisfied: (compute_uv == 0) or (compute_uv == 1)')
    if not (lwork_ >= (((2 * minmn * minmn) + max(m, n) + (2 * minmn)) if compute_uv else ((2 * minmn) + max(m, n)))):
        raise ValueError('Condition on arguments not satisfied: lwork >= (((2 * minmn * minmn) + max(m, n) + (2 * minmn)) if compute_uv else ((2 * minmn) + max(m, n)))')
    if m != a_shape_[0]:
        raise ValueError("(m == a.shape[0]) not satisifed")
    if not (0 <= n <= a_shape_[1]):
        raise ValueError("(0 <= n <= a.shape[1]) not satisifed")
    du = m if compute_uv else 1
    u_, u = fw_explicitshapearray(u, fwc_dbl_complex_t_enum, 2, [du, du], False)
    fw_copyshape(u_shape_, np.PyArray_DIMS(u_), 2)
    if du != u_shape_[0]:
        raise ValueError("(du == u.shape[0]) not satisifed")
    if du != u_shape_[1]:
        raise ValueError("(du == u.shape[1]) not satisifed")
    s_, s = fw_explicitshapearray(s, fwr_dbl_t_enum, 1, [minmn], False)
    fw_copyshape(s_shape_, np.PyArray_DIMS(s_), 1)
    if minmn != s_shape_[0]:
        raise ValueError("(minmn == s.shape[0]) not satisifed")
    dvt = n if compute_uv else 1
    vt_, vt = fw_explicitshapearray(vt, fwc_dbl_complex_t_enum, 2, [dvt, dvt], False)
    fw_copyshape(vt_shape_, np.PyArray_DIMS(vt_), 2)
    if dvt != vt_shape_[0]:
        raise ValueError("(dvt == vt.shape[0]) not satisifed")
    if dvt != vt_shape_[1]:
        raise ValueError("(dvt == vt.shape[1]) not satisifed")
    work_, work = fw_explicitshapearray(None, fwc_dbl_complex_t_enum, 1, [lwork_], False)
    fw_copyshape(work_shape_, np.PyArray_DIMS(work_), 1)
    if lwork_ != work_shape_[0]:
        raise ValueError("(lwork == work.shape[0]) not satisifed")
    rwork_len = ((5 * minmn * minmn) + (7 * minmn)) if compute_uv else (5 * minmn)
    rwork_, rwork = fw_explicitshapearray(None, fwr_dbl_t_enum, 1, [rwork_len], False)
    fw_copyshape(rwork_shape_, np.PyArray_DIMS(rwork_), 1)
    if not (0 <= rwork_len <= rwork_shape_[0]):
        raise ValueError("(0 <= rwork_len <= rwork.shape[0]) not satisifed")
    iwork_, iwork = fw_explicitshapearray(None, fwi_integer_t_enum, 1, [8 * minmn], False)
    fw_copyshape(iwork_shape_, np.PyArray_DIMS(iwork_), 1)
    if 8 * minmn != iwork_shape_[0]:
        raise ValueError("(8 * minmn == iwork.shape[0]) not satisifed")
    fw_jobz_f[0] = fw_aschar(jobz_f)
    if fw_jobz_f[0] == 0:
        raise ValueError("len(jobz_f) != 1")
    zgesdd_c(fw_jobz_f, &m, &n, a_shape_, <fwc_dbl_complex_t*>np.PyArray_DATA(a_), &m, s_shape_, <fwr_dbl_t*>np.PyArray_DATA(s_), u_shape_, <fwc_dbl_complex_t*>np.PyArray_DATA(u_), &du, vt_shape_, <fwc_dbl_complex_t*>np.PyArray_DATA(vt_), &dvt, work_shape_, <fwc_dbl_complex_t*>np.PyArray_DATA(work_), &lwork_, rwork_shape_, <fwr_dbl_t*>np.PyArray_DATA(rwork_), iwork_shape_, <fwi_integer_t*>np.PyArray_DATA(iwork_), &info, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the 'zgesdd' wrapper.")
    return (u, s, vt, info,)


cpdef api object zggev(object a, object b, fwi_integer_t compute_vl=1, fwi_integer_t compute_vr=1, object alpha=None, object beta=None, object vl=None, object vr=None, object work=None, object lwork=None, bint overwrite_a=False, bint overwrite_b=False):
    """zggev(a, b[, compute_vl, compute_vr, alpha, beta, vl, vr, work, lwork, overwrite_a, overwrite_b]) -> (alpha, beta, vl, vr, work, info)

    Parameters
    ----------
    a : fwc_dbl_complex, 2D array, dimension(n, n), intent in
    b : fwc_dbl_complex, 2D array, dimension(n, n), intent in
    compute_vl : fwi_integer, intent in
    compute_vr : fwi_integer, intent in
    alpha : fwc_dbl_complex, 1D array, dimension(n), intent out
    beta : fwc_dbl_complex, 1D array, dimension(n), intent out
    vl : fwc_dbl_complex, 2D array, dimension(ldvl, n), intent out
    vr : fwc_dbl_complex, 2D array, dimension(ldvr, n), intent out
    work : fwc_dbl_complex, 1D array, dimension(max(lwork,1)), intent out
    lwork : fwi_integer, intent in
    overwrite_a : bint_, intent in
    overwrite_b : bint_, intent in

    Returns
    -------
    alpha : fwc_dbl_complex, 1D array, dimension(n), intent out
    beta : fwc_dbl_complex, 1D array, dimension(n), intent out
    vl : fwc_dbl_complex, 2D array, dimension(ldvl, n), intent out
    vr : fwc_dbl_complex, 2D array, dimension(ldvr, n), intent out
    work : fwc_dbl_complex, 1D array, dimension(max(lwork,1)), intent out
    info : fwi_integer, intent out

    """
    cdef np.ndarray a_
    cdef fw_shape_t a_shape_[2]
    cdef np.ndarray b_
    cdef fw_shape_t b_shape_[2]
    cdef np.ndarray alpha_
    cdef fw_shape_t alpha_shape_[1]
    cdef np.ndarray beta_
    cdef fw_shape_t beta_shape_[1]
    cdef np.ndarray vl_
    cdef fw_shape_t vl_shape_[2]
    cdef np.ndarray vr_
    cdef fw_shape_t vr_shape_[2]
    cdef np.ndarray work_
    cdef fw_shape_t work_shape_[1]
    cdef fwi_integer_t lwork_
    cdef fwi_integer_t n
    cdef fwi_integer_t ldvl
    cdef fwi_integer_t ldvr
    cdef np.ndarray rwork_
    cdef fw_shape_t rwork_shape_[1]
    cdef fwi_integer_t fw_iserr__
    cdef char *fw_jobvl_f = [0, 0]
    cdef char *fw_jobvr_f = [0, 0]
    cdef fwi_integer_t info
    cdef fw_character_t fw_errstr__[fw_errstr_len]
    jobvl_f = "V" if compute_vl else "N"
    jobvr_f = "V" if compute_vr else "N"
    a_, a = fw_asfortranarray(a, fwc_dbl_complex_t_enum, 2, not overwrite_a)
    fw_copyshape(a_shape_, np.PyArray_DIMS(a_), 2)
    b_, b = fw_asfortranarray(b, fwc_dbl_complex_t_enum, 2, not overwrite_b)
    fw_copyshape(b_shape_, np.PyArray_DIMS(b_), 2)
    n = np.PyArray_DIMS(a_)[0]
    lwork_ = lwork if (lwork is not None) else 2 * n
    if not (np.PyArray_DIMS(a_)[0] == np.PyArray_DIMS(a_)[1]):
        raise ValueError('Condition on arguments not satisfied: a.shape[0] == a.shape[1]')
    if not (np.PyArray_DIMS(b_)[0] == np.PyArray_DIMS(b_)[1]):
        raise ValueError('Condition on arguments not satisfied: b.shape[0] == b.shape[1]')
    if not ((compute_vl == 1) or (compute_vl == 0)):
        raise ValueError('Condition on arguments not satisfied: (compute_vl == 1) or (compute_vl == 0)')
    if not ((compute_vr == 1) or (compute_vr == 0)):
        raise ValueError('Condition on arguments not satisfied: (compute_vr == 1) or (compute_vr == 0)')
    if not ((lwork_ == -1) or (lwork_ >= max(1, (2 * n)))):
        raise ValueError('Condition on arguments not satisfied: (lwork == -1) or (lwork >= max(1, (2 * n)))')
    if n != a_shape_[0]:
        raise ValueError("(n == a.shape[0]) not satisifed")
    if not (0 <= n <= a_shape_[1]):
        raise ValueError("(0 <= n <= a.shape[1]) not satisifed")
    if n != b_shape_[0]:
        raise ValueError("(n == b.shape[0]) not satisifed")
    if not (0 <= n <= b_shape_[1]):
        raise ValueError("(0 <= n <= b.shape[1]) not satisifed")
    alpha_, alpha = fw_explicitshapearray(alpha, fwc_dbl_complex_t_enum, 1, [n], False)
    fw_copyshape(alpha_shape_, np.PyArray_DIMS(alpha_), 1)
    if n != alpha_shape_[0]:
        raise ValueError("(n == alpha.shape[0]) not satisifed")
    beta_, beta = fw_explicitshapearray(beta, fwc_dbl_complex_t_enum, 1, [n], False)
    fw_copyshape(beta_shape_, np.PyArray_DIMS(beta_), 1)
    if n != beta_shape_[0]:
        raise ValueError("(n == beta.shape[0]) not satisifed")
    ldvl = n if compute_vl else 1
    vl_, vl = fw_explicitshapearray(vl, fwc_dbl_complex_t_enum, 2, [ldvl, n], False)
    fw_copyshape(vl_shape_, np.PyArray_DIMS(vl_), 2)
    if ldvl != vl_shape_[0]:
        raise ValueError("(ldvl == vl.shape[0]) not satisifed")
    if n != vl_shape_[1]:
        raise ValueError("(n == vl.shape[1]) not satisifed")
    ldvr = n if compute_vr else 1
    vr_, vr = fw_explicitshapearray(vr, fwc_dbl_complex_t_enum, 2, [ldvr, n], False)
    fw_copyshape(vr_shape_, np.PyArray_DIMS(vr_), 2)
    if ldvr != vr_shape_[0]:
        raise ValueError("(ldvr == vr.shape[0]) not satisifed")
    if n != vr_shape_[1]:
        raise ValueError("(n == vr.shape[1]) not satisifed")
    work_, work = fw_explicitshapearray(work, fwc_dbl_complex_t_enum, 1, [max(lwork_, 1)], False)
    fw_copyshape(work_shape_, np.PyArray_DIMS(work_), 1)
    if max(lwork_, 1) != work_shape_[0]:
        raise ValueError("(max(lwork, 1) == work.shape[0]) not satisifed")
    rwork_, rwork = fw_explicitshapearray(None, fwr_dbl_t_enum, 1, [8 * n], False)
    fw_copyshape(rwork_shape_, np.PyArray_DIMS(rwork_), 1)
    if 8 * n != rwork_shape_[0]:
        raise ValueError("(8 * n == rwork.shape[0]) not satisifed")
    fw_jobvl_f[0] = fw_aschar(jobvl_f)
    if fw_jobvl_f[0] == 0:
        raise ValueError("len(jobvl_f) != 1")
    fw_jobvr_f[0] = fw_aschar(jobvr_f)
    if fw_jobvr_f[0] == 0:
        raise ValueError("len(jobvr_f) != 1")
    zggev_c(fw_jobvl_f, fw_jobvr_f, &n, a_shape_, <fwc_dbl_complex_t*>np.PyArray_DATA(a_), &n, b_shape_, <fwc_dbl_complex_t*>np.PyArray_DATA(b_), &n, alpha_shape_, <fwc_dbl_complex_t*>np.PyArray_DATA(alpha_), beta_shape_, <fwc_dbl_complex_t*>np.PyArray_DATA(beta_), vl_shape_, <fwc_dbl_complex_t*>np.PyArray_DATA(vl_), &ldvl, vr_shape_, <fwc_dbl_complex_t*>np.PyArray_DATA(vr_), &ldvr, work_shape_, <fwc_dbl_complex_t*>np.PyArray_DATA(work_), &lwork_, rwork_shape_, <fwr_dbl_t*>np.PyArray_DATA(rwork_), &info, &fw_iserr__, fw_errstr__)
    if fw_iserr__ != FW_NO_ERR__:
        raise RuntimeError("an error was encountered when calling the 'zggev' wrapper.")
    return (alpha, beta, vl, vr, work, info,)



cdef void fw_copyshape(fw_shape_t *target, np.intp_t *source, int ndim):
    # In f77binding mode, we do not always have fw_shape_t and np.npy_intp
    # as the same type, so must make a copy
    cdef int i
    for i in range(ndim):
        target[i] = source[i]

cdef char fw_aschar(object s):
    cdef char* buf
    try:
        return <char>s # int
    except TypeError:
        pass
    try:
        buf = <char*>s # bytes
    except TypeError:
        s = s.encode('ASCII')
        buf = <char*>s # unicode
    if buf[0] == 0:
        return 0
    elif buf[1] != 0:
        return 0
    else:
        return buf[0]

cdef object fw_explicitshapearray(object value, int typenum, int ndim,
                                  np.intp_t *shape, bint copy):
    if value is None:
        result = np.PyArray_ZEROS(ndim, shape, typenum, 1)
        return result, result
    else:
        return fw_asfortranarray(value, typenum, ndim, copy)

cdef object fw_asfortranarray(object value, int typenum, int ndim, bint copy):
    cdef int flags = np.NPY_F_CONTIGUOUS | np.NPY_FORCECAST
    if ndim <= 1:
        # See http://projects.scipy.org/numpy/ticket/1691 for why this is needed
        flags |= np.NPY_C_CONTIGUOUS
    if copy:
        flags |= np.NPY_ENSURECOPY
    result = np.PyArray_FROMANY(value, typenum, 0, 0, flags)

    if ndim == result.ndim:
        return result, result
    else:
        to_shape = [None] * ndim
        fw_f2py_shape_coercion(ndim, to_shape, result.ndim, result.shape,
                               result.size)
        return result.reshape(to_shape, order='F'), result

cdef object fw_f2py_shape_coercion(int to_ndim, object to_shape,
                                   int from_ndim, object from_shape,
                                   Py_ssize_t from_size):
    # Logic ported from check_and_fix_dimensions in fortranobject.c
    # Todo: optimize
    if to_ndim > from_ndim:
        to_size = 1
        free_ax = -1
        for i in range(from_ndim):
            d = from_shape[i]
            if d == 0:
                d = 1
            to_shape[i] = d
            to_size *= d
        for i in range(from_ndim, to_ndim):
            if free_ax < 0:
                free_ax = i
            else:
                to_shape[i] = 1
        if free_ax >= 0:
            to_shape[free_ax] = from_size // to_size
    elif to_ndim < from_ndim:
        j = 0
        for i in range(from_ndim):
            while j < from_ndim and from_shape[j] < 2:
                j += 1
            if j >= from_ndim:
                d = 1
            else:
                d = from_shape[j]
                j += 1
            if i < to_ndim:
                to_shape[i] = d
            else:
                to_shape[to_ndim - 1] *= d

# Fwrap configuration:
# Fwrap: version 0.2.0dev_8989ae1
# Fwrap: self-sha1 57571a0e42332f3f0c9a5ea3b239886ae0942c94
# Fwrap: pyf-sha1 4b963f85763a1fb28ad84550e01f8960c55ecd12
# Fwrap: wraps $REFERENCE_LAPACK/*.f
# Fwrap:     sha1 06e293fd20e9b3eb70d4bf63898874dd720f21b0
# Fwrap: exclude cbbcsd
# Fwrap: exclude cbdsqr
# Fwrap: exclude cgbbrd
# Fwrap: exclude cgbcon
# Fwrap: exclude cgbequ
# Fwrap: exclude cgbequb
# Fwrap: exclude cgbrfs
# Fwrap: exclude cgbrfsx
# Fwrap: exclude cgbsvx
# Fwrap: exclude cgbsvxx
# Fwrap: exclude cgbtf2
# Fwrap: exclude cgebak
# Fwrap: exclude cgebd2
# Fwrap: exclude cgebrd
# Fwrap: exclude cgecon
# Fwrap: exclude cgeequ
# Fwrap: exclude cgeequb
# Fwrap: exclude cgeesx
# Fwrap: exclude cgeevx
# Fwrap: exclude cgegs
# Fwrap: exclude cgehd2
# Fwrap: exclude cgelq2
# Fwrap: exclude cgelqf
# Fwrap: exclude cgels
# Fwrap: exclude cgelsd
# Fwrap: exclude cgelsx
# Fwrap: exclude cgelsy
# Fwrap: exclude cgeql2
# Fwrap: exclude cgeqlf
# Fwrap: exclude cgeqp3
# Fwrap: exclude cgeqpf
# Fwrap: exclude cgeqr2
# Fwrap: exclude cgeqr2p
# Fwrap: exclude cgeqrfp
# Fwrap: exclude cgerfs
# Fwrap: exclude cgerfsx
# Fwrap: exclude cgerq2
# Fwrap: exclude cgesc2
# Fwrap: exclude cgesvd
# Fwrap: exclude cgesvx
# Fwrap: exclude cgesvxx
# Fwrap: exclude cgetc2
# Fwrap: exclude cgetf2
# Fwrap: exclude cggbak
# Fwrap: exclude cggbal
# Fwrap: exclude cgges
# Fwrap: exclude cggesx
# Fwrap: exclude cggevx
# Fwrap: exclude cggglm
# Fwrap: exclude cgghrd
# Fwrap: exclude cgglse
# Fwrap: exclude cggqrf
# Fwrap: exclude cggrqf
# Fwrap: exclude cggsvd
# Fwrap: exclude cggsvp
# Fwrap: exclude cgtcon
# Fwrap: exclude cgtrfs
# Fwrap: exclude cgtsv
# Fwrap: exclude cgtsvx
# Fwrap: exclude cgttrf
# Fwrap: exclude cgttrs
# Fwrap: exclude cgtts2
# Fwrap: exclude chbev
# Fwrap: exclude chbgst
# Fwrap: exclude chbgv
# Fwrap: exclude chbgvd
# Fwrap: exclude chbgvx
# Fwrap: exclude chbtrd
# Fwrap: exclude checon
# Fwrap: exclude cheequb
# Fwrap: exclude cheevd
# Fwrap: exclude cheevx
# Fwrap: exclude chegs2
# Fwrap: exclude chegst
# Fwrap: exclude cherfs
# Fwrap: exclude cherfsx
# Fwrap: exclude chesv
# Fwrap: exclude chesvx
# Fwrap: exclude chesvxx
# Fwrap: exclude chetd2
# Fwrap: exclude chetf2
# Fwrap: exclude chetrd
# Fwrap: exclude chetrf
# Fwrap: exclude chetri
# Fwrap: exclude chetrs
# Fwrap: exclude chetrs2
# Fwrap: exclude chfrk
# Fwrap: exclude chgeqz
# Fwrap: exclude chla_transtype
# Fwrap: exclude chpcon
# Fwrap: exclude chpev
# Fwrap: exclude chpevd
# Fwrap: exclude chpevx
# Fwrap: exclude chpgst
# Fwrap: exclude chpgv
# Fwrap: exclude chpgvd
# Fwrap: exclude chpgvx
# Fwrap: exclude chprfs
# Fwrap: exclude chpsv
# Fwrap: exclude chpsvx
# Fwrap: exclude chptrd
# Fwrap: exclude chptrf
# Fwrap: exclude chptri
# Fwrap: exclude chptrs
# Fwrap: exclude chsein
# Fwrap: exclude chseqr
# Fwrap: exclude cla_gbamv
# Fwrap: exclude cla_gbrcond_c
# Fwrap: exclude cla_gbrcond_x
# Fwrap: exclude cla_gbrfsx_extended
# Fwrap: exclude cla_gbrpvgrw
# Fwrap: exclude cla_geamv
# Fwrap: exclude cla_gercond_c
# Fwrap: exclude cla_gercond_x
# Fwrap: exclude cla_gerfsx_extended
# Fwrap: exclude cla_heamv
# Fwrap: exclude cla_hercond_c
# Fwrap: exclude cla_hercond_x
# Fwrap: exclude cla_herfsx_extended
# Fwrap: exclude cla_herpvgrw
# Fwrap: exclude cla_lin_berr
# Fwrap: exclude cla_porcond_c
# Fwrap: exclude cla_porcond_x
# Fwrap: exclude cla_porfsx_extended
# Fwrap: exclude cla_porpvgrw
# Fwrap: exclude cla_rpvgrw
# Fwrap: exclude cla_syamv
# Fwrap: exclude cla_syrcond_c
# Fwrap: exclude cla_syrcond_x
# Fwrap: exclude cla_syrfsx_extended
# Fwrap: exclude cla_syrpvgrw
# Fwrap: exclude cla_wwaddw
# Fwrap: exclude clabrd
# Fwrap: exclude clacgv
# Fwrap: exclude clacn2
# Fwrap: exclude clacon
# Fwrap: exclude clacp2
# Fwrap: exclude clacpy
# Fwrap: exclude clacrm
# Fwrap: exclude clacrt
# Fwrap: exclude cladiv
# Fwrap: exclude claed0
# Fwrap: exclude claed7
# Fwrap: exclude claed8
# Fwrap: exclude claein
# Fwrap: exclude claesy
# Fwrap: exclude claev2
# Fwrap: exclude clag2z
# Fwrap: exclude clags2
# Fwrap: exclude clagtm
# Fwrap: exclude clahef
# Fwrap: exclude clahqr
# Fwrap: exclude clahr2
# Fwrap: exclude clahrd
# Fwrap: exclude claic1
# Fwrap: exclude clals0
# Fwrap: exclude clalsa
# Fwrap: exclude clalsd
# Fwrap: exclude clangb
# Fwrap: exclude clange
# Fwrap: exclude clangt
# Fwrap: exclude clanhb
# Fwrap: exclude clanhe
# Fwrap: exclude clanhf
# Fwrap: exclude clanhp
# Fwrap: exclude clanhs
# Fwrap: exclude clanht
# Fwrap: exclude clansb
# Fwrap: exclude clansp
# Fwrap: exclude clansy
# Fwrap: exclude clantb
# Fwrap: exclude clantp
# Fwrap: exclude clantr
# Fwrap: exclude clapll
# Fwrap: exclude clapmr
# Fwrap: exclude clapmt
# Fwrap: exclude claqgb
# Fwrap: exclude claqge
# Fwrap: exclude claqhb
# Fwrap: exclude claqhe
# Fwrap: exclude claqhp
# Fwrap: exclude claqp2
# Fwrap: exclude claqps
# Fwrap: exclude claqr0
# Fwrap: exclude claqr1
# Fwrap: exclude claqr2
# Fwrap: exclude claqr3
# Fwrap: exclude claqr4
# Fwrap: exclude claqr5
# Fwrap: exclude claqsb
# Fwrap: exclude claqsp
# Fwrap: exclude claqsy
# Fwrap: exclude clar1v
# Fwrap: exclude clar2v
# Fwrap: exclude clarcm
# Fwrap: exclude clarf
# Fwrap: exclude clarfb
# Fwrap: exclude clarfg
# Fwrap: exclude clarfgp
# Fwrap: exclude clarft
# Fwrap: exclude clarfx
# Fwrap: exclude clargv
# Fwrap: exclude clarnv
# Fwrap: exclude clarrv
# Fwrap: exclude clarscl2
# Fwrap: exclude clartg
# Fwrap: exclude clartv
# Fwrap: exclude clarz
# Fwrap: exclude clarzb
# Fwrap: exclude clarzt
# Fwrap: exclude clascl
# Fwrap: exclude clascl2
# Fwrap: exclude claset
# Fwrap: exclude clasr
# Fwrap: exclude classq
# Fwrap: exclude clasyf
# Fwrap: exclude clatbs
# Fwrap: exclude clatdf
# Fwrap: exclude clatps
# Fwrap: exclude clatrd
# Fwrap: exclude clatrs
# Fwrap: exclude clatrz
# Fwrap: exclude clatzm
# Fwrap: exclude clauu2
# Fwrap: exclude cpbcon
# Fwrap: exclude cpbequ
# Fwrap: exclude cpbrfs
# Fwrap: exclude cpbstf
# Fwrap: exclude cpbsvx
# Fwrap: exclude cpbtf2
# Fwrap: exclude cpftrf
# Fwrap: exclude cpftri
# Fwrap: exclude cpftrs
# Fwrap: exclude cpocon
# Fwrap: exclude cpoequ
# Fwrap: exclude cpoequb
# Fwrap: exclude cporfs
# Fwrap: exclude cporfsx
# Fwrap: exclude cposvx
# Fwrap: exclude cposvxx
# Fwrap: exclude cpotf2
# Fwrap: exclude cppcon
# Fwrap: exclude cppequ
# Fwrap: exclude cpprfs
# Fwrap: exclude cppsv
# Fwrap: exclude cppsvx
# Fwrap: exclude cpptrf
# Fwrap: exclude cpptri
# Fwrap: exclude cpptrs
# Fwrap: exclude cpstf2
# Fwrap: exclude cpstrf
# Fwrap: exclude cptcon
# Fwrap: exclude cpteqr
# Fwrap: exclude cptrfs
# Fwrap: exclude cptsv
# Fwrap: exclude cptsvx
# Fwrap: exclude cpttrf
# Fwrap: exclude cpttrs
# Fwrap: exclude cptts2
# Fwrap: exclude crot
# Fwrap: exclude cspcon
# Fwrap: exclude cspmv
# Fwrap: exclude cspr
# Fwrap: exclude csprfs
# Fwrap: exclude cspsv
# Fwrap: exclude cspsvx
# Fwrap: exclude csptrf
# Fwrap: exclude csptri
# Fwrap: exclude csptrs
# Fwrap: exclude csrscl
# Fwrap: exclude cstedc
# Fwrap: exclude cstegr
# Fwrap: exclude cstein
# Fwrap: exclude cstemr
# Fwrap: exclude csteqr
# Fwrap: exclude csycon
# Fwrap: exclude csyconv
# Fwrap: exclude csyequb
# Fwrap: exclude csymv
# Fwrap: exclude csyr
# Fwrap: exclude csyrfs
# Fwrap: exclude csyrfsx
# Fwrap: exclude csysv
# Fwrap: exclude csysvx
# Fwrap: exclude csysvxx
# Fwrap: exclude csyswapr
# Fwrap: exclude csytf2
# Fwrap: exclude csytrf
# Fwrap: exclude csytri
# Fwrap: exclude csytri2
# Fwrap: exclude csytri2x
# Fwrap: exclude csytrs
# Fwrap: exclude csytrs2
# Fwrap: exclude ctbcon
# Fwrap: exclude ctbrfs
# Fwrap: exclude ctbtrs
# Fwrap: exclude ctfsm
# Fwrap: exclude ctftri
# Fwrap: exclude ctfttp
# Fwrap: exclude ctfttr
# Fwrap: exclude ctgevc
# Fwrap: exclude ctgex2
# Fwrap: exclude ctgexc
# Fwrap: exclude ctgsen
# Fwrap: exclude ctgsja
# Fwrap: exclude ctgsna
# Fwrap: exclude ctgsy2
# Fwrap: exclude ctgsyl
# Fwrap: exclude ctpcon
# Fwrap: exclude ctprfs
# Fwrap: exclude ctptri
# Fwrap: exclude ctptrs
# Fwrap: exclude ctpttf
# Fwrap: exclude ctpttr
# Fwrap: exclude ctrcon
# Fwrap: exclude ctrevc
# Fwrap: exclude ctrexc
# Fwrap: exclude ctrrfs
# Fwrap: exclude ctrsen
# Fwrap: exclude ctrsna
# Fwrap: exclude ctrsyl
# Fwrap: exclude ctrti2
# Fwrap: exclude ctrttf
# Fwrap: exclude ctrttp
# Fwrap: exclude ctzrqf
# Fwrap: exclude ctzrzf
# Fwrap: exclude cunbdb
# Fwrap: exclude cuncsd
# Fwrap: exclude cung2l
# Fwrap: exclude cung2r
# Fwrap: exclude cungbr
# Fwrap: exclude cunghr
# Fwrap: exclude cungl2
# Fwrap: exclude cunglq
# Fwrap: exclude cungql
# Fwrap: exclude cungr2
# Fwrap: exclude cungrq
# Fwrap: exclude cungtr
# Fwrap: exclude cunm2l
# Fwrap: exclude cunm2r
# Fwrap: exclude cunmbr
# Fwrap: exclude cunmhr
# Fwrap: exclude cunml2
# Fwrap: exclude cunmlq
# Fwrap: exclude cunmql
# Fwrap: exclude cunmqr
# Fwrap: exclude cunmr2
# Fwrap: exclude cunmr3
# Fwrap: exclude cunmrq
# Fwrap: exclude cunmrz
# Fwrap: exclude cunmtr
# Fwrap: exclude cupgtr
# Fwrap: exclude cupmtr
# Fwrap: exclude dbbcsd
# Fwrap: exclude dbdsdc
# Fwrap: exclude dbdsqr
# Fwrap: exclude ddisna
# Fwrap: exclude dgbbrd
# Fwrap: exclude dgbcon
# Fwrap: exclude dgbequ
# Fwrap: exclude dgbequb
# Fwrap: exclude dgbrfs
# Fwrap: exclude dgbrfsx
# Fwrap: exclude dgbsvx
# Fwrap: exclude dgbsvxx
# Fwrap: exclude dgbtf2
# Fwrap: exclude dgebak
# Fwrap: exclude dgebd2
# Fwrap: exclude dgebrd
# Fwrap: exclude dgecon
# Fwrap: exclude dgeequ
# Fwrap: exclude dgeequb
# Fwrap: exclude dgeesx
# Fwrap: exclude dgeevx
# Fwrap: exclude dgegs
# Fwrap: exclude dgehd2
# Fwrap: exclude dgejsv
# Fwrap: exclude dgelq2
# Fwrap: exclude dgelqf
# Fwrap: exclude dgels
# Fwrap: exclude dgelsd
# Fwrap: exclude dgelsx
# Fwrap: exclude dgelsy
# Fwrap: exclude dgeql2
# Fwrap: exclude dgeqlf
# Fwrap: exclude dgeqp3
# Fwrap: exclude dgeqpf
# Fwrap: exclude dgeqr2
# Fwrap: exclude dgeqr2p
# Fwrap: exclude dgeqrfp
# Fwrap: exclude dgerfs
# Fwrap: exclude dgerfsx
# Fwrap: exclude dgerq2
# Fwrap: exclude dgesc2
# Fwrap: exclude dgesvd
# Fwrap: exclude dgesvj
# Fwrap: exclude dgesvx
# Fwrap: exclude dgesvxx
# Fwrap: exclude dgetc2
# Fwrap: exclude dgetf2
# Fwrap: exclude dggbak
# Fwrap: exclude dggbal
# Fwrap: exclude dgges
# Fwrap: exclude dggesx
# Fwrap: exclude dggevx
# Fwrap: exclude dggglm
# Fwrap: exclude dgghrd
# Fwrap: exclude dgglse
# Fwrap: exclude dggqrf
# Fwrap: exclude dggrqf
# Fwrap: exclude dggsvd
# Fwrap: exclude dggsvp
# Fwrap: exclude dgsvj0
# Fwrap: exclude dgsvj1
# Fwrap: exclude dgtcon
# Fwrap: exclude dgtrfs
# Fwrap: exclude dgtsv
# Fwrap: exclude dgtsvx
# Fwrap: exclude dgttrf
# Fwrap: exclude dgttrs
# Fwrap: exclude dgtts2
# Fwrap: exclude dhgeqz
# Fwrap: exclude dhsein
# Fwrap: exclude dhseqr
# Fwrap: exclude disnan
# Fwrap: exclude dla_gbamv
# Fwrap: exclude dla_gbrcond
# Fwrap: exclude dla_gbrfsx_extended
# Fwrap: exclude dla_gbrpvgrw
# Fwrap: exclude dla_geamv
# Fwrap: exclude dla_gercond
# Fwrap: exclude dla_gerfsx_extended
# Fwrap: exclude dla_lin_berr
# Fwrap: exclude dla_porcond
# Fwrap: exclude dla_porfsx_extended
# Fwrap: exclude dla_porpvgrw
# Fwrap: exclude dla_rpvgrw
# Fwrap: exclude dla_syamv
# Fwrap: exclude dla_syrcond
# Fwrap: exclude dla_syrfsx_extended
# Fwrap: exclude dla_syrpvgrw
# Fwrap: exclude dla_wwaddw
# Fwrap: exclude dlabad
# Fwrap: exclude dlabrd
# Fwrap: exclude dlacn2
# Fwrap: exclude dlacon
# Fwrap: exclude dlacpy
# Fwrap: exclude dladiv
# Fwrap: exclude dlae2
# Fwrap: exclude dlaebz
# Fwrap: exclude dlaed0
# Fwrap: exclude dlaed1
# Fwrap: exclude dlaed2
# Fwrap: exclude dlaed3
# Fwrap: exclude dlaed4
# Fwrap: exclude dlaed5
# Fwrap: exclude dlaed6
# Fwrap: exclude dlaed7
# Fwrap: exclude dlaed8
# Fwrap: exclude dlaed9
# Fwrap: exclude dlaeda
# Fwrap: exclude dlaein
# Fwrap: exclude dlaev2
# Fwrap: exclude dlaexc
# Fwrap: exclude dlag2
# Fwrap: exclude dlag2s
# Fwrap: exclude dlags2
# Fwrap: exclude dlagtf
# Fwrap: exclude dlagtm
# Fwrap: exclude dlagts
# Fwrap: exclude dlagv2
# Fwrap: exclude dlahqr
# Fwrap: exclude dlahr2
# Fwrap: exclude dlahrd
# Fwrap: exclude dlaic1
# Fwrap: exclude dlaisnan
# Fwrap: exclude dlaln2
# Fwrap: exclude dlals0
# Fwrap: exclude dlalsa
# Fwrap: exclude dlalsd
# Fwrap: exclude dlamrg
# Fwrap: exclude dlaneg
# Fwrap: exclude dlangb
# Fwrap: exclude dlange
# Fwrap: exclude dlangt
# Fwrap: exclude dlanhs
# Fwrap: exclude dlansb
# Fwrap: exclude dlansf
# Fwrap: exclude dlansp
# Fwrap: exclude dlanst
# Fwrap: exclude dlansy
# Fwrap: exclude dlantb
# Fwrap: exclude dlantp
# Fwrap: exclude dlantr
# Fwrap: exclude dlanv2
# Fwrap: exclude dlapll
# Fwrap: exclude dlapmr
# Fwrap: exclude dlapmt
# Fwrap: exclude dlapy2
# Fwrap: exclude dlapy3
# Fwrap: exclude dlaqgb
# Fwrap: exclude dlaqge
# Fwrap: exclude dlaqp2
# Fwrap: exclude dlaqps
# Fwrap: exclude dlaqr0
# Fwrap: exclude dlaqr1
# Fwrap: exclude dlaqr2
# Fwrap: exclude dlaqr3
# Fwrap: exclude dlaqr4
# Fwrap: exclude dlaqr5
# Fwrap: exclude dlaqsb
# Fwrap: exclude dlaqsp
# Fwrap: exclude dlaqsy
# Fwrap: exclude dlaqtr
# Fwrap: exclude dlar1v
# Fwrap: exclude dlar2v
# Fwrap: exclude dlarf
# Fwrap: exclude dlarfb
# Fwrap: exclude dlarfg
# Fwrap: exclude dlarfgp
# Fwrap: exclude dlarft
# Fwrap: exclude dlarfx
# Fwrap: exclude dlargv
# Fwrap: exclude dlarnv
# Fwrap: exclude dlarra
# Fwrap: exclude dlarrb
# Fwrap: exclude dlarrc
# Fwrap: exclude dlarrd
# Fwrap: exclude dlarre
# Fwrap: exclude dlarrf
# Fwrap: exclude dlarrj
# Fwrap: exclude dlarrk
# Fwrap: exclude dlarrr
# Fwrap: exclude dlarrv
# Fwrap: exclude dlarscl2
# Fwrap: exclude dlartg
# Fwrap: exclude dlartgp
# Fwrap: exclude dlartgs
# Fwrap: exclude dlartv
# Fwrap: exclude dlaruv
# Fwrap: exclude dlarz
# Fwrap: exclude dlarzb
# Fwrap: exclude dlarzt
# Fwrap: exclude dlas2
# Fwrap: exclude dlascl
# Fwrap: exclude dlascl2
# Fwrap: exclude dlasd0
# Fwrap: exclude dlasd1
# Fwrap: exclude dlasd2
# Fwrap: exclude dlasd3
# Fwrap: exclude dlasd4
# Fwrap: exclude dlasd5
# Fwrap: exclude dlasd6
# Fwrap: exclude dlasd7
# Fwrap: exclude dlasd8
# Fwrap: exclude dlasda
# Fwrap: exclude dlasdq
# Fwrap: exclude dlasdt
# Fwrap: exclude dlaset
# Fwrap: exclude dlasq1
# Fwrap: exclude dlasq2
# Fwrap: exclude dlasq3
# Fwrap: exclude dlasq4
# Fwrap: exclude dlasq5
# Fwrap: exclude dlasq6
# Fwrap: exclude dlasr
# Fwrap: exclude dlasrt
# Fwrap: exclude dlassq
# Fwrap: exclude dlasv2
# Fwrap: exclude dlasy2
# Fwrap: exclude dlasyf
# Fwrap: exclude dlat2s
# Fwrap: exclude dlatbs
# Fwrap: exclude dlatdf
# Fwrap: exclude dlatps
# Fwrap: exclude dlatrd
# Fwrap: exclude dlatrs
# Fwrap: exclude dlatrz
# Fwrap: exclude dlatzm
# Fwrap: exclude dlauu2
# Fwrap: exclude dopgtr
# Fwrap: exclude dopmtr
# Fwrap: exclude dorbdb
# Fwrap: exclude dorcsd
# Fwrap: exclude dorg2l
# Fwrap: exclude dorg2r
# Fwrap: exclude dorgbr
# Fwrap: exclude dorghr
# Fwrap: exclude dorgl2
# Fwrap: exclude dorglq
# Fwrap: exclude dorgql
# Fwrap: exclude dorgr2
# Fwrap: exclude dorgrq
# Fwrap: exclude dorgtr
# Fwrap: exclude dorm2l
# Fwrap: exclude dorm2r
# Fwrap: exclude dormbr
# Fwrap: exclude dormhr
# Fwrap: exclude dorml2
# Fwrap: exclude dormlq
# Fwrap: exclude dormql
# Fwrap: exclude dormqr
# Fwrap: exclude dormr2
# Fwrap: exclude dormr3
# Fwrap: exclude dormrq
# Fwrap: exclude dormrz
# Fwrap: exclude dormtr
# Fwrap: exclude dpbcon
# Fwrap: exclude dpbequ
# Fwrap: exclude dpbrfs
# Fwrap: exclude dpbstf
# Fwrap: exclude dpbsvx
# Fwrap: exclude dpbtf2
# Fwrap: exclude dpftrf
# Fwrap: exclude dpftri
# Fwrap: exclude dpftrs
# Fwrap: exclude dpocon
# Fwrap: exclude dpoequ
# Fwrap: exclude dpoequb
# Fwrap: exclude dporfs
# Fwrap: exclude dporfsx
# Fwrap: exclude dposvx
# Fwrap: exclude dposvxx
# Fwrap: exclude dpotf2
# Fwrap: exclude dppcon
# Fwrap: exclude dppequ
# Fwrap: exclude dpprfs
# Fwrap: exclude dppsv
# Fwrap: exclude dppsvx
# Fwrap: exclude dpptrf
# Fwrap: exclude dpptri
# Fwrap: exclude dpptrs
# Fwrap: exclude dpstf2
# Fwrap: exclude dpstrf
# Fwrap: exclude dptcon
# Fwrap: exclude dpteqr
# Fwrap: exclude dptrfs
# Fwrap: exclude dptsv
# Fwrap: exclude dptsvx
# Fwrap: exclude dpttrf
# Fwrap: exclude dpttrs
# Fwrap: exclude dptts2
# Fwrap: exclude drscl
# Fwrap: exclude dsbgst
# Fwrap: exclude dsbgv
# Fwrap: exclude dsbgvd
# Fwrap: exclude dsbgvx
# Fwrap: exclude dsbtrd
# Fwrap: exclude dsfrk
# Fwrap: exclude dsgesv
# Fwrap: exclude dspcon
# Fwrap: exclude dspev
# Fwrap: exclude dspevd
# Fwrap: exclude dspevx
# Fwrap: exclude dspgst
# Fwrap: exclude dspgv
# Fwrap: exclude dspgvd
# Fwrap: exclude dspgvx
# Fwrap: exclude dsposv
# Fwrap: exclude dsprfs
# Fwrap: exclude dspsv
# Fwrap: exclude dspsvx
# Fwrap: exclude dsptrd
# Fwrap: exclude dsptrf
# Fwrap: exclude dsptri
# Fwrap: exclude dsptrs
# Fwrap: exclude dstebz
# Fwrap: exclude dstedc
# Fwrap: exclude dstegr
# Fwrap: exclude dstein
# Fwrap: exclude dstemr
# Fwrap: exclude dsteqr
# Fwrap: exclude dsterf
# Fwrap: exclude dstev
# Fwrap: exclude dstevd
# Fwrap: exclude dstevr
# Fwrap: exclude dstevx
# Fwrap: exclude dsycon
# Fwrap: exclude dsyconv
# Fwrap: exclude dsyequb
# Fwrap: exclude dsyevd
# Fwrap: exclude dsyevx
# Fwrap: exclude dsygs2
# Fwrap: exclude dsygst
# Fwrap: exclude dsyrfs
# Fwrap: exclude dsyrfsx
# Fwrap: exclude dsysv
# Fwrap: exclude dsysvx
# Fwrap: exclude dsysvxx
# Fwrap: exclude dsyswapr
# Fwrap: exclude dsytd2
# Fwrap: exclude dsytf2
# Fwrap: exclude dsytrd
# Fwrap: exclude dsytrf
# Fwrap: exclude dsytri
# Fwrap: exclude dsytri2
# Fwrap: exclude dsytri2x
# Fwrap: exclude dsytrs
# Fwrap: exclude dsytrs2
# Fwrap: exclude dtbcon
# Fwrap: exclude dtbrfs
# Fwrap: exclude dtbtrs
# Fwrap: exclude dtfsm
# Fwrap: exclude dtftri
# Fwrap: exclude dtfttp
# Fwrap: exclude dtfttr
# Fwrap: exclude dtgevc
# Fwrap: exclude dtgex2
# Fwrap: exclude dtgexc
# Fwrap: exclude dtgsen
# Fwrap: exclude dtgsja
# Fwrap: exclude dtgsna
# Fwrap: exclude dtgsy2
# Fwrap: exclude dtgsyl
# Fwrap: exclude dtpcon
# Fwrap: exclude dtprfs
# Fwrap: exclude dtptri
# Fwrap: exclude dtptrs
# Fwrap: exclude dtpttf
# Fwrap: exclude dtpttr
# Fwrap: exclude dtrcon
# Fwrap: exclude dtrevc
# Fwrap: exclude dtrexc
# Fwrap: exclude dtrrfs
# Fwrap: exclude dtrsen
# Fwrap: exclude dtrsna
# Fwrap: exclude dtrsyl
# Fwrap: exclude dtrti2
# Fwrap: exclude dtrttf
# Fwrap: exclude dtrttp
# Fwrap: exclude dtzrqf
# Fwrap: exclude dtzrzf
# Fwrap: exclude dzsum1
# Fwrap: exclude icmax1
# Fwrap: exclude ieeeck
# Fwrap: exclude ilaclc
# Fwrap: exclude ilaclr
# Fwrap: exclude iladiag
# Fwrap: exclude iladlc
# Fwrap: exclude iladlr
# Fwrap: exclude ilaenv
# Fwrap: exclude ilaprec
# Fwrap: exclude ilaslc
# Fwrap: exclude ilaslr
# Fwrap: exclude ilatrans
# Fwrap: exclude ilauplo
# Fwrap: exclude ilaver
# Fwrap: exclude ilazlc
# Fwrap: exclude ilazlr
# Fwrap: exclude iparmq
# Fwrap: exclude izmax1
# Fwrap: exclude lsamen
# Fwrap: exclude sbbcsd
# Fwrap: exclude sbdsdc
# Fwrap: exclude sbdsqr
# Fwrap: exclude scsum1
# Fwrap: exclude sdisna
# Fwrap: exclude sgbbrd
# Fwrap: exclude sgbcon
# Fwrap: exclude sgbequ
# Fwrap: exclude sgbequb
# Fwrap: exclude sgbrfs
# Fwrap: exclude sgbrfsx
# Fwrap: exclude sgbsvx
# Fwrap: exclude sgbsvxx
# Fwrap: exclude sgbtf2
# Fwrap: exclude sgebak
# Fwrap: exclude sgebd2
# Fwrap: exclude sgebrd
# Fwrap: exclude sgecon
# Fwrap: exclude sgeequ
# Fwrap: exclude sgeequb
# Fwrap: exclude sgeesx
# Fwrap: exclude sgeevx
# Fwrap: exclude sgegs
# Fwrap: exclude sgehd2
# Fwrap: exclude sgejsv
# Fwrap: exclude sgelq2
# Fwrap: exclude sgelqf
# Fwrap: exclude sgels
# Fwrap: exclude sgelsd
# Fwrap: exclude sgelsx
# Fwrap: exclude sgelsy
# Fwrap: exclude sgeql2
# Fwrap: exclude sgeqlf
# Fwrap: exclude sgeqp3
# Fwrap: exclude sgeqpf
# Fwrap: exclude sgeqr2
# Fwrap: exclude sgeqr2p
# Fwrap: exclude sgeqrfp
# Fwrap: exclude sgerfs
# Fwrap: exclude sgerfsx
# Fwrap: exclude sgerq2
# Fwrap: exclude sgesc2
# Fwrap: exclude sgesvd
# Fwrap: exclude sgesvj
# Fwrap: exclude sgesvx
# Fwrap: exclude sgesvxx
# Fwrap: exclude sgetc2
# Fwrap: exclude sgetf2
# Fwrap: exclude sggbak
# Fwrap: exclude sggbal
# Fwrap: exclude sgges
# Fwrap: exclude sggesx
# Fwrap: exclude sggevx
# Fwrap: exclude sggglm
# Fwrap: exclude sgghrd
# Fwrap: exclude sgglse
# Fwrap: exclude sggqrf
# Fwrap: exclude sggrqf
# Fwrap: exclude sggsvd
# Fwrap: exclude sggsvp
# Fwrap: exclude sgsvj0
# Fwrap: exclude sgsvj1
# Fwrap: exclude sgtcon
# Fwrap: exclude sgtrfs
# Fwrap: exclude sgtsv
# Fwrap: exclude sgtsvx
# Fwrap: exclude sgttrf
# Fwrap: exclude sgttrs
# Fwrap: exclude sgtts2
# Fwrap: exclude shgeqz
# Fwrap: exclude shsein
# Fwrap: exclude shseqr
# Fwrap: exclude sisnan
# Fwrap: exclude sla_gbamv
# Fwrap: exclude sla_gbrcond
# Fwrap: exclude sla_gbrfsx_extended
# Fwrap: exclude sla_gbrpvgrw
# Fwrap: exclude sla_geamv
# Fwrap: exclude sla_gercond
# Fwrap: exclude sla_gerfsx_extended
# Fwrap: exclude sla_lin_berr
# Fwrap: exclude sla_porcond
# Fwrap: exclude sla_porfsx_extended
# Fwrap: exclude sla_porpvgrw
# Fwrap: exclude sla_rpvgrw
# Fwrap: exclude sla_syamv
# Fwrap: exclude sla_syrcond
# Fwrap: exclude sla_syrfsx_extended
# Fwrap: exclude sla_syrpvgrw
# Fwrap: exclude sla_wwaddw
# Fwrap: exclude slabad
# Fwrap: exclude slabrd
# Fwrap: exclude slacn2
# Fwrap: exclude slacon
# Fwrap: exclude slacpy
# Fwrap: exclude sladiv
# Fwrap: exclude slae2
# Fwrap: exclude slaebz
# Fwrap: exclude slaed0
# Fwrap: exclude slaed1
# Fwrap: exclude slaed2
# Fwrap: exclude slaed3
# Fwrap: exclude slaed4
# Fwrap: exclude slaed5
# Fwrap: exclude slaed6
# Fwrap: exclude slaed7
# Fwrap: exclude slaed8
# Fwrap: exclude slaed9
# Fwrap: exclude slaeda
# Fwrap: exclude slaein
# Fwrap: exclude slaev2
# Fwrap: exclude slaexc
# Fwrap: exclude slag2
# Fwrap: exclude slag2d
# Fwrap: exclude slags2
# Fwrap: exclude slagtf
# Fwrap: exclude slagtm
# Fwrap: exclude slagts
# Fwrap: exclude slagv2
# Fwrap: exclude slahqr
# Fwrap: exclude slahr2
# Fwrap: exclude slahrd
# Fwrap: exclude slaic1
# Fwrap: exclude slaisnan
# Fwrap: exclude slaln2
# Fwrap: exclude slals0
# Fwrap: exclude slalsa
# Fwrap: exclude slalsd
# Fwrap: exclude slamrg
# Fwrap: exclude slaneg
# Fwrap: exclude slangb
# Fwrap: exclude slange
# Fwrap: exclude slangt
# Fwrap: exclude slanhs
# Fwrap: exclude slansb
# Fwrap: exclude slansf
# Fwrap: exclude slansp
# Fwrap: exclude slanst
# Fwrap: exclude slansy
# Fwrap: exclude slantb
# Fwrap: exclude slantp
# Fwrap: exclude slantr
# Fwrap: exclude slanv2
# Fwrap: exclude slapll
# Fwrap: exclude slapmr
# Fwrap: exclude slapmt
# Fwrap: exclude slapy2
# Fwrap: exclude slapy3
# Fwrap: exclude slaqgb
# Fwrap: exclude slaqge
# Fwrap: exclude slaqp2
# Fwrap: exclude slaqps
# Fwrap: exclude slaqr0
# Fwrap: exclude slaqr1
# Fwrap: exclude slaqr2
# Fwrap: exclude slaqr3
# Fwrap: exclude slaqr4
# Fwrap: exclude slaqr5
# Fwrap: exclude slaqsb
# Fwrap: exclude slaqsp
# Fwrap: exclude slaqsy
# Fwrap: exclude slaqtr
# Fwrap: exclude slar1v
# Fwrap: exclude slar2v
# Fwrap: exclude slarf
# Fwrap: exclude slarfb
# Fwrap: exclude slarfg
# Fwrap: exclude slarfgp
# Fwrap: exclude slarft
# Fwrap: exclude slarfx
# Fwrap: exclude slargv
# Fwrap: exclude slarnv
# Fwrap: exclude slarra
# Fwrap: exclude slarrb
# Fwrap: exclude slarrc
# Fwrap: exclude slarrd
# Fwrap: exclude slarre
# Fwrap: exclude slarrf
# Fwrap: exclude slarrj
# Fwrap: exclude slarrk
# Fwrap: exclude slarrr
# Fwrap: exclude slarrv
# Fwrap: exclude slarscl2
# Fwrap: exclude slartg
# Fwrap: exclude slartgp
# Fwrap: exclude slartgs
# Fwrap: exclude slartv
# Fwrap: exclude slaruv
# Fwrap: exclude slarz
# Fwrap: exclude slarzb
# Fwrap: exclude slarzt
# Fwrap: exclude slas2
# Fwrap: exclude slascl
# Fwrap: exclude slascl2
# Fwrap: exclude slasd0
# Fwrap: exclude slasd1
# Fwrap: exclude slasd2
# Fwrap: exclude slasd3
# Fwrap: exclude slasd4
# Fwrap: exclude slasd5
# Fwrap: exclude slasd6
# Fwrap: exclude slasd7
# Fwrap: exclude slasd8
# Fwrap: exclude slasda
# Fwrap: exclude slasdq
# Fwrap: exclude slasdt
# Fwrap: exclude slaset
# Fwrap: exclude slasq1
# Fwrap: exclude slasq2
# Fwrap: exclude slasq3
# Fwrap: exclude slasq4
# Fwrap: exclude slasq5
# Fwrap: exclude slasq6
# Fwrap: exclude slasr
# Fwrap: exclude slasrt
# Fwrap: exclude slassq
# Fwrap: exclude slasv2
# Fwrap: exclude slasy2
# Fwrap: exclude slasyf
# Fwrap: exclude slatbs
# Fwrap: exclude slatdf
# Fwrap: exclude slatps
# Fwrap: exclude slatrd
# Fwrap: exclude slatrs
# Fwrap: exclude slatrz
# Fwrap: exclude slatzm
# Fwrap: exclude slauu2
# Fwrap: exclude sopgtr
# Fwrap: exclude sopmtr
# Fwrap: exclude sorbdb
# Fwrap: exclude sorcsd
# Fwrap: exclude sorg2l
# Fwrap: exclude sorg2r
# Fwrap: exclude sorgbr
# Fwrap: exclude sorghr
# Fwrap: exclude sorgl2
# Fwrap: exclude sorglq
# Fwrap: exclude sorgql
# Fwrap: exclude sorgr2
# Fwrap: exclude sorgrq
# Fwrap: exclude sorgtr
# Fwrap: exclude sorm2l
# Fwrap: exclude sorm2r
# Fwrap: exclude sormbr
# Fwrap: exclude sormhr
# Fwrap: exclude sorml2
# Fwrap: exclude sormlq
# Fwrap: exclude sormql
# Fwrap: exclude sormqr
# Fwrap: exclude sormr2
# Fwrap: exclude sormr3
# Fwrap: exclude sormrq
# Fwrap: exclude sormrz
# Fwrap: exclude sormtr
# Fwrap: exclude spbcon
# Fwrap: exclude spbequ
# Fwrap: exclude spbrfs
# Fwrap: exclude spbstf
# Fwrap: exclude spbsvx
# Fwrap: exclude spbtf2
# Fwrap: exclude spftrf
# Fwrap: exclude spftri
# Fwrap: exclude spftrs
# Fwrap: exclude spocon
# Fwrap: exclude spoequ
# Fwrap: exclude spoequb
# Fwrap: exclude sporfs
# Fwrap: exclude sporfsx
# Fwrap: exclude sposvx
# Fwrap: exclude sposvxx
# Fwrap: exclude spotf2
# Fwrap: exclude sppcon
# Fwrap: exclude sppequ
# Fwrap: exclude spprfs
# Fwrap: exclude sppsv
# Fwrap: exclude sppsvx
# Fwrap: exclude spptrf
# Fwrap: exclude spptri
# Fwrap: exclude spptrs
# Fwrap: exclude spstf2
# Fwrap: exclude spstrf
# Fwrap: exclude sptcon
# Fwrap: exclude spteqr
# Fwrap: exclude sptrfs
# Fwrap: exclude sptsv
# Fwrap: exclude sptsvx
# Fwrap: exclude spttrf
# Fwrap: exclude spttrs
# Fwrap: exclude sptts2
# Fwrap: exclude srscl
# Fwrap: exclude ssbgst
# Fwrap: exclude ssbgv
# Fwrap: exclude ssbgvd
# Fwrap: exclude ssbgvx
# Fwrap: exclude ssbtrd
# Fwrap: exclude ssfrk
# Fwrap: exclude sspcon
# Fwrap: exclude sspev
# Fwrap: exclude sspevd
# Fwrap: exclude sspevx
# Fwrap: exclude sspgst
# Fwrap: exclude sspgv
# Fwrap: exclude sspgvd
# Fwrap: exclude sspgvx
# Fwrap: exclude ssprfs
# Fwrap: exclude sspsv
# Fwrap: exclude sspsvx
# Fwrap: exclude ssptrd
# Fwrap: exclude ssptrf
# Fwrap: exclude ssptri
# Fwrap: exclude ssptrs
# Fwrap: exclude sstebz
# Fwrap: exclude sstedc
# Fwrap: exclude sstegr
# Fwrap: exclude sstein
# Fwrap: exclude sstemr
# Fwrap: exclude ssteqr
# Fwrap: exclude ssterf
# Fwrap: exclude sstev
# Fwrap: exclude sstevd
# Fwrap: exclude sstevr
# Fwrap: exclude sstevx
# Fwrap: exclude ssycon
# Fwrap: exclude ssyconv
# Fwrap: exclude ssyequb
# Fwrap: exclude ssyevd
# Fwrap: exclude ssyevx
# Fwrap: exclude ssygs2
# Fwrap: exclude ssygst
# Fwrap: exclude ssyrfs
# Fwrap: exclude ssyrfsx
# Fwrap: exclude ssysv
# Fwrap: exclude ssysvx
# Fwrap: exclude ssysvxx
# Fwrap: exclude ssyswapr
# Fwrap: exclude ssytd2
# Fwrap: exclude ssytf2
# Fwrap: exclude ssytrd
# Fwrap: exclude ssytrf
# Fwrap: exclude ssytri
# Fwrap: exclude ssytri2
# Fwrap: exclude ssytri2x
# Fwrap: exclude ssytrs
# Fwrap: exclude ssytrs2
# Fwrap: exclude stbcon
# Fwrap: exclude stbrfs
# Fwrap: exclude stbtrs
# Fwrap: exclude stfsm
# Fwrap: exclude stftri
# Fwrap: exclude stfttp
# Fwrap: exclude stfttr
# Fwrap: exclude stgevc
# Fwrap: exclude stgex2
# Fwrap: exclude stgexc
# Fwrap: exclude stgsen
# Fwrap: exclude stgsja
# Fwrap: exclude stgsna
# Fwrap: exclude stgsy2
# Fwrap: exclude stgsyl
# Fwrap: exclude stpcon
# Fwrap: exclude stprfs
# Fwrap: exclude stptri
# Fwrap: exclude stptrs
# Fwrap: exclude stpttf
# Fwrap: exclude stpttr
# Fwrap: exclude strcon
# Fwrap: exclude strevc
# Fwrap: exclude strexc
# Fwrap: exclude strrfs
# Fwrap: exclude strsen
# Fwrap: exclude strsna
# Fwrap: exclude strsyl
# Fwrap: exclude strti2
# Fwrap: exclude strttf
# Fwrap: exclude strttp
# Fwrap: exclude stzrqf
# Fwrap: exclude stzrzf
# Fwrap: exclude zbbcsd
# Fwrap: exclude zbdsqr
# Fwrap: exclude zcgesv
# Fwrap: exclude zcposv
# Fwrap: exclude zdrscl
# Fwrap: exclude zgbbrd
# Fwrap: exclude zgbcon
# Fwrap: exclude zgbequ
# Fwrap: exclude zgbequb
# Fwrap: exclude zgbrfs
# Fwrap: exclude zgbrfsx
# Fwrap: exclude zgbsvx
# Fwrap: exclude zgbsvxx
# Fwrap: exclude zgbtf2
# Fwrap: exclude zgebak
# Fwrap: exclude zgebd2
# Fwrap: exclude zgebrd
# Fwrap: exclude zgecon
# Fwrap: exclude zgeequ
# Fwrap: exclude zgeequb
# Fwrap: exclude zgeesx
# Fwrap: exclude zgeevx
# Fwrap: exclude zgegs
# Fwrap: exclude zgehd2
# Fwrap: exclude zgelq2
# Fwrap: exclude zgelqf
# Fwrap: exclude zgels
# Fwrap: exclude zgelsd
# Fwrap: exclude zgelsx
# Fwrap: exclude zgelsy
# Fwrap: exclude zgeql2
# Fwrap: exclude zgeqlf
# Fwrap: exclude zgeqp3
# Fwrap: exclude zgeqpf
# Fwrap: exclude zgeqr2
# Fwrap: exclude zgeqr2p
# Fwrap: exclude zgeqrfp
# Fwrap: exclude zgerfs
# Fwrap: exclude zgerfsx
# Fwrap: exclude zgerq2
# Fwrap: exclude zgesc2
# Fwrap: exclude zgesvd
# Fwrap: exclude zgesvx
# Fwrap: exclude zgesvxx
# Fwrap: exclude zgetc2
# Fwrap: exclude zgetf2
# Fwrap: exclude zggbak
# Fwrap: exclude zggbal
# Fwrap: exclude zgges
# Fwrap: exclude zggesx
# Fwrap: exclude zggevx
# Fwrap: exclude zggglm
# Fwrap: exclude zgghrd
# Fwrap: exclude zgglse
# Fwrap: exclude zggqrf
# Fwrap: exclude zggrqf
# Fwrap: exclude zggsvd
# Fwrap: exclude zggsvp
# Fwrap: exclude zgtcon
# Fwrap: exclude zgtrfs
# Fwrap: exclude zgtsv
# Fwrap: exclude zgtsvx
# Fwrap: exclude zgttrf
# Fwrap: exclude zgttrs
# Fwrap: exclude zgtts2
# Fwrap: exclude zhbev
# Fwrap: exclude zhbgst
# Fwrap: exclude zhbgv
# Fwrap: exclude zhbgvd
# Fwrap: exclude zhbgvx
# Fwrap: exclude zhbtrd
# Fwrap: exclude zhecon
# Fwrap: exclude zheequb
# Fwrap: exclude zheevd
# Fwrap: exclude zheevx
# Fwrap: exclude zhegs2
# Fwrap: exclude zhegst
# Fwrap: exclude zherfs
# Fwrap: exclude zherfsx
# Fwrap: exclude zhesv
# Fwrap: exclude zhesvx
# Fwrap: exclude zhesvxx
# Fwrap: exclude zhetd2
# Fwrap: exclude zhetf2
# Fwrap: exclude zhetrd
# Fwrap: exclude zhetrf
# Fwrap: exclude zhetri
# Fwrap: exclude zhetrs
# Fwrap: exclude zhetrs2
# Fwrap: exclude zhfrk
# Fwrap: exclude zhgeqz
# Fwrap: exclude zhpcon
# Fwrap: exclude zhpev
# Fwrap: exclude zhpevd
# Fwrap: exclude zhpevx
# Fwrap: exclude zhpgst
# Fwrap: exclude zhpgv
# Fwrap: exclude zhpgvd
# Fwrap: exclude zhpgvx
# Fwrap: exclude zhprfs
# Fwrap: exclude zhpsv
# Fwrap: exclude zhpsvx
# Fwrap: exclude zhptrd
# Fwrap: exclude zhptrf
# Fwrap: exclude zhptri
# Fwrap: exclude zhptrs
# Fwrap: exclude zhsein
# Fwrap: exclude zhseqr
# Fwrap: exclude zla_gbamv
# Fwrap: exclude zla_gbrcond_c
# Fwrap: exclude zla_gbrcond_x
# Fwrap: exclude zla_gbrfsx_extended
# Fwrap: exclude zla_gbrpvgrw
# Fwrap: exclude zla_geamv
# Fwrap: exclude zla_gercond_c
# Fwrap: exclude zla_gercond_x
# Fwrap: exclude zla_gerfsx_extended
# Fwrap: exclude zla_heamv
# Fwrap: exclude zla_hercond_c
# Fwrap: exclude zla_hercond_x
# Fwrap: exclude zla_herfsx_extended
# Fwrap: exclude zla_herpvgrw
# Fwrap: exclude zla_lin_berr
# Fwrap: exclude zla_porcond_c
# Fwrap: exclude zla_porcond_x
# Fwrap: exclude zla_porfsx_extended
# Fwrap: exclude zla_porpvgrw
# Fwrap: exclude zla_rpvgrw
# Fwrap: exclude zla_syamv
# Fwrap: exclude zla_syrcond_c
# Fwrap: exclude zla_syrcond_x
# Fwrap: exclude zla_syrfsx_extended
# Fwrap: exclude zla_syrpvgrw
# Fwrap: exclude zla_wwaddw
# Fwrap: exclude zlabrd
# Fwrap: exclude zlacgv
# Fwrap: exclude zlacn2
# Fwrap: exclude zlacon
# Fwrap: exclude zlacp2
# Fwrap: exclude zlacpy
# Fwrap: exclude zlacrm
# Fwrap: exclude zlacrt
# Fwrap: exclude zladiv
# Fwrap: exclude zlaed0
# Fwrap: exclude zlaed7
# Fwrap: exclude zlaed8
# Fwrap: exclude zlaein
# Fwrap: exclude zlaesy
# Fwrap: exclude zlaev2
# Fwrap: exclude zlag2c
# Fwrap: exclude zlags2
# Fwrap: exclude zlagtm
# Fwrap: exclude zlahef
# Fwrap: exclude zlahqr
# Fwrap: exclude zlahr2
# Fwrap: exclude zlahrd
# Fwrap: exclude zlaic1
# Fwrap: exclude zlals0
# Fwrap: exclude zlalsa
# Fwrap: exclude zlalsd
# Fwrap: exclude zlangb
# Fwrap: exclude zlange
# Fwrap: exclude zlangt
# Fwrap: exclude zlanhb
# Fwrap: exclude zlanhe
# Fwrap: exclude zlanhf
# Fwrap: exclude zlanhp
# Fwrap: exclude zlanhs
# Fwrap: exclude zlanht
# Fwrap: exclude zlansb
# Fwrap: exclude zlansp
# Fwrap: exclude zlansy
# Fwrap: exclude zlantb
# Fwrap: exclude zlantp
# Fwrap: exclude zlantr
# Fwrap: exclude zlapll
# Fwrap: exclude zlapmr
# Fwrap: exclude zlapmt
# Fwrap: exclude zlaqgb
# Fwrap: exclude zlaqge
# Fwrap: exclude zlaqhb
# Fwrap: exclude zlaqhe
# Fwrap: exclude zlaqhp
# Fwrap: exclude zlaqp2
# Fwrap: exclude zlaqps
# Fwrap: exclude zlaqr0
# Fwrap: exclude zlaqr1
# Fwrap: exclude zlaqr2
# Fwrap: exclude zlaqr3
# Fwrap: exclude zlaqr4
# Fwrap: exclude zlaqr5
# Fwrap: exclude zlaqsb
# Fwrap: exclude zlaqsp
# Fwrap: exclude zlaqsy
# Fwrap: exclude zlar1v
# Fwrap: exclude zlar2v
# Fwrap: exclude zlarcm
# Fwrap: exclude zlarf
# Fwrap: exclude zlarfb
# Fwrap: exclude zlarfg
# Fwrap: exclude zlarfgp
# Fwrap: exclude zlarft
# Fwrap: exclude zlarfx
# Fwrap: exclude zlargv
# Fwrap: exclude zlarnv
# Fwrap: exclude zlarrv
# Fwrap: exclude zlarscl2
# Fwrap: exclude zlartg
# Fwrap: exclude zlartv
# Fwrap: exclude zlarz
# Fwrap: exclude zlarzb
# Fwrap: exclude zlarzt
# Fwrap: exclude zlascl
# Fwrap: exclude zlascl2
# Fwrap: exclude zlaset
# Fwrap: exclude zlasr
# Fwrap: exclude zlassq
# Fwrap: exclude zlasyf
# Fwrap: exclude zlat2c
# Fwrap: exclude zlatbs
# Fwrap: exclude zlatdf
# Fwrap: exclude zlatps
# Fwrap: exclude zlatrd
# Fwrap: exclude zlatrs
# Fwrap: exclude zlatrz
# Fwrap: exclude zlatzm
# Fwrap: exclude zlauu2
# Fwrap: exclude zpbcon
# Fwrap: exclude zpbequ
# Fwrap: exclude zpbrfs
# Fwrap: exclude zpbstf
# Fwrap: exclude zpbsvx
# Fwrap: exclude zpbtf2
# Fwrap: exclude zpftrf
# Fwrap: exclude zpftri
# Fwrap: exclude zpftrs
# Fwrap: exclude zpocon
# Fwrap: exclude zpoequ
# Fwrap: exclude zpoequb
# Fwrap: exclude zporfs
# Fwrap: exclude zporfsx
# Fwrap: exclude zposvx
# Fwrap: exclude zposvxx
# Fwrap: exclude zpotf2
# Fwrap: exclude zppcon
# Fwrap: exclude zppequ
# Fwrap: exclude zpprfs
# Fwrap: exclude zppsv
# Fwrap: exclude zppsvx
# Fwrap: exclude zpptrf
# Fwrap: exclude zpptri
# Fwrap: exclude zpptrs
# Fwrap: exclude zpstf2
# Fwrap: exclude zpstrf
# Fwrap: exclude zptcon
# Fwrap: exclude zpteqr
# Fwrap: exclude zptrfs
# Fwrap: exclude zptsv
# Fwrap: exclude zptsvx
# Fwrap: exclude zpttrf
# Fwrap: exclude zpttrs
# Fwrap: exclude zptts2
# Fwrap: exclude zrot
# Fwrap: exclude zspcon
# Fwrap: exclude zspmv
# Fwrap: exclude zspr
# Fwrap: exclude zsprfs
# Fwrap: exclude zspsv
# Fwrap: exclude zspsvx
# Fwrap: exclude zsptrf
# Fwrap: exclude zsptri
# Fwrap: exclude zsptrs
# Fwrap: exclude zstedc
# Fwrap: exclude zstegr
# Fwrap: exclude zstein
# Fwrap: exclude zstemr
# Fwrap: exclude zsteqr
# Fwrap: exclude zsycon
# Fwrap: exclude zsyconv
# Fwrap: exclude zsyequb
# Fwrap: exclude zsymv
# Fwrap: exclude zsyr
# Fwrap: exclude zsyrfs
# Fwrap: exclude zsyrfsx
# Fwrap: exclude zsysv
# Fwrap: exclude zsysvx
# Fwrap: exclude zsysvxx
# Fwrap: exclude zsyswapr
# Fwrap: exclude zsytf2
# Fwrap: exclude zsytrf
# Fwrap: exclude zsytri
# Fwrap: exclude zsytri2
# Fwrap: exclude zsytri2x
# Fwrap: exclude zsytrs
# Fwrap: exclude zsytrs2
# Fwrap: exclude ztbcon
# Fwrap: exclude ztbrfs
# Fwrap: exclude ztbtrs
# Fwrap: exclude ztfsm
# Fwrap: exclude ztftri
# Fwrap: exclude ztfttp
# Fwrap: exclude ztfttr
# Fwrap: exclude ztgevc
# Fwrap: exclude ztgex2
# Fwrap: exclude ztgexc
# Fwrap: exclude ztgsen
# Fwrap: exclude ztgsja
# Fwrap: exclude ztgsna
# Fwrap: exclude ztgsy2
# Fwrap: exclude ztgsyl
# Fwrap: exclude ztpcon
# Fwrap: exclude ztprfs
# Fwrap: exclude ztptri
# Fwrap: exclude ztptrs
# Fwrap: exclude ztpttf
# Fwrap: exclude ztpttr
# Fwrap: exclude ztrcon
# Fwrap: exclude ztrevc
# Fwrap: exclude ztrexc
# Fwrap: exclude ztrrfs
# Fwrap: exclude ztrsen
# Fwrap: exclude ztrsna
# Fwrap: exclude ztrsyl
# Fwrap: exclude ztrti2
# Fwrap: exclude ztrttf
# Fwrap: exclude ztrttp
# Fwrap: exclude ztzrqf
# Fwrap: exclude ztzrzf
# Fwrap: exclude zunbdb
# Fwrap: exclude zuncsd
# Fwrap: exclude zung2l
# Fwrap: exclude zung2r
# Fwrap: exclude zungbr
# Fwrap: exclude zunghr
# Fwrap: exclude zungl2
# Fwrap: exclude zunglq
# Fwrap: exclude zungql
# Fwrap: exclude zungr2
# Fwrap: exclude zungrq
# Fwrap: exclude zungtr
# Fwrap: exclude zunm2l
# Fwrap: exclude zunm2r
# Fwrap: exclude zunmbr
# Fwrap: exclude zunmhr
# Fwrap: exclude zunml2
# Fwrap: exclude zunmlq
# Fwrap: exclude zunmql
# Fwrap: exclude zunmqr
# Fwrap: exclude zunmr2
# Fwrap: exclude zunmr3
# Fwrap: exclude zunmrq
# Fwrap: exclude zunmrz
# Fwrap: exclude zunmtr
# Fwrap: exclude zupgtr
# Fwrap: exclude zupmtr
# Fwrap: f77binding True
# Fwrap: detect-templates True
# Fwrap: emulate-f2py True
# Fwrap: auxiliary flapack.pxd
# Fwrap: auxiliary flapack.pyx.in
# Fwrap: auxiliary flapack_fc.f
# Fwrap: auxiliary flapack_fc.h
# Fwrap: auxiliary flapack_fc.pxd

