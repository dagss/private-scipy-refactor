from bento.commands.hooks \
    import \
        post_configure, pre_build
from yaku.task_manager \
    import \
        set_file_hook, get_extension_hook

from interface_gen \
    import \
        generate_interface

def generate_fake_interface(name, source, target):
    """Generate a (fake) .pyf file from another pyf file (!)."""
    # XXX handle skip names
    generate_interface(name, source, target)

    f = open(target, 'w')
    f.write('python module '+name+'\n')
    f.write('usercode void empty_module(void) {}\n')
    f.write('interface\n')
    f.write('subroutine empty_module()\n')
    f.write('intent(c) empty_module\n')
    f.write('end subroutine empty_module\n')
    f.write('end interface\nend python module'+name+'\n')
    f.close()

    return 0

# Hook to merge all included .pyf together between sending it to f2py
# this hook is registered for full filenames instead of extension, as
# the distutils build uses the same extension for both of them
def fake_merge_f2py_hook(self, node):
    return _merge_f2py_hook(self, node, fake=True)

def merge_f2py_hook(self, node):
    return _merge_f2py_hook(self, node, fake=False)

def _merge_f2py_hook(self, node, fake=True):
    # XXX: Fix this by structuring f2py_tool better
    f2py_tool = __import__("f2py_tool")
    modulename = f2py_tool.modulename

    f2py_hook = get_extension_hook(".pyf")
    base = modulename(node)
    target = node.parent.declare(base + ".pyf")
    if fake:
        generate_fake_interface(base, node.abspath(), target.abspath())
    else:
        generate_interface(base, node.abspath(), target.abspath())
    ret = f2py_hook(self, target)
    return ret

@post_configure
def myconfigure(ctx):
    cfg = ctx.yaku_configure_ctx
    ldir = ctx.local_node.path_from(ctx.top_node)

    set_file_hook(cfg, ldir + "/generic_fblas.pyf", merge_f2py_hook)
    set_file_hook(cfg, ldir + "/generic_flapack.pyf", merge_f2py_hook)

    if cfg.env.has_key("CBLAS"):
        set_file_hook(cfg, ldir + "/generic_cblas.pyf", merge_f2py_hook)
    else:
        set_file_hook(cfg, ldir + "/generic_cblas.pyf", fake_merge_f2py_hook)
    if cfg.env.has_key("CLAPACK"):
        set_file_hook(cfg, ldir + "/generic_clapack.pyf", merge_f2py_hook)
    else:
        set_file_hook(cfg, ldir + "/generic_clapack.pyf", fake_merge_f2py_hook)

@pre_build
def myprebuild(ctx):
    f2py_tool = __import__("f2py_tool")
    def fextension(bld, extension, verbose):
        builder = bld.builders["f2py_tool"].clone()
        for flag in bld.env["LAPACK"]:
            builder.env["PYEXT_%s" % flag].extend(bld.env["LAPACK"][flag])
        builder.env["PYEXT_SHLINKFLAGS"].extend(bld.env["FC_RUNTIME_LDFLAGS"])
        return builder.extension_fsources(extension.name, extension.sources)

    def custom_env_builder(bld, extension, verbose):
        builder = bld.builders["pyext"].clone()
        for flag in bld.env["LAPACK"]:
            builder.env["PYEXT_%s" % flag].extend(bld.env["LAPACK"][flag])
        builder.env["PYEXT_SHLINKFLAGS"].extend(bld.env["FC_RUNTIME_LDFLAGS"])
        return builder.extension(extension.name,
                extension.sources)

    for name in ctx.local_pkg.extensions:
        ctx.register_builder(name, custom_env_builder)
    ctx.register_builder("_flinalg", fextension)
    ctx.register_builder("calc_lwork", fextension)
