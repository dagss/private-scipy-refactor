import os
import sys
import copy
import subprocess
import re
import shutil

try:
    import numpy
except ImportError:
    raise ValueError("You should install numpy before building scipy")

from numpy.distutils.misc_util import get_numpy_include_dirs
from bento.commands.hooks \
    import \
        post_configure, pre_build, post_build, pre_configure
from bento.installed_package_description \
    import \
        InstalledSection
from yaku.conftests.conftests \
    import \
        check_compiler
from yaku.conftests.fconftests \
    import \
        check_fortran_verbose_flag, check_fortran_runtime_flags, check_fcompiler, check_fortran_mangling, check_fortran_dummy_main

def check_archs(cfg):
    archs = {"i386": False, "x86_64": False, "ppc": False, "ppc64": False}
    for arch in archs:
        old_cflags = copy.deepcopy(cfg.env["CFLAGS"])
        old_linkflags = copy.deepcopy(cfg.env["LINKFLAGS"])
        try:
            cfg.env["CFLAGS"].extend(["-arch", arch])
            cfg.env["LINKFLAGS"].extend(["-arch", arch])
            if check_compiler(cfg, "Checking whether gcc supports arch %s" % arch):
                archs[arch] = True
        finally:
            cfg.env["CFLAGS"] = old_cflags
            cfg.env["LINKFLAGS"] = old_linkflags

    for arch in archs:
        if archs[arch]:
            old_fflags = copy.deepcopy(cfg.env["F77FLAGS"])
            old_linkflags = copy.deepcopy(cfg.env["LINKFLAGS"])
            try:
                cfg.env["F77FLAGS"].extend(["-arch", arch])
                cfg.env["LINKFLAGS"].extend(["-arch", arch])
                if check_fcompiler(cfg, "Checking whether gfortran supports arch %s" % arch):
                    archs[arch] = True
            finally:
                cfg.env["F77FLAGS"] = old_fflags
                cfg.env["LINKFLAGS"] = old_linkflags

    return archs.keys()

def check_gcc_version(cfg):
    GCC_VERSION = re.compile("^gcc version (\d).(\d).(\d)")
    try:
        p = subprocess.Popen(cfg.env["PYEXT_CC"] + ["-v"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        p.wait()
        for line in p.stdout.readlines():
            m = GCC_VERSION.match(line)
            if m:
                return [int(i) for i in m.groups()]
    except OSError:
        return None

@post_configure()
def myconfigure(ctx):
    cfg = ctx.yaku_configure_ctx

    cfg.use_tools(["ctasks", "cxxtasks", "tpl_tasks"])
    cfg.load_tool("fortran")
    if sys.platform == "win32":
        cfg.builders["fortran"].configure(candidates=["ifort"])
    else:
        cfg.use_tools(["fortran"])
    cfg.use_tools(["pyext"])
    cfg.use_tools(["numpy_templates"], ["."])
    cfg.use_tools(["f2py_tool"], ["."])

    cfg.env["PYEXT_CPPPATH"].extend(get_numpy_include_dirs())

    if sys.platform == "darwin":
        cfg.env["BLAS"] = {"FRAMEWORKS": ["Accelerate"]}
        cfg.env["LAPACK"] = {"FRAMEWORKS": ["Accelerate"]}

        for arch in ["i386"]:
            cfg.env["F77FLAGS"].extend(["-arch", arch])
            cfg.env["CFLAGS"].extend(["-arch", arch])
            cfg.env["PYEXT_CFLAGS"].extend(["-arch", arch])
            cfg.env["PYEXT_SHLINKFLAGS"].extend(["-arch", arch])
            cfg.env["LINKFLAGS"].extend(["-arch", arch])

        # XXX: hack to work around gcc 4.0 vs 4.2 mismatch. This will hopefully
        # all go away once we don't rely on distutils at all for obtaining flags
        ret = check_gcc_version(cfg)
        if ret is not None:
            macro, minor, micro = ret
            if macro == 4 and minor == 0:
                cfg.env["CC"] = cfg.env["PYEXT_CC"][:]
                cfg.env["CXX"] = ["g++-4.0"]
                cfg.env["PYEXT_CXX"] = ["g++-4.0"]
                cfg.env["PYEXT_SHLINK"] = ["gcc-4.0"]
                cfg.env["PYEXT_CXXSHLINK"] = ["g++-4.0", "-shared"]
    elif sys.platform == "win32":
        for flag in ["CFLAGS", "PYEXT_CFLAGS"]:
            cfg.env[flag] = ["/MD", "/Od", "/GS-", "/DNDEBUG", "/nologo"]
        cfg.env["PYEXT_CXXFLAGS"] = ["/TP", "/MD", "/EHsc", "/Od", "/DNDEBUG", "/nologo"]
        cfg.env.extend("F77FLAGS", ["/MD", "/Od"])
        cfg.env["BLAS"] = {"LIBDIR": [r"C:\Program Files (x86)\Intel\Compiler\11.1\038\lib\intel64", r"C:\Program Files (x86)\Intel\Compiler\11.1\038\mkl\em64t\lib"],
		"LIBS": ["mkl_lapack95_lp64", "mkl_blas95_lp64", "mkl_intel_lp64", "mkl_intel_thread", "mkl_core", "libiomp5md"]}
        cfg.env["LAPACK"] = cfg.env["BLAS"]
    else:
        cfg.env["BLAS"] = {"LIBS": ["f77blas", "cblas", "atlas"]}
        cfg.env["LAPACK"] = {"LIBS": ["lapack", "f77blas",
                                      "cblas", "atlas"]}

    cfg.env["SUBST_DICT"] = {"SHORT_VERSION": "'0.8.0'",
                             "VERSION": "'0.8.0'",
                             "RELEASE": "False"}
    #for f in ["CFLAGS", "PYEXT_CFLAGS", "PYEXT_CXXFLAGS", "CXXFLAGS", "F77FLAGS"]:
    #    cfg.env[f].append("-fPIC")
    check_fortran_verbose_flag(cfg)
    check_fortran_runtime_flags(cfg)
    check_fortran_dummy_main(cfg)
    check_fortran_mangling(cfg)
    u, du, case = cfg.env["FC_MANGLING"]

    if u == "":
        cfg.env["CFLAGS"].append("/DF77_NO_APPEND_FORTRAN")
        cfg.env["CFLAGS"].append("/DNO_APPEND_FORTRAN")
        cfg.env["PYEXT_CFLAGS"].append("/DF77_NO_APPEND_FORTRAN")
        cfg.env["PYEXT_CFLAGS"].append("/DNO_APPEND_FORTRAN")
    if case == 'upper':
        cfg.env["CFLAGS"].append('/DF77_UPPERCASE_FORTRAN')
        cfg.env["CFLAGS"].append('/DUPPERCASE_FORTRAN')
        cfg.env["PYEXT_CFLAGS"].append('/DF77_UPPERCASE_FORTRAN')
        cfg.env["PYEXT_CFLAGS"].append('/DUPPERCASE_FORTRAN')
    cfg.env["PYEXT_LIBDIR"].extend(cfg.env["LIBDIR"])

@pre_build()
def prebuild(ctx):
    bld = ctx.yaku_build_ctx
    if "-v" in sys.argv:
        bld.env["VERBOSE"] = False
    else:
        bld.env["F2PYFLAGS"].append("--quiet")
        bld.env["VERBOSE"] = True

    templater = ctx.yaku_build_ctx.builders["tpl_tasks"]
    tasks = templater.build("version", ["scipy/version.py.in"])
    tasks += templater.build("__config__", ["scipy/__config__.py.in"])

    section_writer = ctx.cmd.section_writer
    section = InstalledSection(
                  "gen_pythonfiles",
                  "library",
                  os.path.join("$_srcrootdir",
                               ctx.yaku_build_ctx.env["BLDDIR"]),
                  "$sitedir",
                  [os.path.join("scipy", "version.py"),
                   os.path.join("scipy", "__config__.py")])
    section_writer.sections["pythonfiles"]["gen_files"] = section

@post_build()
def postbuild(ctx):
    bld = ctx.yaku_build_ctx

    if "-i" in sys.argv:
        for f in [os.path.join("scipy", "version.py"),
                  os.path.join("scipy", "__config__.py")]:
            source = bld.bld_root.find_node(f)
            shutil.copy(source.path_from(bld.src_root), f)
